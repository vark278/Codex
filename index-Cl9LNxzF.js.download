const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/FineTuningExamplesPage-DnSwrDqS.js","assets/createCell-U7hprdwJ.js","assets/index-DDQ4J8oI.js","assets/index-D0Co8Jlj.js","assets/dialog-BG9t_Wj-.js","assets/active-element-history-DAgXBVAG.js","assets/FineTuningPlaygroundPage-SVAphOTM.js","assets/HomePage-uN4gHFOV.js","assets/Plus-BKlRtqB2.js","assets/Separator-CEHkuZjp.js","assets/Combination-h2wFfpVw.js","assets/index-Ez3RBrjm.js","assets/Navbar-CLdfE-V6.js","assets/load-parse-BKw6L76i.js","assets/Card-r7Zt7VH-.js","assets/Button-CRKomIYF.js","assets/Badge-D4DGIR9F.js","assets/LoginPage-C9r9Ylin.js","assets/MetaTags-CmcLIMFC.js","assets/LogoutPage-ARGV1b5F.js","assets/PluginInstructionsPage-CFo60cxG.js","assets/Metadata-B7_Ys_tM.js","assets/PurchaseSuccessPage-B41kUWwa.js","assets/RecentSignupsPage-2iSg3HK3.js","assets/useLazyQuery-DFCItMZ_.js","assets/useQuery-faDc5fLx.js","assets/useIsomorphicLayoutEffect-F2nMQFbM.js","assets/useMutation-DnK8pHbw.js","assets/SignupPage-CZwdwKYb.js","assets/TemplateEditorEditPage-CjkcHG0v.js","assets/fonts-DZXULzre.js","assets/server.browser-O9vzoZ4C.js","assets/carouselHelper-CtoMj_6p.js","assets/media-2DxFk87J.js","assets/Label-DpOdY4Is.js","assets/chevron-down-BQGOQx1R.js","assets/createLucideIcon-1XxAFDZR.js","assets/check-TI83qRqu.js","assets/Input-CPWCm9FW.js","assets/TemplateEditorNewPage-C-ZgZO7L.js","assets/index-gVIrpAIC.js","assets/TemplateEditorPage-CSTkdqIw.js","assets/TemplateEditorValidatorPage-CMTTA8PS.js","assets/TemplateSectionEditPage-DCZ-NTEI.js","assets/TemplateSectionsPage-DfhFrPAU.js","assets/TrainingWebsitesEditPage-C8yYujh5.js","assets/TrainingWebsitesPage-BzEXt-5o.js","assets/UpgradePurchaseSuccessPage-D-kwnTQM.js","assets/WebsiteChatPage-VebCn-tN.js","assets/loader-circle-B9kYIkFb.js","assets/Accordion-DvHzgFZ1.js","assets/react-remark.esm-CcPB2AHY.js","assets/initialContent-D_1K8jpX.js","assets/WebsiteChatSettingsPage-CeKMBZP6.js","assets/Alert-DC_ga3dY.js","assets/copy-CwEqgM6F.js","assets/Tooltip-CoSRkd08.js","assets/external-link-Bv_kRowz.js","assets/WebsitePreviewPage-CNudNwJO.js","assets/DomainAddPage-Dui3Di5u.js","assets/DomainConfirmDnsPage-WTGzAe-r.js","assets/DnsRecordManager-DfqnI7dn.js","assets/DomainPage-DbOVy7Wx.js","assets/DomainSearchPage-Pp6UoDnH.js","assets/DomainVerifyNameserversPage-QH6lKLci.js","assets/DomainsPage-BCsxmRU3.js","assets/ChatTemplatePage-CsRyD_fm.js","assets/ChatTemplatesPage-BHazjiT7.js","assets/formatters-6-0OGv3W.js","assets/EditChatTemplatePage-DA0YWz9_.js","assets/ChatTemplateForm-DG_pCnHR.js","assets/NewChatTemplatePage-CuWW9GMm.js","assets/PreviewChatTemplatePage-idXFkrvX.js","assets/EditKVStoragePage-BDqX34St.js","assets/KVStorageForm-zhbtVygI.js","assets/KVStoragePage-1T1JCZsm.js","assets/KVStoragesPage-DEtm2gE7.js","assets/NewKVStoragePage-DVcAqQYl.js","assets/EditTemplatePage-CM93fTWh.js","assets/TemplateForm-smt52w7l.js","assets/NewTemplatePage-9rEctMb7.js","assets/TemplatePage-Cyv1AT_d.js","assets/TemplatesPage-PgF6rR7v.js","assets/UserPage-Bg05icDF.js","assets/Table-DHQRDsBJ.js","assets/UsersPage-BwQ2e3rf.js"])))=>i.map(i=>d[i]);
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var _a2, _b, _c;
function _mergeNamespaces(n2, m3) {
  for (var i2 = 0; i2 < m3.length; i2++) {
    const e2 = m3[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d3 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d3) {
            Object.defineProperty(n2, k2, d3.get ? d3 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule) return n2;
  var f3 = n2.default;
  if (typeof f3 == "function") {
    var a3 = function a4() {
      if (this instanceof a4) {
        return Reflect.construct(f3, arguments, this.constructor);
      }
      return f3.apply(this, arguments);
    };
    a3.prototype = f3.prototype;
  } else a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d3 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a3, k2, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$7 = Symbol.for("react.element"), n$9 = Symbol.for("react.portal"), p$8 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$6 = Symbol.for("react.provider"), u$9 = Symbol.for("react.context"), v$5 = Symbol.for("react.forward_ref"), w$6 = Symbol.for("react.suspense"), x$4 = Symbol.for("react.memo"), y$6 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$6(a3) {
  if (null === a3 || "object" !== typeof a3) return null;
  a3 = z$3 && a3[z$3] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$6 = Object.assign, D$5 = {};
function E$6(a3, b2, e2) {
  this.props = a3;
  this.context = b2;
  this.refs = D$5;
  this.updater = e2 || B$3;
}
E$6.prototype.isReactComponent = {};
E$6.prototype.setState = function(a3, b2) {
  if ("object" !== typeof a3 && "function" !== typeof a3 && null != a3) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a3, b2, "setState");
};
E$6.prototype.forceUpdate = function(a3) {
  this.updater.enqueueForceUpdate(this, a3, "forceUpdate");
};
function F$5() {
}
F$5.prototype = E$6.prototype;
function G$4(a3, b2, e2) {
  this.props = a3;
  this.context = b2;
  this.refs = D$5;
  this.updater = e2 || B$3;
}
var H$6 = G$4.prototype = new F$5();
H$6.constructor = G$4;
C$6(H$6, E$6.prototype);
H$6.isPureReactComponent = true;
var I$6 = Array.isArray, J$5 = Object.prototype.hasOwnProperty, K$4 = { current: null }, L$5 = { key: true, ref: true, __self: true, __source: true };
function M$7(a3, b2, e2) {
  var d3, c2 = {}, k2 = null, h3 = null;
  if (null != b2) for (d3 in void 0 !== b2.ref && (h3 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J$5.call(b2, d3) && !L$5.hasOwnProperty(d3) && (c2[d3] = b2[d3]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f3 = Array(g2), m3 = 0; m3 < g2; m3++) f3[m3] = arguments[m3 + 2];
    c2.children = f3;
  }
  if (a3 && a3.defaultProps) for (d3 in g2 = a3.defaultProps, g2) void 0 === c2[d3] && (c2[d3] = g2[d3]);
  return { $$typeof: l$7, type: a3, key: k2, ref: h3, props: c2, _owner: K$4.current };
}
function N$4(a3, b2) {
  return { $$typeof: l$7, type: a3.type, key: b2, ref: a3.ref, props: a3.props, _owner: a3._owner };
}
function O$7(a3) {
  return "object" === typeof a3 && null !== a3 && a3.$$typeof === l$7;
}
function escape(a3) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a3.replace(/[=:]/g, function(a22) {
    return b2[a22];
  });
}
var P$7 = /\/+/g;
function Q$4(a3, b2) {
  return "object" === typeof a3 && null !== a3 && null != a3.key ? escape("" + a3.key) : b2.toString(36);
}
function R$6(a3, b2, e2, d3, c2) {
  var k2 = typeof a3;
  if ("undefined" === k2 || "boolean" === k2) a3 = null;
  var h3 = false;
  if (null === a3) h3 = true;
  else switch (k2) {
    case "string":
    case "number":
      h3 = true;
      break;
    case "object":
      switch (a3.$$typeof) {
        case l$7:
        case n$9:
          h3 = true;
      }
  }
  if (h3) return h3 = a3, c2 = c2(h3), a3 = "" === d3 ? "." + Q$4(h3, 0) : d3, I$6(c2) ? (e2 = "", null != a3 && (e2 = a3.replace(P$7, "$&/") + "/"), R$6(c2, b2, e2, "", function(a22) {
    return a22;
  })) : null != c2 && (O$7(c2) && (c2 = N$4(c2, e2 + (!c2.key || h3 && h3.key === c2.key ? "" : ("" + c2.key).replace(P$7, "$&/") + "/") + a3)), b2.push(c2)), 1;
  h3 = 0;
  d3 = "" === d3 ? "." : d3 + ":";
  if (I$6(a3)) for (var g2 = 0; g2 < a3.length; g2++) {
    k2 = a3[g2];
    var f3 = d3 + Q$4(k2, g2);
    h3 += R$6(k2, b2, e2, f3, c2);
  }
  else if (f3 = A$6(a3), "function" === typeof f3) for (a3 = f3.call(a3), g2 = 0; !(k2 = a3.next()).done; ) k2 = k2.value, f3 = d3 + Q$4(k2, g2++), h3 += R$6(k2, b2, e2, f3, c2);
  else if ("object" === k2) throw b2 = String(a3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a3).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h3;
}
function S$6(a3, b2, e2) {
  if (null == a3) return a3;
  var d3 = [], c2 = 0;
  R$6(a3, d3, "", "", function(a22) {
    return b2.call(e2, a22, c2++);
  });
  return d3;
}
function T$7(a3) {
  if (-1 === a3._status) {
    var b2 = a3._result;
    b2 = b2();
    b2.then(function(b22) {
      if (0 === a3._status || -1 === a3._status) a3._status = 1, a3._result = b22;
    }, function(b22) {
      if (0 === a3._status || -1 === a3._status) a3._status = 2, a3._result = b22;
    });
    -1 === a3._status && (a3._status = 0, a3._result = b2);
  }
  if (1 === a3._status) return a3._result.default;
  throw a3._result;
}
var U$6 = { current: null }, V$5 = { transition: null }, W$5 = { ReactCurrentDispatcher: U$6, ReactCurrentBatchConfig: V$5, ReactCurrentOwner: K$4 };
function X$6() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$6, forEach: function(a3, b2, e2) {
  S$6(a3, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a3) {
  var b2 = 0;
  S$6(a3, function() {
    b2++;
  });
  return b2;
}, toArray: function(a3) {
  return S$6(a3, function(a22) {
    return a22;
  }) || [];
}, only: function(a3) {
  if (!O$7(a3)) throw Error("React.Children.only expected to receive a single React element child.");
  return a3;
} };
react_production_min.Component = E$6;
react_production_min.Fragment = p$8;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$4;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$6;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$5;
react_production_min.act = X$6;
react_production_min.cloneElement = function(a3, b2, e2) {
  if (null === a3 || void 0 === a3) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a3 + ".");
  var d3 = C$6({}, a3.props), c2 = a3.key, k2 = a3.ref, h3 = a3._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h3 = K$4.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a3.type && a3.type.defaultProps) var g2 = a3.type.defaultProps;
    for (f3 in b2) J$5.call(b2, f3) && !L$5.hasOwnProperty(f3) && (d3[f3] = void 0 === b2[f3] && void 0 !== g2 ? g2[f3] : b2[f3]);
  }
  var f3 = arguments.length - 2;
  if (1 === f3) d3.children = e2;
  else if (1 < f3) {
    g2 = Array(f3);
    for (var m3 = 0; m3 < f3; m3++) g2[m3] = arguments[m3 + 2];
    d3.children = g2;
  }
  return { $$typeof: l$7, type: a3.type, key: c2, ref: k2, props: d3, _owner: h3 };
};
react_production_min.createContext = function(a3) {
  a3 = { $$typeof: u$9, _currentValue: a3, _currentValue2: a3, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a3.Provider = { $$typeof: t$6, _context: a3 };
  return a3.Consumer = a3;
};
react_production_min.createElement = M$7;
react_production_min.createFactory = function(a3) {
  var b2 = M$7.bind(null, a3);
  b2.type = a3;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a3) {
  return { $$typeof: v$5, render: a3 };
};
react_production_min.isValidElement = O$7;
react_production_min.lazy = function(a3) {
  return { $$typeof: y$6, _payload: { _status: -1, _result: a3 }, _init: T$7 };
};
react_production_min.memo = function(a3, b2) {
  return { $$typeof: x$4, type: a3, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a3) {
  var b2 = V$5.transition;
  V$5.transition = {};
  try {
    a3();
  } finally {
    V$5.transition = b2;
  }
};
react_production_min.unstable_act = X$6;
react_production_min.useCallback = function(a3, b2) {
  return U$6.current.useCallback(a3, b2);
};
react_production_min.useContext = function(a3) {
  return U$6.current.useContext(a3);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a3) {
  return U$6.current.useDeferredValue(a3);
};
react_production_min.useEffect = function(a3, b2) {
  return U$6.current.useEffect(a3, b2);
};
react_production_min.useId = function() {
  return U$6.current.useId();
};
react_production_min.useImperativeHandle = function(a3, b2, e2) {
  return U$6.current.useImperativeHandle(a3, b2, e2);
};
react_production_min.useInsertionEffect = function(a3, b2) {
  return U$6.current.useInsertionEffect(a3, b2);
};
react_production_min.useLayoutEffect = function(a3, b2) {
  return U$6.current.useLayoutEffect(a3, b2);
};
react_production_min.useMemo = function(a3, b2) {
  return U$6.current.useMemo(a3, b2);
};
react_production_min.useReducer = function(a3, b2, e2) {
  return U$6.current.useReducer(a3, b2, e2);
};
react_production_min.useRef = function(a3) {
  return U$6.current.useRef(a3);
};
react_production_min.useState = function(a3) {
  return U$6.current.useState(a3);
};
react_production_min.useSyncExternalStore = function(a3, b2, e2) {
  return U$6.current.useSyncExternalStore(a3, b2, e2);
};
react_production_min.useTransition = function() {
  return U$6.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React$2 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$3 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$2
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$7 = reactExports, k$2 = Symbol.for("react.element"), l$6 = Symbol.for("react.fragment"), m$7 = Object.prototype.hasOwnProperty, n$8 = f$7.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$7 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a3, g2) {
  var b2, d3 = {}, e2 = null, h3 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a3.key && (e2 = "" + a3.key);
  void 0 !== a3.ref && (h3 = a3.ref);
  for (b2 in a3) m$7.call(a3, b2) && !p$7.hasOwnProperty(b2) && (d3[b2] = a3[b2]);
  if (c2 && c2.defaultProps) for (b2 in a3 = c2.defaultProps, a3) void 0 === d3[b2] && (d3[b2] = a3[b2]);
  return { $$typeof: k$2, type: c2, key: e2, ref: h3, props: d3, _owner: n$8.current };
}
reactJsxRuntime_production_min.Fragment = l$6;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
(function(exports) {
  /**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function f3(a3, b2) {
    var c2 = a3.length;
    a3.push(b2);
    a: for (; 0 < c2; ) {
      var d3 = c2 - 1 >>> 1, e2 = a3[d3];
      if (0 < g2(e2, b2)) a3[d3] = b2, a3[c2] = e2, c2 = d3;
      else break a;
    }
  }
  function h3(a3) {
    return 0 === a3.length ? null : a3[0];
  }
  function k2(a3) {
    if (0 === a3.length) return null;
    var b2 = a3[0], c2 = a3.pop();
    if (c2 !== b2) {
      a3[0] = c2;
      a: for (var d3 = 0, e2 = a3.length, w2 = e2 >>> 1; d3 < w2; ) {
        var m3 = 2 * (d3 + 1) - 1, C2 = a3[m3], n2 = m3 + 1, x2 = a3[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a3[d3] = x2, a3[n2] = c2, d3 = n2) : (a3[d3] = C2, a3[m3] = c2, d3 = m3);
        else if (n2 < e2 && 0 > g2(x2, c2)) a3[d3] = x2, a3[n2] = c2, d3 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a3, b2) {
    var c2 = a3.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a3.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l3 = performance;
    exports.unstable_now = function() {
      return l3.now();
    };
  } else {
    var p3 = Date, q2 = p3.now();
    exports.unstable_now = function() {
      return p3.now() - q2;
    };
  }
  var r2 = [], t2 = [], u3 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a3) {
    for (var b2 = h3(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a3) k2(t2), b2.sortIndex = b2.expirationTime, f3(r2, b2);
      else break;
      b2 = h3(t2);
    }
  }
  function H2(a3) {
    B2 = false;
    G2(a3);
    if (!A2) if (null !== h3(r2)) A2 = true, I2(J2);
    else {
      var b2 = h3(t2);
      null !== b2 && K2(H2, b2.startTime - a3);
    }
  }
  function J2(a3, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h3(r2); null !== v2 && (!(v2.expirationTime > b2) || a3 && !M2()); ) {
        var d3 = v2.callback;
        if ("function" === typeof d3) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d3(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h3(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h3(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m3 = h3(t2);
        null !== m3 && K2(H2, m3.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P3 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P3 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a3 = exports.unstable_now();
      Q2 = a3;
      var b2 = true;
      try {
        b2 = O2(true, a3);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a3) {
    O2 = a3;
    N2 || (N2 = true, S2());
  }
  function K2(a3, b2) {
    L2 = D2(function() {
      a3(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a3) {
    a3.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a3) {
    0 > a3 || 125 < a3 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P3 = 0 < a3 ? Math.floor(1e3 / a3) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h3(r2);
  };
  exports.unstable_next = function(a3) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a3();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a3, b2) {
    switch (a3) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a3 = 3;
    }
    var c2 = y2;
    y2 = a3;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a3, b2, c2) {
    var d3 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d3 + c2 : d3) : c2 = d3;
    switch (a3) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a3 = { id: u3++, callback: b2, priorityLevel: a3, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d3 ? (a3.sortIndex = c2, f3(t2, a3), null === h3(r2) && a3 === h3(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d3))) : (a3.sortIndex = e2, f3(r2, a3), A2 || z2 || (A2 = true, I2(J2)));
    return a3;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a3) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a3.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$6(a3) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a3, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a3 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a3, b2) {
  ha(a3, b2);
  ha(a3 + "Capture", b2);
}
function ha(a3, b2) {
  ea[a3] = b2;
  for (a3 = 0; a3 < b2.length; a3++) da.add(b2[a3]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a3) {
  if (ja.call(ma, a3)) return true;
  if (ja.call(la, a3)) return false;
  if (ka.test(a3)) return ma[a3] = true;
  la[a3] = true;
  return false;
}
function pa(a3, b2, c2, d3) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d3) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a3 = a3.toLowerCase().slice(0, 5);
      return "data-" !== a3 && "aria-" !== a3;
    default:
      return false;
  }
}
function qa(a3, b2, c2, d3) {
  if (null === b2 || "undefined" === typeof b2 || pa(a3, b2, c2, d3)) return true;
  if (d3) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$4(a3, b2, c2, d3, e2, f3, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d3;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a3;
  this.type = b2;
  this.sanitizeURL = f3;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
  z$2[a3] = new v$4(a3, 0, false, a3, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
  var b2 = a3[0];
  z$2[b2] = new v$4(b2, 1, false, a3[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 2, false, a3.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 2, false, a3, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
  z$2[a3] = new v$4(a3, 3, false, a3.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 3, true, a3, null, false, false);
});
["capture", "download"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 4, false, a3, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 6, false, a3, null, false, false);
});
["rowSpan", "start"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 5, false, a3.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a3) {
  return a3[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
  var b2 = a3.replace(
    ra,
    sa
  );
  z$2[b2] = new v$4(b2, 1, false, a3, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
  var b2 = a3.replace(ra, sa);
  z$2[b2] = new v$4(b2, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
  var b2 = a3.replace(ra, sa);
  z$2[b2] = new v$4(b2, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 1, false, a3.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$4("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a3) {
  z$2[a3] = new v$4(a3, 1, false, a3.toLowerCase(), null, true, true);
});
function ta(a3, b2, c2, d3) {
  var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d3 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d3) && (c2 = null), d3 || null === e2 ? oa(b2) && (null === c2 ? a3.removeAttribute(b2) : a3.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a3[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d3 = e2.attributeNamespace, null === c2 ? a3.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d3 ? a3.setAttributeNS(d3, b2, c2) : a3.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a3) {
  if (null === a3 || "object" !== typeof a3) return null;
  a3 = Ja && a3[Ja] || a3["@@iterator"];
  return "function" === typeof a3 ? a3 : null;
}
var A$5 = Object.assign, La;
function Ma(a3) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a3;
}
var Na = false;
function Oa(a3, b2) {
  if (!a3 || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l3) {
        var d3 = l3;
      }
      Reflect.construct(a3, [], b2);
    } else {
      try {
        b2.call();
      } catch (l3) {
        d3 = l3;
      }
      a3.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l3) {
        d3 = l3;
      }
      a3();
    }
  } catch (l3) {
    if (l3 && d3 && "string" === typeof l3.stack) {
      for (var e2 = l3.stack.split("\n"), f3 = d3.stack.split("\n"), g2 = e2.length - 1, h3 = f3.length - 1; 1 <= g2 && 0 <= h3 && e2[g2] !== f3[h3]; ) h3--;
      for (; 1 <= g2 && 0 <= h3; g2--, h3--) if (e2[g2] !== f3[h3]) {
        if (1 !== g2 || 1 !== h3) {
          do
            if (g2--, h3--, 0 > h3 || e2[g2] !== f3[h3]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a3.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a3.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h3);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a3 = a3 ? a3.displayName || a3.name : "") ? Ma(a3) : "";
}
function Pa(a3) {
  switch (a3.tag) {
    case 5:
      return Ma(a3.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a3 = Oa(a3.type, false), a3;
    case 11:
      return a3 = Oa(a3.type.render, false), a3;
    case 1:
      return a3 = Oa(a3.type, true), a3;
    default:
      return "";
  }
}
function Qa(a3) {
  if (null == a3) return null;
  if ("function" === typeof a3) return a3.displayName || a3.name || null;
  if ("string" === typeof a3) return a3;
  switch (a3) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a3) switch (a3.$$typeof) {
    case Ca:
      return (a3.displayName || "Context") + ".Consumer";
    case Ba:
      return (a3._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a3.render;
      a3 = a3.displayName;
      a3 || (a3 = b2.displayName || b2.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
      return a3;
    case Ga:
      return b2 = a3.displayName || null, null !== b2 ? b2 : Qa(a3.type) || "Memo";
    case Ha:
      b2 = a3._payload;
      a3 = a3._init;
      try {
        return Qa(a3(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a3) {
  var b2 = a3.type;
  switch (a3.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a3 = b2.render, a3 = a3.displayName || a3.name || "", b2.displayName || ("" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a3) {
  switch (typeof a3) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a3;
    case "object":
      return a3;
    default:
      return "";
  }
}
function Ta(a3) {
  var b2 = a3.type;
  return (a3 = a3.nodeName) && "input" === a3.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a3) {
  var b2 = Ta(a3) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b2), d3 = "" + a3[b2];
  if (!a3.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f3 = c2.set;
    Object.defineProperty(a3, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a22) {
      d3 = "" + a22;
      f3.call(this, a22);
    } });
    Object.defineProperty(a3, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d3;
    }, setValue: function(a22) {
      d3 = "" + a22;
    }, stopTracking: function() {
      a3._valueTracker = null;
      delete a3[b2];
    } };
  }
}
function Va(a3) {
  a3._valueTracker || (a3._valueTracker = Ua(a3));
}
function Wa(a3) {
  if (!a3) return false;
  var b2 = a3._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d3 = "";
  a3 && (d3 = Ta(a3) ? a3.checked ? "true" : "false" : a3.value);
  a3 = d3;
  return a3 !== c2 ? (b2.setValue(a3), true) : false;
}
function Xa(a3) {
  a3 = a3 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a3) return null;
  try {
    return a3.activeElement || a3.body;
  } catch (b2) {
    return a3.body;
  }
}
function Ya(a3, b2) {
  var c2 = b2.checked;
  return A$5({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a3._wrapperState.initialChecked });
}
function Za(a3, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d3 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a3._wrapperState = { initialChecked: d3, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a3, b2) {
  b2 = b2.checked;
  null != b2 && ta(a3, "checked", b2, false);
}
function bb(a3, b2) {
  ab(a3, b2);
  var c2 = Sa(b2.value), d3 = b2.type;
  if (null != c2) if ("number" === d3) {
    if (0 === c2 && "" === a3.value || a3.value != c2) a3.value = "" + c2;
  } else a3.value !== "" + c2 && (a3.value = "" + c2);
  else if ("submit" === d3 || "reset" === d3) {
    a3.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a3, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a3, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a3.defaultChecked = !!b2.defaultChecked);
}
function db(a3, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d3 = b2.type;
    if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a3._wrapperState.initialValue;
    c2 || b2 === a3.value || (a3.value = b2);
    a3.defaultValue = b2;
  }
  c2 = a3.name;
  "" !== c2 && (a3.name = "");
  a3.defaultChecked = !!a3._wrapperState.initialChecked;
  "" !== c2 && (a3.name = c2);
}
function cb(a3, b2, c2) {
  if ("number" !== b2 || Xa(a3.ownerDocument) !== a3) null == c2 ? a3.defaultValue = "" + a3._wrapperState.initialValue : a3.defaultValue !== "" + c2 && (a3.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a3, b2, c2, d3) {
  a3 = a3.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a3.length; c2++) e2 = b2.hasOwnProperty("$" + a3[c2].value), a3[c2].selected !== e2 && (a3[c2].selected = e2), e2 && d3 && (a3[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a3.length; e2++) {
      if (a3[e2].value === c2) {
        a3[e2].selected = true;
        d3 && (a3[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a3[e2].disabled || (b2 = a3[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a3, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$6(91));
  return A$5({}, b2, { value: void 0, defaultValue: void 0, children: "" + a3._wrapperState.initialValue });
}
function hb(a3, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$6(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$6(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a3._wrapperState = { initialValue: Sa(c2) };
}
function ib(a3, b2) {
  var c2 = Sa(b2.value), d3 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a3.value && (a3.value = c2), null == b2.defaultValue && a3.defaultValue !== c2 && (a3.defaultValue = c2));
  null != d3 && (a3.defaultValue = "" + d3);
}
function jb(a3) {
  var b2 = a3.textContent;
  b2 === a3._wrapperState.initialValue && "" !== b2 && null !== b2 && (a3.value = b2);
}
function kb(a3) {
  switch (a3) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a3, b2) {
  return null == a3 || "http://www.w3.org/1999/xhtml" === a3 ? kb(b2) : "http://www.w3.org/2000/svg" === a3 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a3;
}
var mb, nb = function(a3) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d3, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a3(b2, c2, d3, e2);
    });
  } : a3;
}(function(a3, b2) {
  if ("http://www.w3.org/2000/svg" !== a3.namespaceURI || "innerHTML" in a3) a3.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a3.firstChild; ) a3.removeChild(a3.firstChild);
    for (; b2.firstChild; ) a3.appendChild(b2.firstChild);
  }
});
function ob(a3, b2) {
  if (b2) {
    var c2 = a3.firstChild;
    if (c2 && c2 === a3.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a3.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a3) {
  qb.forEach(function(b2) {
    b2 = b2 + a3.charAt(0).toUpperCase() + a3.substring(1);
    pb[b2] = pb[a3];
  });
});
function rb(a3, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a3) && pb[a3] ? ("" + b2).trim() : b2 + "px";
}
function sb(a3, b2) {
  a3 = a3.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d3 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d3);
    "float" === c2 && (c2 = "cssFloat");
    d3 ? a3.setProperty(c2, e2) : a3[c2] = e2;
  }
}
var tb = A$5({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a3, b2) {
  if (b2) {
    if (tb[a3] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$6(137, a3));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$6(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$6(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$6(62));
  }
}
function vb(a3, b2) {
  if (-1 === a3.indexOf("-")) return "string" === typeof b2.is;
  switch (a3) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a3) {
  a3 = a3.target || a3.srcElement || window;
  a3.correspondingUseElement && (a3 = a3.correspondingUseElement);
  return 3 === a3.nodeType ? a3.parentNode : a3;
}
var yb = null, zb = null, Ab = null;
function Bb(a3) {
  if (a3 = Cb(a3)) {
    if ("function" !== typeof yb) throw Error(p$6(280));
    var b2 = a3.stateNode;
    b2 && (b2 = Db(b2), yb(a3.stateNode, a3.type, b2));
  }
}
function Eb(a3) {
  zb ? Ab ? Ab.push(a3) : Ab = [a3] : zb = a3;
}
function Fb() {
  if (zb) {
    var a3 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a3);
    if (b2) for (a3 = 0; a3 < b2.length; a3++) Bb(b2[a3]);
  }
}
function Gb(a3, b2) {
  return a3(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a3, b2, c2) {
  if (Ib) return a3(b2, c2);
  Ib = true;
  try {
    return Gb(a3, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a3, b2) {
  var c2 = a3.stateNode;
  if (null === c2) return null;
  var d3 = Db(c2);
  if (null === d3) return null;
  c2 = d3[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d3 = !d3.disabled) || (a3 = a3.type, d3 = !("button" === a3 || "input" === a3 || "select" === a3 || "textarea" === a3));
      a3 = !d3;
      break a;
    default:
      a3 = false;
  }
  if (a3) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$6(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a3) {
  Lb = false;
}
function Nb(a3, b2, c2, d3, e2, f3, g2, h3, k2) {
  var l3 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l3);
  } catch (m3) {
    this.onError(m3);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a3) {
  Ob = true;
  Pb = a3;
} };
function Tb(a3, b2, c2, d3, e2, f3, g2, h3, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a3, b2, c2, d3, e2, f3, g2, h3, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l3 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$6(198));
    Qb || (Qb = true, Rb = l3);
  }
}
function Vb(a3) {
  var b2 = a3, c2 = a3;
  if (a3.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a3 = b2;
    do
      b2 = a3, 0 !== (b2.flags & 4098) && (c2 = b2.return), a3 = b2.return;
    while (a3);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a3) {
  if (13 === a3.tag) {
    var b2 = a3.memoizedState;
    null === b2 && (a3 = a3.alternate, null !== a3 && (b2 = a3.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a3) {
  if (Vb(a3) !== a3) throw Error(p$6(188));
}
function Yb(a3) {
  var b2 = a3.alternate;
  if (!b2) {
    b2 = Vb(a3);
    if (null === b2) throw Error(p$6(188));
    return b2 !== a3 ? null : a3;
  }
  for (var c2 = a3, d3 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f3 = e2.alternate;
    if (null === f3) {
      d3 = e2.return;
      if (null !== d3) {
        c2 = d3;
        continue;
      }
      break;
    }
    if (e2.child === f3.child) {
      for (f3 = e2.child; f3; ) {
        if (f3 === c2) return Xb(e2), a3;
        if (f3 === d3) return Xb(e2), b2;
        f3 = f3.sibling;
      }
      throw Error(p$6(188));
    }
    if (c2.return !== d3.return) c2 = e2, d3 = f3;
    else {
      for (var g2 = false, h3 = e2.child; h3; ) {
        if (h3 === c2) {
          g2 = true;
          c2 = e2;
          d3 = f3;
          break;
        }
        if (h3 === d3) {
          g2 = true;
          d3 = e2;
          c2 = f3;
          break;
        }
        h3 = h3.sibling;
      }
      if (!g2) {
        for (h3 = f3.child; h3; ) {
          if (h3 === c2) {
            g2 = true;
            c2 = f3;
            d3 = e2;
            break;
          }
          if (h3 === d3) {
            g2 = true;
            d3 = f3;
            c2 = e2;
            break;
          }
          h3 = h3.sibling;
        }
        if (!g2) throw Error(p$6(189));
      }
    }
    if (c2.alternate !== d3) throw Error(p$6(190));
  }
  if (3 !== c2.tag) throw Error(p$6(188));
  return c2.stateNode.current === c2 ? a3 : b2;
}
function Zb(a3) {
  a3 = Yb(a3);
  return null !== a3 ? $b(a3) : null;
}
function $b(a3) {
  if (5 === a3.tag || 6 === a3.tag) return a3;
  for (a3 = a3.child; null !== a3; ) {
    var b2 = $b(a3);
    if (null !== b2) return b2;
    a3 = a3.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a3) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a3, void 0, 128 === (a3.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a3) {
  a3 >>>= 0;
  return 0 === a3 ? 32 : 31 - (pc(a3) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a3) {
  switch (a3 & -a3) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a3 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a3 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a3;
  }
}
function uc(a3, b2) {
  var c2 = a3.pendingLanes;
  if (0 === c2) return 0;
  var d3 = 0, e2 = a3.suspendedLanes, f3 = a3.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h3 = g2 & ~e2;
    0 !== h3 ? d3 = tc(h3) : (f3 &= g2, 0 !== f3 && (d3 = tc(f3)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d3 = tc(g2) : 0 !== f3 && (d3 = tc(f3));
  if (0 === d3) return 0;
  if (0 !== b2 && b2 !== d3 && 0 === (b2 & e2) && (e2 = d3 & -d3, f3 = b2 & -b2, e2 >= f3 || 16 === e2 && 0 !== (f3 & 4194240))) return b2;
  0 !== (d3 & 4) && (d3 |= c2 & 16);
  b2 = a3.entangledLanes;
  if (0 !== b2) for (a3 = a3.entanglements, b2 &= d3; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d3 |= a3[c2], b2 &= ~e2;
  return d3;
}
function vc(a3, b2) {
  switch (a3) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a3, b2) {
  for (var c2 = a3.suspendedLanes, d3 = a3.pingedLanes, e2 = a3.expirationTimes, f3 = a3.pendingLanes; 0 < f3; ) {
    var g2 = 31 - oc(f3), h3 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h3 & c2) || 0 !== (h3 & d3)) e2[g2] = vc(h3, b2);
    } else k2 <= b2 && (a3.expiredLanes |= h3);
    f3 &= ~h3;
  }
}
function xc(a3) {
  a3 = a3.pendingLanes & -1073741825;
  return 0 !== a3 ? a3 : a3 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a3 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a3;
}
function zc(a3) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a3);
  return b2;
}
function Ac(a3, b2, c2) {
  a3.pendingLanes |= b2;
  536870912 !== b2 && (a3.suspendedLanes = 0, a3.pingedLanes = 0);
  a3 = a3.eventTimes;
  b2 = 31 - oc(b2);
  a3[b2] = c2;
}
function Bc(a3, b2) {
  var c2 = a3.pendingLanes & ~b2;
  a3.pendingLanes = b2;
  a3.suspendedLanes = 0;
  a3.pingedLanes = 0;
  a3.expiredLanes &= b2;
  a3.mutableReadLanes &= b2;
  a3.entangledLanes &= b2;
  b2 = a3.entanglements;
  var d3 = a3.eventTimes;
  for (a3 = a3.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f3 = 1 << e2;
    b2[e2] = 0;
    d3[e2] = -1;
    a3[e2] = -1;
    c2 &= ~f3;
  }
}
function Cc(a3, b2) {
  var c2 = a3.entangledLanes |= b2;
  for (a3 = a3.entanglements; c2; ) {
    var d3 = 31 - oc(c2), e2 = 1 << d3;
    e2 & b2 | a3[d3] & b2 && (a3[d3] |= b2);
    c2 &= ~e2;
  }
}
var C$5 = 0;
function Dc(a3) {
  a3 &= -a3;
  return 1 < a3 ? 4 < a3 ? 0 !== (a3 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a3, b2) {
  switch (a3) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a3, b2, c2, d3, e2, f3) {
  if (null === a3 || a3.nativeEvent !== f3) return a3 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d3, nativeEvent: f3, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a3;
  a3.eventSystemFlags |= d3;
  b2 = a3.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a3;
}
function Uc(a3, b2, c2, d3, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a3, b2, c2, d3, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a3, b2, c2, d3, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a3, b2, c2, d3, e2), true;
    case "pointerover":
      var f3 = e2.pointerId;
      Oc.set(f3, Tc(Oc.get(f3) || null, a3, b2, c2, d3, e2));
      return true;
    case "gotpointercapture":
      return f3 = e2.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a3, b2, c2, d3, e2)), true;
  }
  return false;
}
function Vc(a3) {
  var b2 = Wc(a3.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a3.blockedOn = b2;
          Ic(a3.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a3.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a3.blockedOn = null;
}
function Xc(a3) {
  if (null !== a3.blockedOn) return false;
  for (var b2 = a3.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a3.domEventName, a3.eventSystemFlags, b2[0], a3.nativeEvent);
    if (null === c2) {
      c2 = a3.nativeEvent;
      var d3 = new c2.constructor(c2.type, c2);
      wb = d3;
      c2.target.dispatchEvent(d3);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a3.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a3, b2, c2) {
  Xc(a3) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a3, b2) {
  a3.blockedOn === b2 && (a3.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a3) {
  function b2(b22) {
    return ad(b22, a3);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a3);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d3 = Kc[c2];
      d3.blockedOn === a3 && (d3.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a3);
  null !== Mc && ad(Mc, a3);
  null !== Nc && ad(Nc, a3);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d3 = Qc[c2], d3.blockedOn === a3 && (d3.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a3, b2, c2, d3) {
  var e2 = C$5, f3 = cd.transition;
  cd.transition = null;
  try {
    C$5 = 1, fd(a3, b2, c2, d3);
  } finally {
    C$5 = e2, cd.transition = f3;
  }
}
function gd(a3, b2, c2, d3) {
  var e2 = C$5, f3 = cd.transition;
  cd.transition = null;
  try {
    C$5 = 4, fd(a3, b2, c2, d3);
  } finally {
    C$5 = e2, cd.transition = f3;
  }
}
function fd(a3, b2, c2, d3) {
  if (dd) {
    var e2 = Yc(a3, b2, c2, d3);
    if (null === e2) hd(a3, b2, d3, id, c2), Sc(a3, d3);
    else if (Uc(e2, a3, b2, c2, d3)) d3.stopPropagation();
    else if (Sc(a3, d3), b2 & 4 && -1 < Rc.indexOf(a3)) {
      for (; null !== e2; ) {
        var f3 = Cb(e2);
        null !== f3 && Ec(f3);
        f3 = Yc(a3, b2, c2, d3);
        null === f3 && hd(a3, b2, d3, id, c2);
        if (f3 === e2) break;
        e2 = f3;
      }
      null !== e2 && d3.stopPropagation();
    } else hd(a3, b2, d3, null, c2);
  }
}
var id = null;
function Yc(a3, b2, c2, d3) {
  id = null;
  a3 = xb(d3);
  a3 = Wc(a3);
  if (null !== a3) if (b2 = Vb(a3), null === b2) a3 = null;
  else if (c2 = b2.tag, 13 === c2) {
    a3 = Wb(b2);
    if (null !== a3) return a3;
    a3 = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a3 = null;
  } else b2 !== a3 && (a3 = null);
  id = a3;
  return null;
}
function jd(a3) {
  switch (a3) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a3, b2 = ld, c2 = b2.length, d3, e2 = "value" in kd ? kd.value : kd.textContent, f3 = e2.length;
  for (a3 = 0; a3 < c2 && b2[a3] === e2[a3]; a3++) ;
  var g2 = c2 - a3;
  for (d3 = 1; d3 <= g2 && b2[c2 - d3] === e2[f3 - d3]; d3++) ;
  return md = e2.slice(a3, 1 < d3 ? 1 - d3 : void 0);
}
function od(a3) {
  var b2 = a3.keyCode;
  "charCode" in a3 ? (a3 = a3.charCode, 0 === a3 && 13 === b2 && (a3 = 13)) : a3 = b2;
  10 === a3 && (a3 = 13);
  return 32 <= a3 || 13 === a3 ? a3 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a3) {
  function b2(b22, d3, e2, f3, g2) {
    this._reactName = b22;
    this._targetInst = e2;
    this.type = d3;
    this.nativeEvent = f3;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a3) a3.hasOwnProperty(c2) && (b22 = a3[c2], this[c2] = b22 ? b22(f3) : f3[c2]);
    this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$5(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a22 = this.nativeEvent;
    a22 && (a22.preventDefault ? a22.preventDefault() : "unknown" !== typeof a22.returnValue && (a22.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a22 = this.nativeEvent;
    a22 && (a22.stopPropagation ? a22.stopPropagation() : "unknown" !== typeof a22.cancelBubble && (a22.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a3) {
  return a3.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$5({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$5({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a3) {
  return void 0 === a3.relatedTarget ? a3.fromElement === a3.srcElement ? a3.toElement : a3.fromElement : a3.relatedTarget;
}, movementX: function(a3) {
  if ("movementX" in a3) return a3.movementX;
  a3 !== yd && (yd && "mousemove" === a3.type ? (wd = a3.screenX - yd.screenX, xd = a3.screenY - yd.screenY) : xd = wd = 0, yd = a3);
  return wd;
}, movementY: function(a3) {
  return "movementY" in a3 ? a3.movementY : xd;
} }), Bd = rd(Ad), Cd = A$5({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$5({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$5({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$5({}, sd, { clipboardData: function(a3) {
  return "clipboardData" in a3 ? a3.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$5({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a3) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a3) : (a3 = Od[a3]) ? !!b2[a3] : false;
}
function zd() {
  return Pd;
}
var Qd = A$5({}, ud, { key: function(a3) {
  if (a3.key) {
    var b2 = Md[a3.key] || a3.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a3.type ? (a3 = od(a3), 13 === a3 ? "Enter" : String.fromCharCode(a3)) : "keydown" === a3.type || "keyup" === a3.type ? Nd[a3.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a3) {
  return "keypress" === a3.type ? od(a3) : 0;
}, keyCode: function(a3) {
  return "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
}, which: function(a3) {
  return "keypress" === a3.type ? od(a3) : "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$5({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$5({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$5({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$5({}, Ad, {
  deltaX: function(a3) {
    return "deltaX" in a3 ? a3.deltaX : "wheelDeltaX" in a3 ? -a3.wheelDeltaX : 0;
  },
  deltaY: function(a3) {
    return "deltaY" in a3 ? a3.deltaY : "wheelDeltaY" in a3 ? -a3.wheelDeltaY : "wheelDelta" in a3 ? -a3.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$4 = null;
ia && "documentMode" in document && (be$4 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$4, de$3 = ia && (!ae$1 || be$4 && 8 < be$4 && 11 >= be$4), ee$3 = String.fromCharCode(32), fe$3 = false;
function ge$3(a3, b2) {
  switch (a3) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$2(a3) {
  a3 = a3.detail;
  return "object" === typeof a3 && "data" in a3 ? a3.data : null;
}
var ie$2 = false;
function je$1(a3, b2) {
  switch (a3) {
    case "compositionend":
      return he$2(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe$3 = true;
      return ee$3;
    case "textInput":
      return a3 = b2.data, a3 === ee$3 && fe$3 ? null : a3;
    default:
      return null;
  }
}
function ke$1(a3, b2) {
  if (ie$2) return "compositionend" === a3 || !ae$1 && ge$3(a3, b2) ? (a3 = nd(), md = ld = kd = null, ie$2 = false, a3) : null;
  switch (a3) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$3 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a3) {
  var b2 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return "input" === b2 ? !!le$2[a3.type] : "textarea" === b2 ? true : false;
}
function ne$2(a3, b2, c2, d3) {
  Eb(d3);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d3), a3.push({ event: c2, listeners: b2 }));
}
var pe$3 = null, qe$1 = null;
function re$3(a3) {
  se$3(a3, 0);
}
function te$3(a3) {
  var b2 = ue$4(a3);
  if (Wa(b2)) return a3;
}
function ve$2(a3, b2) {
  if ("change" === a3) return b2;
}
var we$1 = false;
if (ia) {
  var xe$3;
  if (ia) {
    var ye$3 = "oninput" in document;
    if (!ye$3) {
      var ze$2 = document.createElement("div");
      ze$2.setAttribute("oninput", "return;");
      ye$3 = "function" === typeof ze$2.oninput;
    }
    xe$3 = ye$3;
  } else xe$3 = false;
  we$1 = xe$3 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$3() {
  pe$3 && (pe$3.detachEvent("onpropertychange", Be$1), qe$1 = pe$3 = null);
}
function Be$1(a3) {
  if ("value" === a3.propertyName && te$3(qe$1)) {
    var b2 = [];
    ne$2(b2, qe$1, a3, xb(a3));
    Jb(re$3, b2);
  }
}
function Ce$1(a3, b2, c2) {
  "focusin" === a3 ? (Ae$3(), pe$3 = b2, qe$1 = c2, pe$3.attachEvent("onpropertychange", Be$1)) : "focusout" === a3 && Ae$3();
}
function De$2(a3) {
  if ("selectionchange" === a3 || "keyup" === a3 || "keydown" === a3) return te$3(qe$1);
}
function Ee$3(a3, b2) {
  if ("click" === a3) return te$3(b2);
}
function Fe$3(a3, b2) {
  if ("input" === a3 || "change" === a3) return te$3(b2);
}
function Ge$1(a3, b2) {
  return a3 === b2 && (0 !== a3 || 1 / a3 === 1 / b2) || a3 !== a3 && b2 !== b2;
}
var He$2 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$3(a3, b2) {
  if (He$2(a3, b2)) return true;
  if ("object" !== typeof a3 || null === a3 || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a3), d3 = Object.keys(b2);
  if (c2.length !== d3.length) return false;
  for (d3 = 0; d3 < c2.length; d3++) {
    var e2 = c2[d3];
    if (!ja.call(b2, e2) || !He$2(a3[e2], b2[e2])) return false;
  }
  return true;
}
function Je$1(a3) {
  for (; a3 && a3.firstChild; ) a3 = a3.firstChild;
  return a3;
}
function Ke$1(a3, b2) {
  var c2 = Je$1(a3);
  a3 = 0;
  for (var d3; c2; ) {
    if (3 === c2.nodeType) {
      d3 = a3 + c2.textContent.length;
      if (a3 <= b2 && d3 >= b2) return { node: c2, offset: b2 - a3 };
      a3 = d3;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$2(a3, b2) {
  return a3 && b2 ? a3 === b2 ? true : a3 && 3 === a3.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a3, b2.parentNode) : "contains" in a3 ? a3.contains(b2) : a3.compareDocumentPosition ? !!(a3.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$3() {
  for (var a3 = window, b2 = Xa(); b2 instanceof a3.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d3) {
      c2 = false;
    }
    if (c2) a3 = b2.contentWindow;
    else break;
    b2 = Xa(a3.document);
  }
  return b2;
}
function Ne$1(a3) {
  var b2 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a3.type || "search" === a3.type || "tel" === a3.type || "url" === a3.type || "password" === a3.type) || "textarea" === b2 || "true" === a3.contentEditable);
}
function Oe$2(a3) {
  var b2 = Me$3(), c2 = a3.focusedElem, d3 = a3.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
    if (null !== d3 && Ne$1(c2)) {
      if (b2 = d3.start, a3 = d3.end, void 0 === a3 && (a3 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a3, c2.value.length);
      else if (a3 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a3.getSelection) {
        a3 = a3.getSelection();
        var e2 = c2.textContent.length, f3 = Math.min(d3.start, e2);
        d3 = void 0 === d3.end ? f3 : Math.min(d3.end, e2);
        !a3.extend && f3 > d3 && (e2 = d3, d3 = f3, f3 = e2);
        e2 = Ke$1(c2, f3);
        var g2 = Ke$1(
          c2,
          d3
        );
        e2 && g2 && (1 !== a3.rangeCount || a3.anchorNode !== e2.node || a3.anchorOffset !== e2.offset || a3.focusNode !== g2.node || a3.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a3.removeAllRanges(), f3 > d3 ? (a3.addRange(b2), a3.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a3.addRange(b2)));
      }
    }
    b2 = [];
    for (a3 = c2; a3 = a3.parentNode; ) 1 === a3.nodeType && b2.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a3 = b2[c2], a3.element.scrollLeft = a3.left, a3.element.scrollTop = a3.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$3 = null, Se$2 = null, Te$3 = false;
function Ue$1(a3, b2, c2) {
  var d3 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$3 || null == Qe$1 || Qe$1 !== Xa(d3) || (d3 = Qe$1, "selectionStart" in d3 && Ne$1(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se$2 && Ie$3(Se$2, d3) || (Se$2 = d3, d3 = oe$2(Re$3, "onSelect"), 0 < d3.length && (b2 = new td("onSelect", "select", null, b2, c2), a3.push({ event: b2, listeners: d3 }), b2.target = Qe$1)));
}
function Ve$1(a3, b2) {
  var c2 = {};
  c2[a3.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a3] = "webkit" + b2;
  c2["Moz" + a3] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a3) {
  if (Xe$1[a3]) return Xe$1[a3];
  if (!We$1[a3]) return a3;
  var b2 = We$1[a3], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye$1) return Xe$1[a3] = b2[c2];
  return a3;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a3, b2) {
  df.set(a3, b2);
  fa(b2, [a3]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a3, b2, c2) {
  var d3 = a3.type || "unknown-event";
  a3.currentTarget = c2;
  Ub(d3, b2, void 0, a3);
  a3.currentTarget = null;
}
function se$3(a3, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a3.length; c2++) {
    var d3 = a3[c2], e2 = d3.event;
    d3 = d3.listeners;
    a: {
      var f3 = void 0;
      if (b2) for (var g2 = d3.length - 1; 0 <= g2; g2--) {
        var h3 = d3[g2], k2 = h3.instance, l3 = h3.currentTarget;
        h3 = h3.listener;
        if (k2 !== f3 && e2.isPropagationStopped()) break a;
        nf(e2, h3, l3);
        f3 = k2;
      }
      else for (g2 = 0; g2 < d3.length; g2++) {
        h3 = d3[g2];
        k2 = h3.instance;
        l3 = h3.currentTarget;
        h3 = h3.listener;
        if (k2 !== f3 && e2.isPropagationStopped()) break a;
        nf(e2, h3, l3);
        f3 = k2;
      }
    }
  }
  if (Qb) throw a3 = Rb, Qb = false, Rb = null, a3;
}
function D$4(a3, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d3 = a3 + "__bubble";
  c2.has(d3) || (pf(b2, a3, 2, false), c2.add(d3));
}
function qf(a3, b2, c2) {
  var d3 = 0;
  b2 && (d3 |= 4);
  pf(c2, a3, d3, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a3) {
  if (!a3[rf]) {
    a3[rf] = true;
    da.forEach(function(b22) {
      "selectionchange" !== b22 && (mf.has(b22) || qf(b22, false, a3), qf(b22, true, a3));
    });
    var b2 = 9 === a3.nodeType ? a3 : a3.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a3, b2, c2, d3) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a3);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d3 ? void 0 !== e2 ? a3.addEventListener(b2, c2, { capture: true, passive: e2 }) : a3.addEventListener(b2, c2, true) : void 0 !== e2 ? a3.addEventListener(b2, c2, { passive: e2 }) : a3.addEventListener(b2, c2, false);
}
function hd(a3, b2, c2, d3, e2) {
  var f3 = d3;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d3) a: for (; ; ) {
    if (null === d3) return;
    var g2 = d3.tag;
    if (3 === g2 || 4 === g2) {
      var h3 = d3.stateNode.containerInfo;
      if (h3 === e2 || 8 === h3.nodeType && h3.parentNode === e2) break;
      if (4 === g2) for (g2 = d3.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h3; ) {
        g2 = Wc(h3);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d3 = f3 = g2;
          continue a;
        }
        h3 = h3.parentNode;
      }
    }
    d3 = d3.return;
  }
  Jb(function() {
    var d22 = f3, e22 = xb(c2), g22 = [];
    a: {
      var h22 = df.get(a3);
      if (void 0 !== h22) {
        var k22 = td, n2 = a3;
        switch (a3) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k22 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k22 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k22 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k22 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k22 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k22 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k22 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k22 = Hd;
            break;
          case cf:
            k22 = Xd;
            break;
          case "scroll":
            k22 = vd;
            break;
          case "wheel":
            k22 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k22 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k22 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a3, x2 = t2 ? null !== h22 ? h22 + "Capture" : null : h22;
        t2 = [];
        for (var w2 = d22, u3; null !== w2; ) {
          u3 = w2;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u3))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h22 = new k22(h22, n2, null, c2, e22), g22.push({ event: h22, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h22 = "mouseover" === a3 || "pointerover" === a3;
        k22 = "mouseout" === a3 || "pointerout" === a3;
        if (h22 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k22 || h22) {
          h22 = e22.window === e22 ? e22 : (h22 = e22.ownerDocument) ? h22.defaultView || h22.parentWindow : window;
          if (k22) {
            if (n2 = c2.relatedTarget || c2.toElement, k22 = d22, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k22 = null, n2 = d22;
          if (k22 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a3 || "pointerover" === a3) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k22 ? h22 : ue$4(k22);
            u3 = null == n2 ? h22 : ue$4(n2);
            h22 = new t2(F2, w2 + "leave", k22, c2, e22);
            h22.target = J2;
            h22.relatedTarget = u3;
            F2 = null;
            Wc(e22) === d22 && (t2 = new t2(x2, w2 + "enter", n2, c2, e22), t2.target = u3, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k22 && n2) b: {
              t2 = k22;
              x2 = n2;
              w2 = 0;
              for (u3 = t2; u3; u3 = vf(u3)) w2++;
              u3 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u3++;
              for (; 0 < w2 - u3; ) t2 = vf(t2), w2--;
              for (; 0 < u3 - w2; ) x2 = vf(x2), u3--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k22 && wf(g22, h22, k22, t2, false);
            null !== n2 && null !== J2 && wf(g22, J2, n2, t2, true);
          }
        }
      }
      a: {
        h22 = d22 ? ue$4(d22) : window;
        k22 = h22.nodeName && h22.nodeName.toLowerCase();
        if ("select" === k22 || "input" === k22 && "file" === h22.type) var na = ve$2;
        else if (me$2(h22)) if (we$1) na = Fe$3;
        else {
          na = De$2;
          var xa = Ce$1;
        }
        else (k22 = h22.nodeName) && "input" === k22.toLowerCase() && ("checkbox" === h22.type || "radio" === h22.type) && (na = Ee$3);
        if (na && (na = na(a3, d22))) {
          ne$2(g22, na, c2, e22);
          break a;
        }
        xa && xa(a3, h22, d22);
        "focusout" === a3 && (xa = h22._wrapperState) && xa.controlled && "number" === h22.type && cb(h22, "number", h22.value);
      }
      xa = d22 ? ue$4(d22) : window;
      switch (a3) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable) Qe$1 = xa, Re$3 = d22, Se$2 = null;
          break;
        case "focusout":
          Se$2 = Re$3 = Qe$1 = null;
          break;
        case "mousedown":
          Te$3 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$3 = false;
          Ue$1(g22, c2, e22);
          break;
        case "selectionchange":
          if (Pe$1) break;
        case "keydown":
        case "keyup":
          Ue$1(g22, c2, e22);
      }
      var $a;
      if (ae$1) b: {
        switch (a3) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie$2 ? ge$3(a3, c2) && (ba = "onCompositionEnd") : "keydown" === a3 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$3 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e22, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$2(d22, ba), 0 < xa.length && (ba = new Ld(ba, a3, null, c2, e22), g22.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je$1(a3, c2) : ke$1(a3, c2)) d22 = oe$2(d22, "onBeforeInput"), 0 < d22.length && (e22 = new Ld("onBeforeInput", "beforeinput", null, c2, e22), g22.push({ event: e22, listeners: d22 }), e22.data = $a);
    }
    se$3(g22, b2);
  });
}
function tf(a3, b2, c2) {
  return { instance: a3, listener: b2, currentTarget: c2 };
}
function oe$2(a3, b2) {
  for (var c2 = b2 + "Capture", d3 = []; null !== a3; ) {
    var e2 = a3, f3 = e2.stateNode;
    5 === e2.tag && null !== f3 && (e2 = f3, f3 = Kb(a3, c2), null != f3 && d3.unshift(tf(a3, f3, e2)), f3 = Kb(a3, b2), null != f3 && d3.push(tf(a3, f3, e2)));
    a3 = a3.return;
  }
  return d3;
}
function vf(a3) {
  if (null === a3) return null;
  do
    a3 = a3.return;
  while (a3 && 5 !== a3.tag);
  return a3 ? a3 : null;
}
function wf(a3, b2, c2, d3, e2) {
  for (var f3 = b2._reactName, g2 = []; null !== c2 && c2 !== d3; ) {
    var h3 = c2, k2 = h3.alternate, l3 = h3.stateNode;
    if (null !== k2 && k2 === d3) break;
    5 === h3.tag && null !== l3 && (h3 = l3, e2 ? (k2 = Kb(c2, f3), null != k2 && g2.unshift(tf(c2, k2, h3))) : e2 || (k2 = Kb(c2, f3), null != k2 && g2.push(tf(c2, k2, h3))));
    c2 = c2.return;
  }
  0 !== g2.length && a3.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a3) {
  return ("string" === typeof a3 ? a3 : "" + a3).replace(xf, "\n").replace(yf, "");
}
function Af(a3, b2, c2) {
  b2 = zf(b2);
  if (zf(a3) !== b2 && c2) throw Error(p$6(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a3, b2) {
  return "textarea" === a3 || "noscript" === a3 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a3) {
  return Hf.resolve(null).then(a3).catch(If);
} : Ff;
function If(a3) {
  setTimeout(function() {
    throw a3;
  });
}
function Kf(a3, b2) {
  var c2 = b2, d3 = 0;
  do {
    var e2 = c2.nextSibling;
    a3.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d3) {
        a3.removeChild(e2);
        bd(b2);
        return;
      }
      d3--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d3++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a3) {
  for (; null != a3; a3 = a3.nextSibling) {
    var b2 = a3.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a3.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a3;
}
function Mf(a3) {
  a3 = a3.previousSibling;
  for (var b2 = 0; a3; ) {
    if (8 === a3.nodeType) {
      var c2 = a3.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a3;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a3 = a3.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a3) {
  var b2 = a3[Of];
  if (b2) return b2;
  for (var c2 = a3.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a3 = Mf(a3); null !== a3; ) {
        if (c2 = a3[Of]) return c2;
        a3 = Mf(a3);
      }
      return b2;
    }
    a3 = c2;
    c2 = a3.parentNode;
  }
  return null;
}
function Cb(a3) {
  a3 = a3[Of] || a3[uf];
  return !a3 || 5 !== a3.tag && 6 !== a3.tag && 13 !== a3.tag && 3 !== a3.tag ? null : a3;
}
function ue$4(a3) {
  if (5 === a3.tag || 6 === a3.tag) return a3.stateNode;
  throw Error(p$6(33));
}
function Db(a3) {
  return a3[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a3) {
  return { current: a3 };
}
function E$5(a3) {
  0 > Tf || (a3.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$3(a3, b2) {
  Tf++;
  Sf[Tf] = a3.current;
  a3.current = b2;
}
var Vf = {}, H$5 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a3, b2) {
  var c2 = a3.type.contextTypes;
  if (!c2) return Vf;
  var d3 = a3.stateNode;
  if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b2) return d3.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f3;
  for (f3 in c2) e2[f3] = b2[f3];
  d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = b2, a3.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a3) {
  a3 = a3.childContextTypes;
  return null !== a3 && void 0 !== a3;
}
function $f() {
  E$5(Wf);
  E$5(H$5);
}
function ag(a3, b2, c2) {
  if (H$5.current !== Vf) throw Error(p$6(168));
  G$3(H$5, b2);
  G$3(Wf, c2);
}
function bg(a3, b2, c2) {
  var d3 = a3.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d3.getChildContext) return c2;
  d3 = d3.getChildContext();
  for (var e2 in d3) if (!(e2 in b2)) throw Error(p$6(108, Ra(a3) || "Unknown", e2));
  return A$5({}, c2, d3);
}
function cg(a3) {
  a3 = (a3 = a3.stateNode) && a3.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$5.current;
  G$3(H$5, a3);
  G$3(Wf, Wf.current);
  return true;
}
function dg(a3, b2, c2) {
  var d3 = a3.stateNode;
  if (!d3) throw Error(p$6(169));
  c2 ? (a3 = bg(a3, b2, Xf), d3.__reactInternalMemoizedMergedChildContext = a3, E$5(Wf), E$5(H$5), G$3(H$5, a3)) : E$5(Wf);
  G$3(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a3) {
  null === eg ? eg = [a3] : eg.push(a3);
}
function ig(a3) {
  fg = true;
  hg(a3);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a3 = 0, b2 = C$5;
    try {
      var c2 = eg;
      for (C$5 = 1; a3 < c2.length; a3++) {
        var d3 = c2[a3];
        do
          d3 = d3(true);
        while (null !== d3);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a3 + 1)), ac(fc, jg), e2;
    } finally {
      C$5 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a3, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a3;
  ng = b2;
}
function ug(a3, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a3;
  var d3 = rg;
  a3 = sg;
  var e2 = 32 - oc(d3) - 1;
  d3 &= ~(1 << e2);
  c2 += 1;
  var f3 = 32 - oc(b2) + e2;
  if (30 < f3) {
    var g2 = e2 - e2 % 5;
    f3 = (d3 & (1 << g2) - 1).toString(32);
    d3 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d3;
    sg = f3 + a3;
  } else rg = 1 << f3 | c2 << e2 | d3, sg = a3;
}
function vg(a3) {
  null !== a3.return && (tg(a3, 1), ug(a3, 1, 0));
}
function wg(a3) {
  for (; a3 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a3 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$5 = false, zg = null;
function Ag(a3, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a3;
  b2 = a3.deletions;
  null === b2 ? (a3.deletions = [c2], a3.flags |= 16) : b2.push(c2);
}
function Cg(a3, b2) {
  switch (a3.tag) {
    case 5:
      var c2 = a3.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a3.stateNode = b2, xg = a3, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a3.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a3.stateNode = b2, xg = a3, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a3.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a3, a3.child = c2, xg = a3, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a3) {
  return 0 !== (a3.mode & 1) && 0 === (a3.flags & 128);
}
function Eg(a3) {
  if (I$5) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a3, b2)) {
        if (Dg(a3)) throw Error(p$6(418));
        b2 = Lf(c2.nextSibling);
        var d3 = xg;
        b2 && Cg(a3, b2) ? Ag(d3, c2) : (a3.flags = a3.flags & -4097 | 2, I$5 = false, xg = a3);
      }
    } else {
      if (Dg(a3)) throw Error(p$6(418));
      a3.flags = a3.flags & -4097 | 2;
      I$5 = false;
      xg = a3;
    }
  }
}
function Fg(a3) {
  for (a3 = a3.return; null !== a3 && 5 !== a3.tag && 3 !== a3.tag && 13 !== a3.tag; ) a3 = a3.return;
  xg = a3;
}
function Gg(a3) {
  if (a3 !== xg) return false;
  if (!I$5) return Fg(a3), I$5 = true, false;
  var b2;
  (b2 = 3 !== a3.tag) && !(b2 = 5 !== a3.tag) && (b2 = a3.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a3.type, a3.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a3)) throw Hg(), Error(p$6(418));
    for (; b2; ) Ag(a3, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a3);
  if (13 === a3.tag) {
    a3 = a3.memoizedState;
    a3 = null !== a3 ? a3.dehydrated : null;
    if (!a3) throw Error(p$6(317));
    a: {
      a3 = a3.nextSibling;
      for (b2 = 0; a3; ) {
        if (8 === a3.nodeType) {
          var c2 = a3.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a3.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a3 = a3.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a3.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a3 = yg; a3; ) a3 = Lf(a3.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$5 = false;
}
function Jg(a3) {
  null === zg ? zg = [a3] : zg.push(a3);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a3, b2, c2) {
  a3 = c2.ref;
  if (null !== a3 && "function" !== typeof a3 && "object" !== typeof a3) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$6(309));
        var d3 = c2.stateNode;
      }
      if (!d3) throw Error(p$6(147, a3));
      var e2 = d3, f3 = "" + a3;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f3) return b2.ref;
      b2 = function(a22) {
        var b22 = e2.refs;
        null === a22 ? delete b22[f3] : b22[f3] = a22;
      };
      b2._stringRef = f3;
      return b2;
    }
    if ("string" !== typeof a3) throw Error(p$6(284));
    if (!c2._owner) throw Error(p$6(290, a3));
  }
  return a3;
}
function Mg(a3, b2) {
  a3 = Object.prototype.toString.call(b2);
  throw Error(p$6(31, "[object Object]" === a3 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a3));
}
function Ng(a3) {
  var b2 = a3._init;
  return b2(a3._payload);
}
function Og(a3) {
  function b2(b22, c22) {
    if (a3) {
      var d22 = b22.deletions;
      null === d22 ? (b22.deletions = [c22], b22.flags |= 16) : d22.push(c22);
    }
  }
  function c2(c22, d22) {
    if (!a3) return null;
    for (; null !== d22; ) b2(c22, d22), d22 = d22.sibling;
    return null;
  }
  function d3(a22, b22) {
    for (a22 = /* @__PURE__ */ new Map(); null !== b22; ) null !== b22.key ? a22.set(b22.key, b22) : a22.set(b22.index, b22), b22 = b22.sibling;
    return a22;
  }
  function e2(a22, b22) {
    a22 = Pg(a22, b22);
    a22.index = 0;
    a22.sibling = null;
    return a22;
  }
  function f3(b22, c22, d22) {
    b22.index = d22;
    if (!a3) return b22.flags |= 1048576, c22;
    d22 = b22.alternate;
    if (null !== d22) return d22 = d22.index, d22 < c22 ? (b22.flags |= 2, c22) : d22;
    b22.flags |= 2;
    return c22;
  }
  function g2(b22) {
    a3 && null === b22.alternate && (b22.flags |= 2);
    return b22;
  }
  function h3(a22, b22, c22, d22) {
    if (null === b22 || 6 !== b22.tag) return b22 = Qg(c22, a22.mode, d22), b22.return = a22, b22;
    b22 = e2(b22, c22);
    b22.return = a22;
    return b22;
  }
  function k2(a22, b22, c22, d22) {
    var f22 = c22.type;
    if (f22 === ya) return m3(a22, b22, c22.props.children, d22, c22.key);
    if (null !== b22 && (b22.elementType === f22 || "object" === typeof f22 && null !== f22 && f22.$$typeof === Ha && Ng(f22) === b22.type)) return d22 = e2(b22, c22.props), d22.ref = Lg(a22, b22, c22), d22.return = a22, d22;
    d22 = Rg(c22.type, c22.key, c22.props, null, a22.mode, d22);
    d22.ref = Lg(a22, b22, c22);
    d22.return = a22;
    return d22;
  }
  function l3(a22, b22, c22, d22) {
    if (null === b22 || 4 !== b22.tag || b22.stateNode.containerInfo !== c22.containerInfo || b22.stateNode.implementation !== c22.implementation) return b22 = Sg(c22, a22.mode, d22), b22.return = a22, b22;
    b22 = e2(b22, c22.children || []);
    b22.return = a22;
    return b22;
  }
  function m3(a22, b22, c22, d22, f22) {
    if (null === b22 || 7 !== b22.tag) return b22 = Tg(c22, a22.mode, d22, f22), b22.return = a22, b22;
    b22 = e2(b22, c22);
    b22.return = a22;
    return b22;
  }
  function q2(a22, b22, c22) {
    if ("string" === typeof b22 && "" !== b22 || "number" === typeof b22) return b22 = Qg("" + b22, a22.mode, c22), b22.return = a22, b22;
    if ("object" === typeof b22 && null !== b22) {
      switch (b22.$$typeof) {
        case va:
          return c22 = Rg(b22.type, b22.key, b22.props, null, a22.mode, c22), c22.ref = Lg(a22, null, b22), c22.return = a22, c22;
        case wa:
          return b22 = Sg(b22, a22.mode, c22), b22.return = a22, b22;
        case Ha:
          var d22 = b22._init;
          return q2(a22, d22(b22._payload), c22);
      }
      if (eb(b22) || Ka(b22)) return b22 = Tg(b22, a22.mode, c22, null), b22.return = a22, b22;
      Mg(a22, b22);
    }
    return null;
  }
  function r2(a22, b22, c22, d22) {
    var e22 = null !== b22 ? b22.key : null;
    if ("string" === typeof c22 && "" !== c22 || "number" === typeof c22) return null !== e22 ? null : h3(a22, b22, "" + c22, d22);
    if ("object" === typeof c22 && null !== c22) {
      switch (c22.$$typeof) {
        case va:
          return c22.key === e22 ? k2(a22, b22, c22, d22) : null;
        case wa:
          return c22.key === e22 ? l3(a22, b22, c22, d22) : null;
        case Ha:
          return e22 = c22._init, r2(
            a22,
            b22,
            e22(c22._payload),
            d22
          );
      }
      if (eb(c22) || Ka(c22)) return null !== e22 ? null : m3(a22, b22, c22, d22, null);
      Mg(a22, c22);
    }
    return null;
  }
  function y2(a22, b22, c22, d22, e22) {
    if ("string" === typeof d22 && "" !== d22 || "number" === typeof d22) return a22 = a22.get(c22) || null, h3(b22, a22, "" + d22, e22);
    if ("object" === typeof d22 && null !== d22) {
      switch (d22.$$typeof) {
        case va:
          return a22 = a22.get(null === d22.key ? c22 : d22.key) || null, k2(b22, a22, d22, e22);
        case wa:
          return a22 = a22.get(null === d22.key ? c22 : d22.key) || null, l3(b22, a22, d22, e22);
        case Ha:
          var f22 = d22._init;
          return y2(a22, b22, c22, f22(d22._payload), e22);
      }
      if (eb(d22) || Ka(d22)) return a22 = a22.get(c22) || null, m3(b22, a22, d22, e22, null);
      Mg(b22, d22);
    }
    return null;
  }
  function n2(e22, g22, h22, k22) {
    for (var l22 = null, m22 = null, u3 = g22, w2 = g22 = 0, x2 = null; null !== u3 && w2 < h22.length; w2++) {
      u3.index > w2 ? (x2 = u3, u3 = null) : x2 = u3.sibling;
      var n22 = r2(e22, u3, h22[w2], k22);
      if (null === n22) {
        null === u3 && (u3 = x2);
        break;
      }
      a3 && u3 && null === n22.alternate && b2(e22, u3);
      g22 = f3(n22, g22, w2);
      null === m22 ? l22 = n22 : m22.sibling = n22;
      m22 = n22;
      u3 = x2;
    }
    if (w2 === h22.length) return c2(e22, u3), I$5 && tg(e22, w2), l22;
    if (null === u3) {
      for (; w2 < h22.length; w2++) u3 = q2(e22, h22[w2], k22), null !== u3 && (g22 = f3(u3, g22, w2), null === m22 ? l22 = u3 : m22.sibling = u3, m22 = u3);
      I$5 && tg(e22, w2);
      return l22;
    }
    for (u3 = d3(e22, u3); w2 < h22.length; w2++) x2 = y2(u3, e22, w2, h22[w2], k22), null !== x2 && (a3 && null !== x2.alternate && u3.delete(null === x2.key ? w2 : x2.key), g22 = f3(x2, g22, w2), null === m22 ? l22 = x2 : m22.sibling = x2, m22 = x2);
    a3 && u3.forEach(function(a22) {
      return b2(e22, a22);
    });
    I$5 && tg(e22, w2);
    return l22;
  }
  function t2(e22, g22, h22, k22) {
    var l22 = Ka(h22);
    if ("function" !== typeof l22) throw Error(p$6(150));
    h22 = l22.call(h22);
    if (null == h22) throw Error(p$6(151));
    for (var u3 = l22 = null, m22 = g22, w2 = g22 = 0, x2 = null, n22 = h22.next(); null !== m22 && !n22.done; w2++, n22 = h22.next()) {
      m22.index > w2 ? (x2 = m22, m22 = null) : x2 = m22.sibling;
      var t22 = r2(e22, m22, n22.value, k22);
      if (null === t22) {
        null === m22 && (m22 = x2);
        break;
      }
      a3 && m22 && null === t22.alternate && b2(e22, m22);
      g22 = f3(t22, g22, w2);
      null === u3 ? l22 = t22 : u3.sibling = t22;
      u3 = t22;
      m22 = x2;
    }
    if (n22.done) return c2(
      e22,
      m22
    ), I$5 && tg(e22, w2), l22;
    if (null === m22) {
      for (; !n22.done; w2++, n22 = h22.next()) n22 = q2(e22, n22.value, k22), null !== n22 && (g22 = f3(n22, g22, w2), null === u3 ? l22 = n22 : u3.sibling = n22, u3 = n22);
      I$5 && tg(e22, w2);
      return l22;
    }
    for (m22 = d3(e22, m22); !n22.done; w2++, n22 = h22.next()) n22 = y2(m22, e22, w2, n22.value, k22), null !== n22 && (a3 && null !== n22.alternate && m22.delete(null === n22.key ? w2 : n22.key), g22 = f3(n22, g22, w2), null === u3 ? l22 = n22 : u3.sibling = n22, u3 = n22);
    a3 && m22.forEach(function(a22) {
      return b2(e22, a22);
    });
    I$5 && tg(e22, w2);
    return l22;
  }
  function J2(a22, d22, f22, h22) {
    "object" === typeof f22 && null !== f22 && f22.type === ya && null === f22.key && (f22 = f22.props.children);
    if ("object" === typeof f22 && null !== f22) {
      switch (f22.$$typeof) {
        case va:
          a: {
            for (var k22 = f22.key, l22 = d22; null !== l22; ) {
              if (l22.key === k22) {
                k22 = f22.type;
                if (k22 === ya) {
                  if (7 === l22.tag) {
                    c2(a22, l22.sibling);
                    d22 = e2(l22, f22.props.children);
                    d22.return = a22;
                    a22 = d22;
                    break a;
                  }
                } else if (l22.elementType === k22 || "object" === typeof k22 && null !== k22 && k22.$$typeof === Ha && Ng(k22) === l22.type) {
                  c2(a22, l22.sibling);
                  d22 = e2(l22, f22.props);
                  d22.ref = Lg(a22, l22, f22);
                  d22.return = a22;
                  a22 = d22;
                  break a;
                }
                c2(a22, l22);
                break;
              } else b2(a22, l22);
              l22 = l22.sibling;
            }
            f22.type === ya ? (d22 = Tg(f22.props.children, a22.mode, h22, f22.key), d22.return = a22, a22 = d22) : (h22 = Rg(f22.type, f22.key, f22.props, null, a22.mode, h22), h22.ref = Lg(a22, d22, f22), h22.return = a22, a22 = h22);
          }
          return g2(a22);
        case wa:
          a: {
            for (l22 = f22.key; null !== d22; ) {
              if (d22.key === l22) if (4 === d22.tag && d22.stateNode.containerInfo === f22.containerInfo && d22.stateNode.implementation === f22.implementation) {
                c2(a22, d22.sibling);
                d22 = e2(d22, f22.children || []);
                d22.return = a22;
                a22 = d22;
                break a;
              } else {
                c2(a22, d22);
                break;
              }
              else b2(a22, d22);
              d22 = d22.sibling;
            }
            d22 = Sg(f22, a22.mode, h22);
            d22.return = a22;
            a22 = d22;
          }
          return g2(a22);
        case Ha:
          return l22 = f22._init, J2(a22, d22, l22(f22._payload), h22);
      }
      if (eb(f22)) return n2(a22, d22, f22, h22);
      if (Ka(f22)) return t2(a22, d22, f22, h22);
      Mg(a22, f22);
    }
    return "string" === typeof f22 && "" !== f22 || "number" === typeof f22 ? (f22 = "" + f22, null !== d22 && 6 === d22.tag ? (c2(a22, d22.sibling), d22 = e2(d22, f22), d22.return = a22, a22 = d22) : (c2(a22, d22), d22 = Qg(f22, a22.mode, h22), d22.return = a22, a22 = d22), g2(a22)) : c2(a22, d22);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a3) {
  var b2 = Wg.current;
  E$5(Wg);
  a3._currentValue = b2;
}
function bh(a3, b2, c2) {
  for (; null !== a3; ) {
    var d3 = a3.alternate;
    (a3.childLanes & b2) !== b2 ? (a3.childLanes |= b2, null !== d3 && (d3.childLanes |= b2)) : null !== d3 && (d3.childLanes & b2) !== b2 && (d3.childLanes |= b2);
    if (a3 === c2) break;
    a3 = a3.return;
  }
}
function ch(a3, b2) {
  Xg = a3;
  Zg = Yg = null;
  a3 = a3.dependencies;
  null !== a3 && null !== a3.firstContext && (0 !== (a3.lanes & b2) && (dh = true), a3.firstContext = null);
}
function eh(a3) {
  var b2 = a3._currentValue;
  if (Zg !== a3) if (a3 = { context: a3, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$6(308));
    Yg = a3;
    Xg.dependencies = { lanes: 0, firstContext: a3 };
  } else Yg = Yg.next = a3;
  return b2;
}
var fh = null;
function gh(a3) {
  null === fh ? fh = [a3] : fh.push(a3);
}
function hh(a3, b2, c2, d3) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a3, d3);
}
function ih(a3, b2) {
  a3.lanes |= b2;
  var c2 = a3.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a3;
  for (a3 = a3.return; null !== a3; ) a3.childLanes |= b2, c2 = a3.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a3, a3 = a3.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a3) {
  a3.updateQueue = { baseState: a3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a3, b2) {
  a3 = a3.updateQueue;
  b2.updateQueue === a3 && (b2.updateQueue = { baseState: a3.baseState, firstBaseUpdate: a3.firstBaseUpdate, lastBaseUpdate: a3.lastBaseUpdate, shared: a3.shared, effects: a3.effects });
}
function mh(a3, b2) {
  return { eventTime: a3, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a3, b2, c2) {
  var d3 = a3.updateQueue;
  if (null === d3) return null;
  d3 = d3.shared;
  if (0 !== (K$3 & 2)) {
    var e2 = d3.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d3.pending = b2;
    return ih(a3, c2);
  }
  e2 = d3.interleaved;
  null === e2 ? (b2.next = b2, gh(d3)) : (b2.next = e2.next, e2.next = b2);
  d3.interleaved = b2;
  return ih(a3, c2);
}
function oh(a3, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d3 = b2.lanes;
    d3 &= a3.pendingLanes;
    c2 |= d3;
    b2.lanes = c2;
    Cc(a3, c2);
  }
}
function ph(a3, b2) {
  var c2 = a3.updateQueue, d3 = a3.alternate;
  if (null !== d3 && (d3 = d3.updateQueue, c2 === d3)) {
    var e2 = null, f3 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f3 ? e2 = f3 = g2 : f3 = f3.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f3 ? e2 = f3 = b2 : f3 = f3.next = b2;
    } else e2 = f3 = b2;
    c2 = { baseState: d3.baseState, firstBaseUpdate: e2, lastBaseUpdate: f3, shared: d3.shared, effects: d3.effects };
    a3.updateQueue = c2;
    return;
  }
  a3 = c2.lastBaseUpdate;
  null === a3 ? c2.firstBaseUpdate = b2 : a3.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a3, b2, c2, d3) {
  var e2 = a3.updateQueue;
  jh = false;
  var f3 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h3 = e2.shared.pending;
  if (null !== h3) {
    e2.shared.pending = null;
    var k2 = h3, l3 = k2.next;
    k2.next = null;
    null === g2 ? f3 = l3 : g2.next = l3;
    g2 = k2;
    var m3 = a3.alternate;
    null !== m3 && (m3 = m3.updateQueue, h3 = m3.lastBaseUpdate, h3 !== g2 && (null === h3 ? m3.firstBaseUpdate = l3 : h3.next = l3, m3.lastBaseUpdate = k2));
  }
  if (null !== f3) {
    var q2 = e2.baseState;
    g2 = 0;
    m3 = l3 = k2 = null;
    h3 = f3;
    do {
      var r2 = h3.lane, y2 = h3.eventTime;
      if ((d3 & r2) === r2) {
        null !== m3 && (m3 = m3.next = {
          eventTime: y2,
          lane: 0,
          tag: h3.tag,
          payload: h3.payload,
          callback: h3.callback,
          next: null
        });
        a: {
          var n2 = a3, t2 = h3;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$5({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h3.callback && 0 !== h3.lane && (a3.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h3] : r2.push(h3));
      } else y2 = { eventTime: y2, lane: r2, tag: h3.tag, payload: h3.payload, callback: h3.callback, next: null }, null === m3 ? (l3 = m3 = y2, k2 = q2) : m3 = m3.next = y2, g2 |= r2;
      h3 = h3.next;
      if (null === h3) if (h3 = e2.shared.pending, null === h3) break;
      else r2 = h3, h3 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m3 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l3;
    e2.lastBaseUpdate = m3;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f3 && (e2.shared.lanes = 0);
    rh |= g2;
    a3.lanes = g2;
    a3.memoizedState = q2;
  }
}
function sh(a3, b2, c2) {
  a3 = b2.effects;
  b2.effects = null;
  if (null !== a3) for (b2 = 0; b2 < a3.length; b2++) {
    var d3 = a3[b2], e2 = d3.callback;
    if (null !== e2) {
      d3.callback = null;
      d3 = c2;
      if ("function" !== typeof e2) throw Error(p$6(191, e2));
      e2.call(d3);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a3) {
  if (a3 === th) throw Error(p$6(174));
  return a3;
}
function yh(a3, b2) {
  G$3(wh, b2);
  G$3(vh, a3);
  G$3(uh, th);
  a3 = b2.nodeType;
  switch (a3) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a3 = 8 === a3 ? b2.parentNode : b2, b2 = a3.namespaceURI || null, a3 = a3.tagName, b2 = lb(b2, a3);
  }
  E$5(uh);
  G$3(uh, b2);
}
function zh() {
  E$5(uh);
  E$5(vh);
  E$5(wh);
}
function Ah(a3) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a3.type);
  b2 !== c2 && (G$3(vh, a3), G$3(uh, c2));
}
function Bh(a3) {
  vh.current === a3 && (E$5(uh), E$5(vh));
}
var L$4 = Uf(0);
function Ch(a3) {
  for (var b2 = a3; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a3) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a3) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a3 = 0; a3 < Dh.length; a3++) Dh[a3]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$6 = null, N$3 = null, O$6 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$6() {
  throw Error(p$6(321));
}
function Mh(a3, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a3.length; c2++) if (!He$2(a3[c2], b2[c2])) return false;
  return true;
}
function Nh(a3, b2, c2, d3, e2, f3) {
  Hh = f3;
  M$6 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a3 || null === a3.memoizedState ? Oh : Ph;
  a3 = c2(d3, e2);
  if (Jh) {
    f3 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f3) throw Error(p$6(301));
      f3 += 1;
      O$6 = N$3 = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a3 = c2(d3, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N$3 && null !== N$3.next;
  Hh = 0;
  O$6 = N$3 = M$6 = null;
  Ih = false;
  if (b2) throw Error(p$6(300));
  return a3;
}
function Sh() {
  var a3 = 0 !== Kh;
  Kh = 0;
  return a3;
}
function Th() {
  var a3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O$6 ? M$6.memoizedState = O$6 = a3 : O$6 = O$6.next = a3;
  return O$6;
}
function Uh() {
  if (null === N$3) {
    var a3 = M$6.alternate;
    a3 = null !== a3 ? a3.memoizedState : null;
  } else a3 = N$3.next;
  var b2 = null === O$6 ? M$6.memoizedState : O$6.next;
  if (null !== b2) O$6 = b2, N$3 = a3;
  else {
    if (null === a3) throw Error(p$6(310));
    N$3 = a3;
    a3 = { memoizedState: N$3.memoizedState, baseState: N$3.baseState, baseQueue: N$3.baseQueue, queue: N$3.queue, next: null };
    null === O$6 ? M$6.memoizedState = O$6 = a3 : O$6 = O$6.next = a3;
  }
  return O$6;
}
function Vh(a3, b2) {
  return "function" === typeof b2 ? b2(a3) : b2;
}
function Wh(a3) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$6(311));
  c2.lastRenderedReducer = a3;
  var d3 = N$3, e2 = d3.baseQueue, f3 = c2.pending;
  if (null !== f3) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f3.next;
      f3.next = g2;
    }
    d3.baseQueue = e2 = f3;
    c2.pending = null;
  }
  if (null !== e2) {
    f3 = e2.next;
    d3 = d3.baseState;
    var h3 = g2 = null, k2 = null, l3 = f3;
    do {
      var m3 = l3.lane;
      if ((Hh & m3) === m3) null !== k2 && (k2 = k2.next = { lane: 0, action: l3.action, hasEagerState: l3.hasEagerState, eagerState: l3.eagerState, next: null }), d3 = l3.hasEagerState ? l3.eagerState : a3(d3, l3.action);
      else {
        var q2 = {
          lane: m3,
          action: l3.action,
          hasEagerState: l3.hasEagerState,
          eagerState: l3.eagerState,
          next: null
        };
        null === k2 ? (h3 = k2 = q2, g2 = d3) : k2 = k2.next = q2;
        M$6.lanes |= m3;
        rh |= m3;
      }
      l3 = l3.next;
    } while (null !== l3 && l3 !== f3);
    null === k2 ? g2 = d3 : k2.next = h3;
    He$2(d3, b2.memoizedState) || (dh = true);
    b2.memoizedState = d3;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d3;
  }
  a3 = c2.interleaved;
  if (null !== a3) {
    e2 = a3;
    do
      f3 = e2.lane, M$6.lanes |= f3, rh |= f3, e2 = e2.next;
    while (e2 !== a3);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a3) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$6(311));
  c2.lastRenderedReducer = a3;
  var d3 = c2.dispatch, e2 = c2.pending, f3 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f3 = a3(f3, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$2(f3, b2.memoizedState) || (dh = true);
    b2.memoizedState = f3;
    null === b2.baseQueue && (b2.baseState = f3);
    c2.lastRenderedState = f3;
  }
  return [f3, d3];
}
function Yh() {
}
function Zh(a3, b2) {
  var c2 = M$6, d3 = Uh(), e2 = b2(), f3 = !He$2(d3.memoizedState, e2);
  f3 && (d3.memoizedState = e2, dh = true);
  d3 = d3.queue;
  $h(ai$1.bind(null, c2, d3, a3), [a3]);
  if (d3.getSnapshot !== b2 || f3 || null !== O$6 && O$6.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi$1(9, ci$1.bind(null, c2, d3, e2, b2), void 0, null);
    if (null === Q$3) throw Error(p$6(349));
    0 !== (Hh & 30) || di$1(c2, b2, e2);
  }
  return e2;
}
function di$1(a3, b2, c2) {
  a3.flags |= 16384;
  a3 = { getSnapshot: b2, value: c2 };
  b2 = M$6.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$6.updateQueue = b2, b2.stores = [a3]) : (c2 = b2.stores, null === c2 ? b2.stores = [a3] : c2.push(a3));
}
function ci$1(a3, b2, c2, d3) {
  b2.value = c2;
  b2.getSnapshot = d3;
  ei$1(b2) && fi$1(a3);
}
function ai$1(a3, b2, c2) {
  return c2(function() {
    ei$1(b2) && fi$1(a3);
  });
}
function ei$1(a3) {
  var b2 = a3.getSnapshot;
  a3 = a3.value;
  try {
    var c2 = b2();
    return !He$2(a3, c2);
  } catch (d3) {
    return true;
  }
}
function fi$1(a3) {
  var b2 = ih(a3, 1);
  null !== b2 && gi$1(b2, a3, 1, -1);
}
function hi$1(a3) {
  var b2 = Th();
  "function" === typeof a3 && (a3 = a3());
  b2.memoizedState = b2.baseState = a3;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a3 };
  b2.queue = a3;
  a3 = a3.dispatch = ii$1.bind(null, M$6, a3);
  return [b2.memoizedState, a3];
}
function bi$1(a3, b2, c2, d3) {
  a3 = { tag: a3, create: b2, destroy: c2, deps: d3, next: null };
  b2 = M$6.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$6.updateQueue = b2, b2.lastEffect = a3.next = a3) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a3.next = a3 : (d3 = c2.next, c2.next = a3, a3.next = d3, b2.lastEffect = a3));
  return a3;
}
function ji$1() {
  return Uh().memoizedState;
}
function ki$1(a3, b2, c2, d3) {
  var e2 = Th();
  M$6.flags |= a3;
  e2.memoizedState = bi$1(1 | b2, c2, void 0, void 0 === d3 ? null : d3);
}
function li$1(a3, b2, c2, d3) {
  var e2 = Uh();
  d3 = void 0 === d3 ? null : d3;
  var f3 = void 0;
  if (null !== N$3) {
    var g2 = N$3.memoizedState;
    f3 = g2.destroy;
    if (null !== d3 && Mh(d3, g2.deps)) {
      e2.memoizedState = bi$1(b2, c2, f3, d3);
      return;
    }
  }
  M$6.flags |= a3;
  e2.memoizedState = bi$1(1 | b2, c2, f3, d3);
}
function mi$1(a3, b2) {
  return ki$1(8390656, 8, a3, b2);
}
function $h(a3, b2) {
  return li$1(2048, 8, a3, b2);
}
function ni$1(a3, b2) {
  return li$1(4, 2, a3, b2);
}
function oi$1(a3, b2) {
  return li$1(4, 4, a3, b2);
}
function pi$1(a3, b2) {
  if ("function" === typeof b2) return a3 = a3(), b2(a3), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a3 = a3(), b2.current = a3, function() {
    b2.current = null;
  };
}
function qi$1(a3, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a3]) : null;
  return li$1(4, 4, pi$1.bind(null, b2, a3), c2);
}
function ri$1() {
}
function si$1(a3, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b2 && Mh(b2, d3[1])) return d3[0];
  c2.memoizedState = [a3, b2];
  return a3;
}
function ti$1(a3, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d3 = c2.memoizedState;
  if (null !== d3 && null !== b2 && Mh(b2, d3[1])) return d3[0];
  a3 = a3();
  c2.memoizedState = [a3, b2];
  return a3;
}
function ui$1(a3, b2, c2) {
  if (0 === (Hh & 21)) return a3.baseState && (a3.baseState = false, dh = true), a3.memoizedState = c2;
  He$2(c2, b2) || (c2 = yc(), M$6.lanes |= c2, rh |= c2, a3.baseState = true);
  return b2;
}
function vi$1(a3, b2) {
  var c2 = C$5;
  C$5 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a3(true);
  var d3 = Gh.transition;
  Gh.transition = {};
  try {
    a3(false), b2();
  } finally {
    C$5 = c2, Gh.transition = d3;
  }
}
function wi$1() {
  return Uh().memoizedState;
}
function xi$1(a3, b2, c2) {
  var d3 = yi$1(a3);
  c2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi$1(a3)) Ai$1(b2, c2);
  else if (c2 = hh(a3, b2, c2, d3), null !== c2) {
    var e2 = R$5();
    gi$1(c2, a3, d3, e2);
    Bi$1(c2, b2, d3);
  }
}
function ii$1(a3, b2, c2) {
  var d3 = yi$1(a3), e2 = { lane: d3, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi$1(a3)) Ai$1(b2, e2);
  else {
    var f3 = a3.alternate;
    if (0 === a3.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b2.lastRenderedReducer, null !== f3)) try {
      var g2 = b2.lastRenderedState, h3 = f3(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h3;
      if (He$2(h3, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l3) {
    } finally {
    }
    c2 = hh(a3, b2, e2, d3);
    null !== c2 && (e2 = R$5(), gi$1(c2, a3, d3, e2), Bi$1(c2, b2, d3));
  }
}
function zi$1(a3) {
  var b2 = a3.alternate;
  return a3 === M$6 || null !== b2 && b2 === M$6;
}
function Ai$1(a3, b2) {
  Jh = Ih = true;
  var c2 = a3.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a3.pending = b2;
}
function Bi$1(a3, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d3 = b2.lanes;
    d3 &= a3.pendingLanes;
    c2 |= d3;
    b2.lanes = c2;
    Cc(a3, c2);
  }
}
var Rh = { readContext: eh, useCallback: P$6, useContext: P$6, useEffect: P$6, useImperativeHandle: P$6, useInsertionEffect: P$6, useLayoutEffect: P$6, useMemo: P$6, useReducer: P$6, useRef: P$6, useState: P$6, useDebugValue: P$6, useDeferredValue: P$6, useTransition: P$6, useMutableSource: P$6, useSyncExternalStore: P$6, useId: P$6, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a3, b2) {
  Th().memoizedState = [a3, void 0 === b2 ? null : b2];
  return a3;
}, useContext: eh, useEffect: mi$1, useImperativeHandle: function(a3, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a3]) : null;
  return ki$1(
    4194308,
    4,
    pi$1.bind(null, b2, a3),
    c2
  );
}, useLayoutEffect: function(a3, b2) {
  return ki$1(4194308, 4, a3, b2);
}, useInsertionEffect: function(a3, b2) {
  return ki$1(4, 2, a3, b2);
}, useMemo: function(a3, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a3 = a3();
  c2.memoizedState = [a3, b2];
  return a3;
}, useReducer: function(a3, b2, c2) {
  var d3 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d3.memoizedState = d3.baseState = b2;
  a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a3, lastRenderedState: b2 };
  d3.queue = a3;
  a3 = a3.dispatch = xi$1.bind(null, M$6, a3);
  return [d3.memoizedState, a3];
}, useRef: function(a3) {
  var b2 = Th();
  a3 = { current: a3 };
  return b2.memoizedState = a3;
}, useState: hi$1, useDebugValue: ri$1, useDeferredValue: function(a3) {
  return Th().memoizedState = a3;
}, useTransition: function() {
  var a3 = hi$1(false), b2 = a3[0];
  a3 = vi$1.bind(null, a3[1]);
  Th().memoizedState = a3;
  return [b2, a3];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a3, b2, c2) {
  var d3 = M$6, e2 = Th();
  if (I$5) {
    if (void 0 === c2) throw Error(p$6(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q$3) throw Error(p$6(349));
    0 !== (Hh & 30) || di$1(d3, b2, c2);
  }
  e2.memoizedState = c2;
  var f3 = { value: c2, getSnapshot: b2 };
  e2.queue = f3;
  mi$1(ai$1.bind(
    null,
    d3,
    f3,
    a3
  ), [a3]);
  d3.flags |= 2048;
  bi$1(9, ci$1.bind(null, d3, f3, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a3 = Th(), b2 = Q$3.identifierPrefix;
  if (I$5) {
    var c2 = sg;
    var d3 = rg;
    c2 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a3.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si$1,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi$1,
  useInsertionEffect: ni$1,
  useLayoutEffect: oi$1,
  useMemo: ti$1,
  useReducer: Wh,
  useRef: ji$1,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri$1,
  useDeferredValue: function(a3) {
    var b2 = Uh();
    return ui$1(b2, N$3.memoizedState, a3);
  },
  useTransition: function() {
    var a3 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a3, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi$1,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si$1, useContext: eh, useEffect: $h, useImperativeHandle: qi$1, useInsertionEffect: ni$1, useLayoutEffect: oi$1, useMemo: ti$1, useReducer: Xh, useRef: ji$1, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri$1, useDeferredValue: function(a3) {
  var b2 = Uh();
  return null === N$3 ? b2.memoizedState = a3 : ui$1(b2, N$3.memoizedState, a3);
}, useTransition: function() {
  var a3 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a3, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi$1, unstable_isNewReconciler: false };
function Ci$1(a3, b2) {
  if (a3 && a3.defaultProps) {
    b2 = A$5({}, b2);
    a3 = a3.defaultProps;
    for (var c2 in a3) void 0 === b2[c2] && (b2[c2] = a3[c2]);
    return b2;
  }
  return b2;
}
function Di$1(a3, b2, c2, d3) {
  b2 = a3.memoizedState;
  c2 = c2(d3, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$5({}, b2, c2);
  a3.memoizedState = c2;
  0 === a3.lanes && (a3.updateQueue.baseState = c2);
}
var Ei$1 = { isMounted: function(a3) {
  return (a3 = a3._reactInternals) ? Vb(a3) === a3 : false;
}, enqueueSetState: function(a3, b2, c2) {
  a3 = a3._reactInternals;
  var d3 = R$5(), e2 = yi$1(a3), f3 = mh(d3, e2);
  f3.payload = b2;
  void 0 !== c2 && null !== c2 && (f3.callback = c2);
  b2 = nh(a3, f3, e2);
  null !== b2 && (gi$1(b2, a3, e2, d3), oh(b2, a3, e2));
}, enqueueReplaceState: function(a3, b2, c2) {
  a3 = a3._reactInternals;
  var d3 = R$5(), e2 = yi$1(a3), f3 = mh(d3, e2);
  f3.tag = 1;
  f3.payload = b2;
  void 0 !== c2 && null !== c2 && (f3.callback = c2);
  b2 = nh(a3, f3, e2);
  null !== b2 && (gi$1(b2, a3, e2, d3), oh(b2, a3, e2));
}, enqueueForceUpdate: function(a3, b2) {
  a3 = a3._reactInternals;
  var c2 = R$5(), d3 = yi$1(a3), e2 = mh(c2, d3);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a3, e2, d3);
  null !== b2 && (gi$1(b2, a3, d3, c2), oh(b2, a3, d3));
} };
function Fi$1(a3, b2, c2, d3, e2, f3, g2) {
  a3 = a3.stateNode;
  return "function" === typeof a3.shouldComponentUpdate ? a3.shouldComponentUpdate(d3, f3, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$3(c2, d3) || !Ie$3(e2, f3) : true;
}
function Gi$1(a3, b2, c2) {
  var d3 = false, e2 = Vf;
  var f3 = b2.contextType;
  "object" === typeof f3 && null !== f3 ? f3 = eh(f3) : (e2 = Zf(b2) ? Xf : H$5.current, d3 = b2.contextTypes, f3 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a3, e2) : Vf);
  b2 = new b2(c2, f3);
  a3.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei$1;
  a3.stateNode = b2;
  b2._reactInternals = a3;
  d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = e2, a3.__reactInternalMemoizedMaskedChildContext = f3);
  return b2;
}
function Hi$1(a3, b2, c2, d3) {
  a3 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d3);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d3);
  b2.state !== a3 && Ei$1.enqueueReplaceState(b2, b2.state, null);
}
function Ii$1(a3, b2, c2, d3) {
  var e2 = a3.stateNode;
  e2.props = c2;
  e2.state = a3.memoizedState;
  e2.refs = {};
  kh(a3);
  var f3 = b2.contextType;
  "object" === typeof f3 && null !== f3 ? e2.context = eh(f3) : (f3 = Zf(b2) ? Xf : H$5.current, e2.context = Yf(a3, f3));
  e2.state = a3.memoizedState;
  f3 = b2.getDerivedStateFromProps;
  "function" === typeof f3 && (Di$1(a3, b2, f3, c2), e2.state = a3.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei$1.enqueueReplaceState(e2, e2.state, null), qh(a3, c2, e2, d3), e2.state = a3.memoizedState);
  "function" === typeof e2.componentDidMount && (a3.flags |= 4194308);
}
function Ji$1(a3, b2) {
  try {
    var c2 = "", d3 = b2;
    do
      c2 += Pa(d3), d3 = d3.return;
    while (d3);
    var e2 = c2;
  } catch (f3) {
    e2 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
  }
  return { value: a3, source: b2, stack: e2, digest: null };
}
function Ki$1(a3, b2, c2) {
  return { value: a3, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li$1(a3, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Ni$1(a3, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d3 = b2.value;
  c2.callback = function() {
    Oi$1 || (Oi$1 = true, Pi$1 = d3);
    Li$1(a3, b2);
  };
  return c2;
}
function Qi$1(a3, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d3 = a3.type.getDerivedStateFromError;
  if ("function" === typeof d3) {
    var e2 = b2.value;
    c2.payload = function() {
      return d3(e2);
    };
    c2.callback = function() {
      Li$1(a3, b2);
    };
  }
  var f3 = a3.stateNode;
  null !== f3 && "function" === typeof f3.componentDidCatch && (c2.callback = function() {
    Li$1(a3, b2);
    "function" !== typeof d3 && (null === Ri$1 ? Ri$1 = /* @__PURE__ */ new Set([this]) : Ri$1.add(this));
    var c22 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c22 ? c22 : "" });
  });
  return c2;
}
function Si$1(a3, b2, c2) {
  var d3 = a3.pingCache;
  if (null === d3) {
    d3 = a3.pingCache = new Mi$1();
    var e2 = /* @__PURE__ */ new Set();
    d3.set(b2, e2);
  } else e2 = d3.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d3.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a3 = Ti$1.bind(null, a3, b2, c2), b2.then(a3, a3));
}
function Ui$1(a3) {
  do {
    var b2;
    if (b2 = 13 === a3.tag) b2 = a3.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a3;
    a3 = a3.return;
  } while (null !== a3);
  return null;
}
function Vi$1(a3, b2, c2, d3, e2) {
  if (0 === (a3.mode & 1)) return a3 === b2 ? a3.flags |= 65536 : (a3.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a3;
  a3.flags |= 65536;
  a3.lanes = e2;
  return a3;
}
var Wi$1 = ua.ReactCurrentOwner, dh = false;
function Xi$1(a3, b2, c2, d3) {
  b2.child = null === a3 ? Vg(b2, null, c2, d3) : Ug(b2, a3.child, c2, d3);
}
function Yi$1(a3, b2, c2, d3, e2) {
  c2 = c2.render;
  var f3 = b2.ref;
  ch(b2, e2);
  d3 = Nh(a3, b2, c2, d3, f3, e2);
  c2 = Sh();
  if (null !== a3 && !dh) return b2.updateQueue = a3.updateQueue, b2.flags &= -2053, a3.lanes &= ~e2, Zi$1(a3, b2, e2);
  I$5 && c2 && vg(b2);
  b2.flags |= 1;
  Xi$1(a3, b2, d3, e2);
  return b2.child;
}
function $i$1(a3, b2, c2, d3, e2) {
  if (null === a3) {
    var f3 = c2.type;
    if ("function" === typeof f3 && !aj(f3) && void 0 === f3.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f3, bj(a3, b2, f3, d3, e2);
    a3 = Rg(c2.type, null, d3, b2, b2.mode, e2);
    a3.ref = b2.ref;
    a3.return = b2;
    return b2.child = a3;
  }
  f3 = a3.child;
  if (0 === (a3.lanes & e2)) {
    var g2 = f3.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$3;
    if (c2(g2, d3) && a3.ref === b2.ref) return Zi$1(a3, b2, e2);
  }
  b2.flags |= 1;
  a3 = Pg(f3, d3);
  a3.ref = b2.ref;
  a3.return = b2;
  return b2.child = a3;
}
function bj(a3, b2, c2, d3, e2) {
  if (null !== a3) {
    var f3 = a3.memoizedProps;
    if (Ie$3(f3, d3) && a3.ref === b2.ref) if (dh = false, b2.pendingProps = d3 = f3, 0 !== (a3.lanes & e2)) 0 !== (a3.flags & 131072) && (dh = true);
    else return b2.lanes = a3.lanes, Zi$1(a3, b2, e2);
  }
  return cj(a3, b2, c2, d3, e2);
}
function dj(a3, b2, c2) {
  var d3 = b2.pendingProps, e2 = d3.children, f3 = null !== a3 ? a3.memoizedState : null;
  if ("hidden" === d3.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$3(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a3 = null !== f3 ? f3.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a3, cachePool: null, transitions: null }, b2.updateQueue = null, G$3(ej, fj), fj |= a3, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d3 = null !== f3 ? f3.baseLanes : c2;
    G$3(ej, fj);
    fj |= d3;
  }
  else null !== f3 ? (d3 = f3.baseLanes | c2, b2.memoizedState = null) : d3 = c2, G$3(ej, fj), fj |= d3;
  Xi$1(a3, b2, e2, c2);
  return b2.child;
}
function gj(a3, b2) {
  var c2 = b2.ref;
  if (null === a3 && null !== c2 || null !== a3 && a3.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a3, b2, c2, d3, e2) {
  var f3 = Zf(c2) ? Xf : H$5.current;
  f3 = Yf(b2, f3);
  ch(b2, e2);
  c2 = Nh(a3, b2, c2, d3, f3, e2);
  d3 = Sh();
  if (null !== a3 && !dh) return b2.updateQueue = a3.updateQueue, b2.flags &= -2053, a3.lanes &= ~e2, Zi$1(a3, b2, e2);
  I$5 && d3 && vg(b2);
  b2.flags |= 1;
  Xi$1(a3, b2, c2, e2);
  return b2.child;
}
function hj(a3, b2, c2, d3, e2) {
  if (Zf(c2)) {
    var f3 = true;
    cg(b2);
  } else f3 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a3, b2), Gi$1(b2, c2, d3), Ii$1(b2, c2, d3, e2), d3 = true;
  else if (null === a3) {
    var g2 = b2.stateNode, h3 = b2.memoizedProps;
    g2.props = h3;
    var k2 = g2.context, l3 = c2.contextType;
    "object" === typeof l3 && null !== l3 ? l3 = eh(l3) : (l3 = Zf(c2) ? Xf : H$5.current, l3 = Yf(b2, l3));
    var m3 = c2.getDerivedStateFromProps, q2 = "function" === typeof m3 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h3 !== d3 || k2 !== l3) && Hi$1(b2, g2, d3, l3);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d3, g2, e2);
    k2 = b2.memoizedState;
    h3 !== d3 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m3 && (Di$1(b2, c2, m3, d3), k2 = b2.memoizedState), (h3 = jh || Fi$1(b2, c2, h3, d3, r2, k2, l3)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d3, b2.memoizedState = k2), g2.props = d3, g2.state = k2, g2.context = l3, d3 = h3) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d3 = false);
  } else {
    g2 = b2.stateNode;
    lh(a3, b2);
    h3 = b2.memoizedProps;
    l3 = b2.type === b2.elementType ? h3 : Ci$1(b2.type, h3);
    g2.props = l3;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H$5.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m3 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h3 !== q2 || r2 !== k2) && Hi$1(b2, g2, d3, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d3, g2, e2);
    var n2 = b2.memoizedState;
    h3 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di$1(b2, c2, y2, d3), n2 = b2.memoizedState), (l3 = jh || Fi$1(b2, c2, l3, d3, r2, n2, k2) || false) ? (m3 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d3, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d3, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h3 === a3.memoizedProps && r2 === a3.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h3 === a3.memoizedProps && r2 === a3.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d3, b2.memoizedState = n2), g2.props = d3, g2.state = n2, g2.context = k2, d3 = l3) : ("function" !== typeof g2.componentDidUpdate || h3 === a3.memoizedProps && r2 === a3.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h3 === a3.memoizedProps && r2 === a3.memoizedState || (b2.flags |= 1024), d3 = false);
  }
  return jj(a3, b2, c2, d3, f3, e2);
}
function jj(a3, b2, c2, d3, e2, f3) {
  gj(a3, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d3 && !g2) return e2 && dg(b2, c2, false), Zi$1(a3, b2, f3);
  d3 = b2.stateNode;
  Wi$1.current = b2;
  var h3 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d3.render();
  b2.flags |= 1;
  null !== a3 && g2 ? (b2.child = Ug(b2, a3.child, null, f3), b2.child = Ug(b2, null, h3, f3)) : Xi$1(a3, b2, h3, f3);
  b2.memoizedState = d3.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a3) {
  var b2 = a3.stateNode;
  b2.pendingContext ? ag(a3, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a3, b2.context, false);
  yh(a3, b2.containerInfo);
}
function lj(a3, b2, c2, d3, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi$1(a3, b2, c2, d3);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a3) {
  return { baseLanes: a3, cachePool: null, transitions: null };
}
function oj(a3, b2, c2) {
  var d3 = b2.pendingProps, e2 = L$4.current, f3 = false, g2 = 0 !== (b2.flags & 128), h3;
  (h3 = g2) || (h3 = null !== a3 && null === a3.memoizedState ? false : 0 !== (e2 & 2));
  if (h3) f3 = true, b2.flags &= -129;
  else if (null === a3 || null !== a3.memoizedState) e2 |= 1;
  G$3(L$4, e2 & 1);
  if (null === a3) {
    Eg(b2);
    a3 = b2.memoizedState;
    if (null !== a3 && (a3 = a3.dehydrated, null !== a3)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a3.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d3.children;
    a3 = d3.fallback;
    return f3 ? (d3 = b2.mode, f3 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d3 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g2) : f3 = pj(g2, d3, 0, null), a3 = Tg(a3, d3, c2, null), f3.return = b2, a3.return = b2, f3.sibling = a3, b2.child = f3, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a3) : qj(b2, g2);
  }
  e2 = a3.memoizedState;
  if (null !== e2 && (h3 = e2.dehydrated, null !== h3)) return rj(a3, b2, g2, d3, h3, e2, c2);
  if (f3) {
    f3 = d3.fallback;
    g2 = b2.mode;
    e2 = a3.child;
    h3 = e2.sibling;
    var k2 = { mode: "hidden", children: d3.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d3 = b2.child, d3.childLanes = 0, d3.pendingProps = k2, b2.deletions = null) : (d3 = Pg(e2, k2), d3.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h3 ? f3 = Pg(h3, f3) : (f3 = Tg(f3, g2, c2, null), f3.flags |= 2);
    f3.return = b2;
    d3.return = b2;
    d3.sibling = f3;
    b2.child = d3;
    d3 = f3;
    f3 = b2.child;
    g2 = a3.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f3.memoizedState = g2;
    f3.childLanes = a3.childLanes & ~c2;
    b2.memoizedState = mj;
    return d3;
  }
  f3 = a3.child;
  a3 = f3.sibling;
  d3 = Pg(f3, { mode: "visible", children: d3.children });
  0 === (b2.mode & 1) && (d3.lanes = c2);
  d3.return = b2;
  d3.sibling = null;
  null !== a3 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a3], b2.flags |= 16) : c2.push(a3));
  b2.child = d3;
  b2.memoizedState = null;
  return d3;
}
function qj(a3, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a3.mode, 0, null);
  b2.return = a3;
  return a3.child = b2;
}
function sj(a3, b2, c2, d3) {
  null !== d3 && Jg(d3);
  Ug(b2, a3.child, null, c2);
  a3 = qj(b2, b2.pendingProps.children);
  a3.flags |= 2;
  b2.memoizedState = null;
  return a3;
}
function rj(a3, b2, c2, d3, e2, f3, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d3 = Ki$1(Error(p$6(422))), sj(a3, b2, g2, d3);
    if (null !== b2.memoizedState) return b2.child = a3.child, b2.flags |= 128, null;
    f3 = d3.fallback;
    e2 = b2.mode;
    d3 = pj({ mode: "visible", children: d3.children }, e2, 0, null);
    f3 = Tg(f3, e2, g2, null);
    f3.flags |= 2;
    d3.return = b2;
    f3.return = b2;
    d3.sibling = f3;
    b2.child = d3;
    0 !== (b2.mode & 1) && Ug(b2, a3.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f3;
  }
  if (0 === (b2.mode & 1)) return sj(a3, b2, g2, null);
  if ("$!" === e2.data) {
    d3 = e2.nextSibling && e2.nextSibling.dataset;
    if (d3) var h3 = d3.dgst;
    d3 = h3;
    f3 = Error(p$6(419));
    d3 = Ki$1(f3, d3, void 0);
    return sj(a3, b2, g2, d3);
  }
  h3 = 0 !== (g2 & a3.childLanes);
  if (dh || h3) {
    d3 = Q$3;
    if (null !== d3) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d3.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f3.retryLane && (f3.retryLane = e2, ih(a3, e2), gi$1(d3, a3, e2, -1));
    }
    tj();
    d3 = Ki$1(Error(p$6(421)));
    return sj(a3, b2, g2, d3);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a3.child, b2 = uj.bind(null, a3), e2._reactRetry = b2, null;
  a3 = f3.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$5 = true;
  zg = null;
  null !== a3 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a3.id, sg = a3.overflow, qg = b2);
  b2 = qj(b2, d3.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a3, b2, c2) {
  a3.lanes |= b2;
  var d3 = a3.alternate;
  null !== d3 && (d3.lanes |= b2);
  bh(a3.return, b2, c2);
}
function wj(a3, b2, c2, d3, e2) {
  var f3 = a3.memoizedState;
  null === f3 ? a3.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d3, tail: c2, tailMode: e2 } : (f3.isBackwards = b2, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d3, f3.tail = c2, f3.tailMode = e2);
}
function xj(a3, b2, c2) {
  var d3 = b2.pendingProps, e2 = d3.revealOrder, f3 = d3.tail;
  Xi$1(a3, b2, d3.children, c2);
  d3 = L$4.current;
  if (0 !== (d3 & 2)) d3 = d3 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a3 && 0 !== (a3.flags & 128)) a: for (a3 = b2.child; null !== a3; ) {
      if (13 === a3.tag) null !== a3.memoizedState && vj(a3, c2, b2);
      else if (19 === a3.tag) vj(a3, c2, b2);
      else if (null !== a3.child) {
        a3.child.return = a3;
        a3 = a3.child;
        continue;
      }
      if (a3 === b2) break a;
      for (; null === a3.sibling; ) {
        if (null === a3.return || a3.return === b2) break a;
        a3 = a3.return;
      }
      a3.sibling.return = a3.return;
      a3 = a3.sibling;
    }
    d3 &= 1;
  }
  G$3(L$4, d3);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a3 = c2.alternate, null !== a3 && null === Ch(a3) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f3);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a3 = e2.alternate;
        if (null !== a3 && null === Ch(a3)) {
          b2.child = e2;
          break;
        }
        a3 = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a3;
      }
      wj(b2, true, c2, null, f3);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a3, b2) {
  0 === (b2.mode & 1) && null !== a3 && (a3.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi$1(a3, b2, c2) {
  null !== a3 && (b2.dependencies = a3.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a3 && b2.child !== a3.child) throw Error(p$6(153));
  if (null !== b2.child) {
    a3 = b2.child;
    c2 = Pg(a3, a3.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a3.sibling; ) a3 = a3.sibling, c2 = c2.sibling = Pg(a3, a3.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a3, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d3 = b2.type._context, e2 = b2.memoizedProps.value;
      G$3(Wg, d3._currentValue);
      d3._currentValue = e2;
      break;
    case 13:
      d3 = b2.memoizedState;
      if (null !== d3) {
        if (null !== d3.dehydrated) return G$3(L$4, L$4.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a3, b2, c2);
        G$3(L$4, L$4.current & 1);
        a3 = Zi$1(a3, b2, c2);
        return null !== a3 ? a3.sibling : null;
      }
      G$3(L$4, L$4.current & 1);
      break;
    case 19:
      d3 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a3.flags & 128)) {
        if (d3) return xj(a3, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$3(L$4, L$4.current);
      if (d3) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a3, b2, c2);
  }
  return Zi$1(a3, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a3, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a3.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a3, b2, c2, d3) {
  var e2 = a3.memoizedProps;
  if (e2 !== d3) {
    a3 = b2.stateNode;
    xh(uh.current);
    var f3 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a3, e2);
        d3 = Ya(a3, d3);
        f3 = [];
        break;
      case "select":
        e2 = A$5({}, e2, { value: void 0 });
        d3 = A$5({}, d3, { value: void 0 });
        f3 = [];
        break;
      case "textarea":
        e2 = gb(a3, e2);
        d3 = gb(a3, d3);
        f3 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d3.onClick && (a3.onclick = Bf);
    }
    ub(c2, d3);
    var g2;
    c2 = null;
    for (l3 in e2) if (!d3.hasOwnProperty(l3) && e2.hasOwnProperty(l3) && null != e2[l3]) if ("style" === l3) {
      var h3 = e2[l3];
      for (g2 in h3) h3.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l3 && "children" !== l3 && "suppressContentEditableWarning" !== l3 && "suppressHydrationWarning" !== l3 && "autoFocus" !== l3 && (ea.hasOwnProperty(l3) ? f3 || (f3 = []) : (f3 = f3 || []).push(l3, null));
    for (l3 in d3) {
      var k2 = d3[l3];
      h3 = null != e2 ? e2[l3] : void 0;
      if (d3.hasOwnProperty(l3) && k2 !== h3 && (null != k2 || null != h3)) if ("style" === l3) if (h3) {
        for (g2 in h3) !h3.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h3[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f3 || (f3 = []), f3.push(
        l3,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l3 ? (k2 = k2 ? k2.__html : void 0, h3 = h3 ? h3.__html : void 0, null != k2 && h3 !== k2 && (f3 = f3 || []).push(l3, k2)) : "children" === l3 ? "string" !== typeof k2 && "number" !== typeof k2 || (f3 = f3 || []).push(l3, "" + k2) : "suppressContentEditableWarning" !== l3 && "suppressHydrationWarning" !== l3 && (ea.hasOwnProperty(l3) ? (null != k2 && "onScroll" === l3 && D$4("scroll", a3), f3 || h3 === k2 || (f3 = [])) : (f3 = f3 || []).push(l3, k2));
    }
    c2 && (f3 = f3 || []).push("style", c2);
    var l3 = f3;
    if (b2.updateQueue = l3) b2.flags |= 4;
  }
};
Cj = function(a3, b2, c2, d3) {
  c2 !== d3 && (b2.flags |= 4);
};
function Dj(a3, b2) {
  if (!I$5) switch (a3.tailMode) {
    case "hidden":
      b2 = a3.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a3.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a3.tail;
      for (var d3 = null; null !== c2; ) null !== c2.alternate && (d3 = c2), c2 = c2.sibling;
      null === d3 ? b2 || null === a3.tail ? a3.tail = null : a3.tail.sibling = null : d3.sibling = null;
  }
}
function S$5(a3) {
  var b2 = null !== a3.alternate && a3.alternate.child === a3.child, c2 = 0, d3 = 0;
  if (b2) for (var e2 = a3.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags & 14680064, d3 |= e2.flags & 14680064, e2.return = a3, e2 = e2.sibling;
  else for (e2 = a3.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags, d3 |= e2.flags, e2.return = a3, e2 = e2.sibling;
  a3.subtreeFlags |= d3;
  a3.childLanes = c2;
  return b2;
}
function Ej(a3, b2, c2) {
  var d3 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$5(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$5(b2), null;
    case 3:
      d3 = b2.stateNode;
      zh();
      E$5(Wf);
      E$5(H$5);
      Eh();
      d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
      if (null === a3 || null === a3.child) Gg(b2) ? b2.flags |= 4 : null === a3 || a3.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a3, b2);
      S$5(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a3 && null != b2.stateNode) Bj(a3, b2, c2, d3, e2), a3.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d3) {
          if (null === b2.stateNode) throw Error(p$6(166));
          S$5(b2);
          return null;
        }
        a3 = xh(uh.current);
        if (Gg(b2)) {
          d3 = b2.stateNode;
          c2 = b2.type;
          var f3 = b2.memoizedProps;
          d3[Of] = b2;
          d3[Pf] = f3;
          a3 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$4("cancel", d3);
              D$4("close", d3);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$4("load", d3);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D$4(lf[e2], d3);
              break;
            case "source":
              D$4("error", d3);
              break;
            case "img":
            case "image":
            case "link":
              D$4(
                "error",
                d3
              );
              D$4("load", d3);
              break;
            case "details":
              D$4("toggle", d3);
              break;
            case "input":
              Za(d3, f3);
              D$4("invalid", d3);
              break;
            case "select":
              d3._wrapperState = { wasMultiple: !!f3.multiple };
              D$4("invalid", d3);
              break;
            case "textarea":
              hb(d3, f3), D$4("invalid", d3);
          }
          ub(c2, f3);
          e2 = null;
          for (var g2 in f3) if (f3.hasOwnProperty(g2)) {
            var h3 = f3[g2];
            "children" === g2 ? "string" === typeof h3 ? d3.textContent !== h3 && (true !== f3.suppressHydrationWarning && Af(d3.textContent, h3, a3), e2 = ["children", h3]) : "number" === typeof h3 && d3.textContent !== "" + h3 && (true !== f3.suppressHydrationWarning && Af(
              d3.textContent,
              h3,
              a3
            ), e2 = ["children", "" + h3]) : ea.hasOwnProperty(g2) && null != h3 && "onScroll" === g2 && D$4("scroll", d3);
          }
          switch (c2) {
            case "input":
              Va(d3);
              db(d3, f3, true);
              break;
            case "textarea":
              Va(d3);
              jb(d3);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f3.onClick && (d3.onclick = Bf);
          }
          d3 = e2;
          b2.updateQueue = d3;
          null !== d3 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a3 && (a3 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a3 ? "script" === c2 ? (a3 = g2.createElement("div"), a3.innerHTML = "<script><\/script>", a3 = a3.removeChild(a3.firstChild)) : "string" === typeof d3.is ? a3 = g2.createElement(c2, { is: d3.is }) : (a3 = g2.createElement(c2), "select" === c2 && (g2 = a3, d3.multiple ? g2.multiple = true : d3.size && (g2.size = d3.size))) : a3 = g2.createElementNS(a3, c2);
          a3[Of] = b2;
          a3[Pf] = d3;
          zj(a3, b2, false, false);
          b2.stateNode = a3;
          a: {
            g2 = vb(c2, d3);
            switch (c2) {
              case "dialog":
                D$4("cancel", a3);
                D$4("close", a3);
                e2 = d3;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$4("load", a3);
                e2 = d3;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D$4(lf[e2], a3);
                e2 = d3;
                break;
              case "source":
                D$4("error", a3);
                e2 = d3;
                break;
              case "img":
              case "image":
              case "link":
                D$4(
                  "error",
                  a3
                );
                D$4("load", a3);
                e2 = d3;
                break;
              case "details":
                D$4("toggle", a3);
                e2 = d3;
                break;
              case "input":
                Za(a3, d3);
                e2 = Ya(a3, d3);
                D$4("invalid", a3);
                break;
              case "option":
                e2 = d3;
                break;
              case "select":
                a3._wrapperState = { wasMultiple: !!d3.multiple };
                e2 = A$5({}, d3, { value: void 0 });
                D$4("invalid", a3);
                break;
              case "textarea":
                hb(a3, d3);
                e2 = gb(a3, d3);
                D$4("invalid", a3);
                break;
              default:
                e2 = d3;
            }
            ub(c2, e2);
            h3 = e2;
            for (f3 in h3) if (h3.hasOwnProperty(f3)) {
              var k2 = h3[f3];
              "style" === f3 ? sb(a3, k2) : "dangerouslySetInnerHTML" === f3 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a3, k2)) : "children" === f3 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a3, k2) : "number" === typeof k2 && ob(a3, "" + k2) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k2 && "onScroll" === f3 && D$4("scroll", a3) : null != k2 && ta(a3, f3, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a3);
                db(a3, d3, false);
                break;
              case "textarea":
                Va(a3);
                jb(a3);
                break;
              case "option":
                null != d3.value && a3.setAttribute("value", "" + Sa(d3.value));
                break;
              case "select":
                a3.multiple = !!d3.multiple;
                f3 = d3.value;
                null != f3 ? fb(a3, !!d3.multiple, f3, false) : null != d3.defaultValue && fb(
                  a3,
                  !!d3.multiple,
                  d3.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a3.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d3 = !!d3.autoFocus;
                break a;
              case "img":
                d3 = true;
                break a;
              default:
                d3 = false;
            }
          }
          d3 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$5(b2);
      return null;
    case 6:
      if (a3 && null != b2.stateNode) Cj(a3, b2, a3.memoizedProps, d3);
      else {
        if ("string" !== typeof d3 && null === b2.stateNode) throw Error(p$6(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d3 = b2.stateNode;
          c2 = b2.memoizedProps;
          d3[Of] = b2;
          if (f3 = d3.nodeValue !== c2) {
            if (a3 = xg, null !== a3) switch (a3.tag) {
              case 3:
                Af(d3.nodeValue, c2, 0 !== (a3.mode & 1));
                break;
              case 5:
                true !== a3.memoizedProps.suppressHydrationWarning && Af(d3.nodeValue, c2, 0 !== (a3.mode & 1));
            }
          }
          f3 && (b2.flags |= 4);
        } else d3 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d3), d3[Of] = b2, b2.stateNode = d3;
      }
      S$5(b2);
      return null;
    case 13:
      E$5(L$4);
      d3 = b2.memoizedState;
      if (null === a3 || null !== a3.memoizedState && null !== a3.memoizedState.dehydrated) {
        if (I$5 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f3 = false;
        else if (f3 = Gg(b2), null !== d3 && null !== d3.dehydrated) {
          if (null === a3) {
            if (!f3) throw Error(p$6(318));
            f3 = b2.memoizedState;
            f3 = null !== f3 ? f3.dehydrated : null;
            if (!f3) throw Error(p$6(317));
            f3[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$5(b2);
          f3 = false;
        } else null !== zg && (Fj(zg), zg = null), f3 = true;
        if (!f3) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d3 = null !== d3;
      d3 !== (null !== a3 && null !== a3.memoizedState) && d3 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a3 || 0 !== (L$4.current & 1) ? 0 === T$6 && (T$6 = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$5(b2);
      return null;
    case 4:
      return zh(), Aj(a3, b2), null === a3 && sf(b2.stateNode.containerInfo), S$5(b2), null;
    case 10:
      return ah(b2.type._context), S$5(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$5(b2), null;
    case 19:
      E$5(L$4);
      f3 = b2.memoizedState;
      if (null === f3) return S$5(b2), null;
      d3 = 0 !== (b2.flags & 128);
      g2 = f3.rendering;
      if (null === g2) if (d3) Dj(f3, false);
      else {
        if (0 !== T$6 || null !== a3 && 0 !== (a3.flags & 128)) for (a3 = b2.child; null !== a3; ) {
          g2 = Ch(a3);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f3, false);
            d3 = g2.updateQueue;
            null !== d3 && (b2.updateQueue = d3, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d3 = c2;
            for (c2 = b2.child; null !== c2; ) f3 = c2, a3 = d3, f3.flags &= 14680066, g2 = f3.alternate, null === g2 ? (f3.childLanes = 0, f3.lanes = a3, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g2.childLanes, f3.lanes = g2.lanes, f3.child = g2.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g2.memoizedProps, f3.memoizedState = g2.memoizedState, f3.updateQueue = g2.updateQueue, f3.type = g2.type, a3 = g2.dependencies, f3.dependencies = null === a3 ? null : { lanes: a3.lanes, firstContext: a3.firstContext }), c2 = c2.sibling;
            G$3(L$4, L$4.current & 1 | 2);
            return b2.child;
          }
          a3 = a3.sibling;
        }
        null !== f3.tail && B$2() > Gj && (b2.flags |= 128, d3 = true, Dj(f3, false), b2.lanes = 4194304);
      }
      else {
        if (!d3) if (a3 = Ch(g2), null !== a3) {
          if (b2.flags |= 128, d3 = true, c2 = a3.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g2.alternate && !I$5) return S$5(b2), null;
        } else 2 * B$2() - f3.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d3 = true, Dj(f3, false), b2.lanes = 4194304);
        f3.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f3.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f3.last = g2);
      }
      if (null !== f3.tail) return b2 = f3.tail, f3.rendering = b2, f3.tail = b2.sibling, f3.renderingStartTime = B$2(), b2.sibling = null, c2 = L$4.current, G$3(L$4, d3 ? c2 & 1 | 2 : c2 & 1), b2;
      S$5(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d3 = null !== b2.memoizedState, null !== a3 && null !== a3.memoizedState !== d3 && (b2.flags |= 8192), d3 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$5(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$5(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$6(156, b2.tag));
}
function Ij(a3, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a3 = b2.flags, a3 & 65536 ? (b2.flags = a3 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E$5(Wf), E$5(H$5), Eh(), a3 = b2.flags, 0 !== (a3 & 65536) && 0 === (a3 & 128) ? (b2.flags = a3 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E$5(L$4);
      a3 = b2.memoizedState;
      if (null !== a3 && null !== a3.dehydrated) {
        if (null === b2.alternate) throw Error(p$6(340));
        Ig();
      }
      a3 = b2.flags;
      return a3 & 65536 ? (b2.flags = a3 & -65537 | 128, b2) : null;
    case 19:
      return E$5(L$4), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$5 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$4 = null;
function Lj(a3, b2) {
  var c2 = a3.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d3) {
    W$4(a3, b2, d3);
  }
  else c2.current = null;
}
function Mj(a3, b2, c2) {
  try {
    c2();
  } catch (d3) {
    W$4(a3, b2, d3);
  }
}
var Nj = false;
function Oj(a3, b2) {
  Cf = dd;
  a3 = Me$3();
  if (Ne$1(a3)) {
    if ("selectionStart" in a3) var c2 = { start: a3.selectionStart, end: a3.selectionEnd };
    else a: {
      c2 = (c2 = a3.ownerDocument) && c2.defaultView || window;
      var d3 = c2.getSelection && c2.getSelection();
      if (d3 && 0 !== d3.rangeCount) {
        c2 = d3.anchorNode;
        var e2 = d3.anchorOffset, f3 = d3.focusNode;
        d3 = d3.focusOffset;
        try {
          c2.nodeType, f3.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h3 = -1, k2 = -1, l3 = 0, m3 = 0, q2 = a3, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h3 = g2 + e2);
            q2 !== f3 || 0 !== d3 && 3 !== q2.nodeType || (k2 = g2 + d3);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a3) break b;
            r2 === c2 && ++l3 === e2 && (h3 = g2);
            r2 === f3 && ++m3 === d3 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h3 || -1 === k2 ? null : { start: h3, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a3, selectionRange: c2 };
  dd = false;
  for (V$4 = b2; null !== V$4; ) if (b2 = V$4, a3 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a3) a3.return = b2, V$4 = a3;
  else for (; null !== V$4; ) {
    b2 = V$4;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci$1(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u3 = b2.stateNode.containerInfo;
          1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$6(163));
      }
    } catch (F2) {
      W$4(b2, b2.return, F2);
    }
    a3 = b2.sibling;
    if (null !== a3) {
      a3.return = b2.return;
      V$4 = a3;
      break;
    }
    V$4 = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a3, b2, c2) {
  var d3 = b2.updateQueue;
  d3 = null !== d3 ? d3.lastEffect : null;
  if (null !== d3) {
    var e2 = d3 = d3.next;
    do {
      if ((e2.tag & a3) === a3) {
        var f3 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f3 && Mj(b2, c2, f3);
      }
      e2 = e2.next;
    } while (e2 !== d3);
  }
}
function Qj(a3, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a3) === a3) {
        var d3 = c2.create;
        c2.destroy = d3();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a3) {
  var b2 = a3.ref;
  if (null !== b2) {
    var c2 = a3.stateNode;
    switch (a3.tag) {
      case 5:
        a3 = c2;
        break;
      default:
        a3 = c2;
    }
    "function" === typeof b2 ? b2(a3) : b2.current = a3;
  }
}
function Sj(a3) {
  var b2 = a3.alternate;
  null !== b2 && (a3.alternate = null, Sj(b2));
  a3.child = null;
  a3.deletions = null;
  a3.sibling = null;
  5 === a3.tag && (b2 = a3.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a3.stateNode = null;
  a3.return = null;
  a3.dependencies = null;
  a3.memoizedProps = null;
  a3.memoizedState = null;
  a3.pendingProps = null;
  a3.stateNode = null;
  a3.updateQueue = null;
}
function Tj(a3) {
  return 5 === a3.tag || 3 === a3.tag || 4 === a3.tag;
}
function Uj(a3) {
  a: for (; ; ) {
    for (; null === a3.sibling; ) {
      if (null === a3.return || Tj(a3.return)) return null;
      a3 = a3.return;
    }
    a3.sibling.return = a3.return;
    for (a3 = a3.sibling; 5 !== a3.tag && 6 !== a3.tag && 18 !== a3.tag; ) {
      if (a3.flags & 2) continue a;
      if (null === a3.child || 4 === a3.tag) continue a;
      else a3.child.return = a3, a3 = a3.child;
    }
    if (!(a3.flags & 2)) return a3.stateNode;
  }
}
function Vj(a3, b2, c2) {
  var d3 = a3.tag;
  if (5 === d3 || 6 === d3) a3 = a3.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a3, b2) : c2.insertBefore(a3, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a3, c2)) : (b2 = c2, b2.appendChild(a3)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d3 && (a3 = a3.child, null !== a3)) for (Vj(a3, b2, c2), a3 = a3.sibling; null !== a3; ) Vj(a3, b2, c2), a3 = a3.sibling;
}
function Wj(a3, b2, c2) {
  var d3 = a3.tag;
  if (5 === d3 || 6 === d3) a3 = a3.stateNode, b2 ? c2.insertBefore(a3, b2) : c2.appendChild(a3);
  else if (4 !== d3 && (a3 = a3.child, null !== a3)) for (Wj(a3, b2, c2), a3 = a3.sibling; null !== a3; ) Wj(a3, b2, c2), a3 = a3.sibling;
}
var X$5 = null, Xj = false;
function Yj(a3, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a3, b2, c2), c2 = c2.sibling;
}
function Zj(a3, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h3) {
  }
  switch (c2.tag) {
    case 5:
      U$5 || Lj(c2, b2);
    case 6:
      var d3 = X$5, e2 = Xj;
      X$5 = null;
      Yj(a3, b2, c2);
      X$5 = d3;
      Xj = e2;
      null !== X$5 && (Xj ? (a3 = X$5, c2 = c2.stateNode, 8 === a3.nodeType ? a3.parentNode.removeChild(c2) : a3.removeChild(c2)) : X$5.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$5 && (Xj ? (a3 = X$5, c2 = c2.stateNode, 8 === a3.nodeType ? Kf(a3.parentNode, c2) : 1 === a3.nodeType && Kf(a3, c2), bd(a3)) : Kf(X$5, c2.stateNode));
      break;
    case 4:
      d3 = X$5;
      e2 = Xj;
      X$5 = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a3, b2, c2);
      X$5 = d3;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$5 && (d3 = c2.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
        e2 = d3 = d3.next;
        do {
          var f3 = e2, g2 = f3.destroy;
          f3 = f3.tag;
          void 0 !== g2 && (0 !== (f3 & 2) ? Mj(c2, b2, g2) : 0 !== (f3 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d3);
      }
      Yj(a3, b2, c2);
      break;
    case 1:
      if (!U$5 && (Lj(c2, b2), d3 = c2.stateNode, "function" === typeof d3.componentWillUnmount)) try {
        d3.props = c2.memoizedProps, d3.state = c2.memoizedState, d3.componentWillUnmount();
      } catch (h3) {
        W$4(c2, b2, h3);
      }
      Yj(a3, b2, c2);
      break;
    case 21:
      Yj(a3, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$5 = (d3 = U$5) || null !== c2.memoizedState, Yj(a3, b2, c2), U$5 = d3) : Yj(a3, b2, c2);
      break;
    default:
      Yj(a3, b2, c2);
  }
}
function ak(a3) {
  var b2 = a3.updateQueue;
  if (null !== b2) {
    a3.updateQueue = null;
    var c2 = a3.stateNode;
    null === c2 && (c2 = a3.stateNode = new Kj());
    b2.forEach(function(b22) {
      var d3 = bk.bind(null, a3, b22);
      c2.has(b22) || (c2.add(b22), b22.then(d3, d3));
    });
  }
}
function ck(a3, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d3 = 0; d3 < c2.length; d3++) {
    var e2 = c2[d3];
    try {
      var f3 = a3, g2 = b2, h3 = g2;
      a: for (; null !== h3; ) {
        switch (h3.tag) {
          case 5:
            X$5 = h3.stateNode;
            Xj = false;
            break a;
          case 3:
            X$5 = h3.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$5 = h3.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h3 = h3.return;
      }
      if (null === X$5) throw Error(p$6(160));
      Zj(f3, g2, e2);
      X$5 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l3) {
      W$4(e2, b2, l3);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a3), b2 = b2.sibling;
}
function dk(a3, b2) {
  var c2 = a3.alternate, d3 = a3.flags;
  switch (a3.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a3);
      ek(a3);
      if (d3 & 4) {
        try {
          Pj(3, a3, a3.return), Qj(3, a3);
        } catch (t2) {
          W$4(a3, a3.return, t2);
        }
        try {
          Pj(5, a3, a3.return);
        } catch (t2) {
          W$4(a3, a3.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a3);
      ek(a3);
      d3 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a3);
      ek(a3);
      d3 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a3.flags & 32) {
        var e2 = a3.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$4(a3, a3.return, t2);
        }
      }
      if (d3 & 4 && (e2 = a3.stateNode, null != e2)) {
        var f3 = a3.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f3, h3 = a3.type, k2 = a3.updateQueue;
        a3.updateQueue = null;
        if (null !== k2) try {
          "input" === h3 && "radio" === f3.type && null != f3.name && ab(e2, f3);
          vb(h3, g2);
          var l3 = vb(h3, f3);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m3 = k2[g2], q2 = k2[g2 + 1];
            "style" === m3 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m3 ? nb(e2, q2) : "children" === m3 ? ob(e2, q2) : ta(e2, m3, q2, l3);
          }
          switch (h3) {
            case "input":
              bb(e2, f3);
              break;
            case "textarea":
              ib(e2, f3);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f3.multiple;
              var y2 = f3.value;
              null != y2 ? fb(e2, !!f3.multiple, y2, false) : r2 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                e2,
                !!f3.multiple,
                f3.defaultValue,
                true
              ) : fb(e2, !!f3.multiple, f3.multiple ? [] : "", false));
          }
          e2[Pf] = f3;
        } catch (t2) {
          W$4(a3, a3.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a3);
      ek(a3);
      if (d3 & 4) {
        if (null === a3.stateNode) throw Error(p$6(162));
        e2 = a3.stateNode;
        f3 = a3.memoizedProps;
        try {
          e2.nodeValue = f3;
        } catch (t2) {
          W$4(a3, a3.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a3);
      ek(a3);
      if (d3 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W$4(a3, a3.return, t2);
      }
      break;
    case 4:
      ck(b2, a3);
      ek(a3);
      break;
    case 13:
      ck(b2, a3);
      ek(a3);
      e2 = a3.child;
      e2.flags & 8192 && (f3 = null !== e2.memoizedState, e2.stateNode.isHidden = f3, !f3 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B$2()));
      d3 & 4 && ak(a3);
      break;
    case 22:
      m3 = null !== c2 && null !== c2.memoizedState;
      a3.mode & 1 ? (U$5 = (l3 = U$5) || m3, ck(b2, a3), U$5 = l3) : ck(b2, a3);
      ek(a3);
      if (d3 & 8192) {
        l3 = null !== a3.memoizedState;
        if ((a3.stateNode.isHidden = l3) && !m3 && 0 !== (a3.mode & 1)) for (V$4 = a3, m3 = a3.child; null !== m3; ) {
          for (q2 = V$4 = m3; null !== V$4; ) {
            r2 = V$4;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d3 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d3, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W$4(d3, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V$4 = y2) : gk(q2);
          }
          m3 = m3.sibling;
        }
        a: for (m3 = null, q2 = a3; ; ) {
          if (5 === q2.tag) {
            if (null === m3) {
              m3 = q2;
              try {
                e2 = q2.stateNode, l3 ? (f3 = e2.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h3 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h3.style.display = rb("display", g2));
              } catch (t2) {
                W$4(a3, a3.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m3) try {
              q2.stateNode.nodeValue = l3 ? "" : q2.memoizedProps;
            } catch (t2) {
              W$4(a3, a3.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a3) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a3) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a3) break a;
            m3 === q2 && (m3 = null);
            q2 = q2.return;
          }
          m3 === q2 && (m3 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a3);
      ek(a3);
      d3 & 4 && ak(a3);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a3
      ), ek(a3);
  }
}
function ek(a3) {
  var b2 = a3.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a3.return; null !== c2; ) {
          if (Tj(c2)) {
            var d3 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$6(160));
      }
      switch (d3.tag) {
        case 5:
          var e2 = d3.stateNode;
          d3.flags & 32 && (ob(e2, ""), d3.flags &= -33);
          var f3 = Uj(a3);
          Wj(a3, f3, e2);
          break;
        case 3:
        case 4:
          var g2 = d3.stateNode.containerInfo, h3 = Uj(a3);
          Vj(a3, h3, g2);
          break;
        default:
          throw Error(p$6(161));
      }
    } catch (k2) {
      W$4(a3, a3.return, k2);
    }
    a3.flags &= -3;
  }
  b2 & 4096 && (a3.flags &= -4097);
}
function hk(a3, b2, c2) {
  V$4 = a3;
  ik(a3);
}
function ik(a3, b2, c2) {
  for (var d3 = 0 !== (a3.mode & 1); null !== V$4; ) {
    var e2 = V$4, f3 = e2.child;
    if (22 === e2.tag && d3) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h3 = e2.alternate, k2 = null !== h3 && null !== h3.memoizedState || U$5;
        h3 = Jj;
        var l3 = U$5;
        Jj = g2;
        if ((U$5 = k2) && !l3) for (V$4 = e2; null !== V$4; ) g2 = V$4, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V$4 = k2) : jk(e2);
        for (; null !== f3; ) V$4 = f3, ik(f3), f3 = f3.sibling;
        V$4 = e2;
        Jj = h3;
        U$5 = l3;
      }
      kk(a3);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f3 ? (f3.return = e2, V$4 = f3) : kk(a3);
  }
}
function kk(a3) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U$5 || Qj(5, b2);
            break;
          case 1:
            var d3 = b2.stateNode;
            if (b2.flags & 4 && !U$5) if (null === c2) d3.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci$1(b2.type, c2.memoizedProps);
              d3.componentDidUpdate(e2, c2.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
            }
            var f3 = b2.updateQueue;
            null !== f3 && sh(b2, f3, d3);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h3 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h3;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l3 = b2.alternate;
              if (null !== l3) {
                var m3 = l3.memoizedState;
                if (null !== m3) {
                  var q2 = m3.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$6(163));
        }
        U$5 || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W$4(b2, b2.return, r2);
      }
    }
    if (b2 === a3) {
      V$4 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function gk(a3) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    if (b2 === a3) {
      V$4 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$4 = c2;
      break;
    }
    V$4 = b2.return;
  }
}
function jk(a3) {
  for (; null !== V$4; ) {
    var b2 = V$4;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W$4(b2, c2, k2);
          }
          break;
        case 1:
          var d3 = b2.stateNode;
          if ("function" === typeof d3.componentDidMount) {
            var e2 = b2.return;
            try {
              d3.componentDidMount();
            } catch (k2) {
              W$4(b2, e2, k2);
            }
          }
          var f3 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W$4(b2, f3, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W$4(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$4(b2, b2.return, k2);
    }
    if (b2 === a3) {
      V$4 = null;
      break;
    }
    var h3 = b2.sibling;
    if (null !== h3) {
      h3.return = b2.return;
      V$4 = h3;
      break;
    }
    V$4 = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K$3 = 0, Q$3 = null, Y$3 = null, Z$3 = 0, fj = 0, ej = Uf(0), T$6 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi$1 = false, Pi$1 = null, Ri$1 = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R$5() {
  return 0 !== (K$3 & 6) ? B$2() : -1 !== Ak ? Ak : Ak = B$2();
}
function yi$1(a3) {
  if (0 === (a3.mode & 1)) return 1;
  if (0 !== (K$3 & 2) && 0 !== Z$3) return Z$3 & -Z$3;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a3 = C$5;
  if (0 !== a3) return a3;
  a3 = window.event;
  a3 = void 0 === a3 ? 16 : jd(a3.type);
  return a3;
}
function gi$1(a3, b2, c2, d3) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$6(185));
  Ac(a3, c2, d3);
  if (0 === (K$3 & 2) || a3 !== Q$3) a3 === Q$3 && (0 === (K$3 & 2) && (qk |= c2), 4 === T$6 && Ck(a3, Z$3)), Dk(a3, d3), 1 === c2 && 0 === K$3 && 0 === (b2.mode & 1) && (Gj = B$2() + 500, fg && jg());
}
function Dk(a3, b2) {
  var c2 = a3.callbackNode;
  wc(a3, b2);
  var d3 = uc(a3, a3 === Q$3 ? Z$3 : 0);
  if (0 === d3) null !== c2 && bc(c2), a3.callbackNode = null, a3.callbackPriority = 0;
  else if (b2 = d3 & -d3, a3.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a3.tag ? ig(Ek.bind(null, a3)) : hg(Ek.bind(null, a3)), Jf(function() {
      0 === (K$3 & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d3)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a3));
    }
    a3.callbackPriority = b2;
    a3.callbackNode = c2;
  }
}
function Gk(a3, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K$3 & 6)) throw Error(p$6(327));
  var c2 = a3.callbackNode;
  if (Hk() && a3.callbackNode !== c2) return null;
  var d3 = uc(a3, a3 === Q$3 ? Z$3 : 0);
  if (0 === d3) return null;
  if (0 !== (d3 & 30) || 0 !== (d3 & a3.expiredLanes) || b2) b2 = Ik(a3, d3);
  else {
    b2 = d3;
    var e2 = K$3;
    K$3 |= 2;
    var f3 = Jk();
    if (Q$3 !== a3 || Z$3 !== b2) uk = null, Gj = B$2() + 500, Kk(a3, b2);
    do
      try {
        Lk();
        break;
      } catch (h3) {
        Mk(a3, h3);
      }
    while (1);
    $g();
    mk.current = f3;
    K$3 = e2;
    null !== Y$3 ? b2 = 0 : (Q$3 = null, Z$3 = 0, b2 = T$6);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a3), 0 !== e2 && (d3 = e2, b2 = Nk(a3, e2)));
    if (1 === b2) throw c2 = pk, Kk(a3, 0), Ck(a3, d3), Dk(a3, B$2()), c2;
    if (6 === b2) Ck(a3, d3);
    else {
      e2 = a3.current.alternate;
      if (0 === (d3 & 30) && !Ok(e2) && (b2 = Ik(a3, d3), 2 === b2 && (f3 = xc(a3), 0 !== f3 && (d3 = f3, b2 = Nk(a3, f3))), 1 === b2)) throw c2 = pk, Kk(a3, 0), Ck(a3, d3), Dk(a3, B$2()), c2;
      a3.finishedWork = e2;
      a3.finishedLanes = d3;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$6(345));
        case 2:
          Pk(a3, tk, uk);
          break;
        case 3:
          Ck(a3, d3);
          if ((d3 & 130023424) === d3 && (b2 = fk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a3, 0)) break;
            e2 = a3.suspendedLanes;
            if ((e2 & d3) !== d3) {
              R$5();
              a3.pingedLanes |= a3.suspendedLanes & e2;
              break;
            }
            a3.timeoutHandle = Ff(Pk.bind(null, a3, tk, uk), b2);
            break;
          }
          Pk(a3, tk, uk);
          break;
        case 4:
          Ck(a3, d3);
          if ((d3 & 4194240) === d3) break;
          b2 = a3.eventTimes;
          for (e2 = -1; 0 < d3; ) {
            var g2 = 31 - oc(d3);
            f3 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d3 &= ~f3;
          }
          d3 = e2;
          d3 = B$2() - d3;
          d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * lk(d3 / 1960)) - d3;
          if (10 < d3) {
            a3.timeoutHandle = Ff(Pk.bind(null, a3, tk, uk), d3);
            break;
          }
          Pk(a3, tk, uk);
          break;
        case 5:
          Pk(a3, tk, uk);
          break;
        default:
          throw Error(p$6(329));
      }
    }
  }
  Dk(a3, B$2());
  return a3.callbackNode === c2 ? Gk.bind(null, a3) : null;
}
function Nk(a3, b2) {
  var c2 = sk;
  a3.current.memoizedState.isDehydrated && (Kk(a3, b2).flags |= 256);
  a3 = Ik(a3, b2);
  2 !== a3 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a3;
}
function Fj(a3) {
  null === tk ? tk = a3 : tk.push.apply(tk, a3);
}
function Ok(a3) {
  for (var b2 = a3; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d3 = 0; d3 < c2.length; d3++) {
        var e2 = c2[d3], f3 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He$2(f3(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a3) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a3) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a3, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a3.suspendedLanes |= b2;
  a3.pingedLanes &= ~b2;
  for (a3 = a3.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d3 = 1 << c2;
    a3[c2] = -1;
    b2 &= ~d3;
  }
}
function Ek(a3) {
  if (0 !== (K$3 & 6)) throw Error(p$6(327));
  Hk();
  var b2 = uc(a3, 0);
  if (0 === (b2 & 1)) return Dk(a3, B$2()), null;
  var c2 = Ik(a3, b2);
  if (0 !== a3.tag && 2 === c2) {
    var d3 = xc(a3);
    0 !== d3 && (b2 = d3, c2 = Nk(a3, d3));
  }
  if (1 === c2) throw c2 = pk, Kk(a3, 0), Ck(a3, b2), Dk(a3, B$2()), c2;
  if (6 === c2) throw Error(p$6(345));
  a3.finishedWork = a3.current.alternate;
  a3.finishedLanes = b2;
  Pk(a3, tk, uk);
  Dk(a3, B$2());
  return null;
}
function Qk(a3, b2) {
  var c2 = K$3;
  K$3 |= 1;
  try {
    return a3(b2);
  } finally {
    K$3 = c2, 0 === K$3 && (Gj = B$2() + 500, fg && jg());
  }
}
function Rk(a3) {
  null !== wk && 0 === wk.tag && 0 === (K$3 & 6) && Hk();
  var b2 = K$3;
  K$3 |= 1;
  var c2 = ok.transition, d3 = C$5;
  try {
    if (ok.transition = null, C$5 = 1, a3) return a3();
  } finally {
    C$5 = d3, ok.transition = c2, K$3 = b2, 0 === (K$3 & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$5(ej);
}
function Kk(a3, b2) {
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  var c2 = a3.timeoutHandle;
  -1 !== c2 && (a3.timeoutHandle = -1, Gf(c2));
  if (null !== Y$3) for (c2 = Y$3.return; null !== c2; ) {
    var d3 = c2;
    wg(d3);
    switch (d3.tag) {
      case 1:
        d3 = d3.type.childContextTypes;
        null !== d3 && void 0 !== d3 && $f();
        break;
      case 3:
        zh();
        E$5(Wf);
        E$5(H$5);
        Eh();
        break;
      case 5:
        Bh(d3);
        break;
      case 4:
        zh();
        break;
      case 13:
        E$5(L$4);
        break;
      case 19:
        E$5(L$4);
        break;
      case 10:
        ah(d3.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q$3 = a3;
  Y$3 = a3 = Pg(a3.current, null);
  Z$3 = fj = b2;
  T$6 = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d3 = c2.interleaved, null !== d3) {
      c2.interleaved = null;
      var e2 = d3.next, f3 = c2.pending;
      if (null !== f3) {
        var g2 = f3.next;
        f3.next = e2;
        d3.next = g2;
      }
      c2.pending = d3;
    }
    fh = null;
  }
  return a3;
}
function Mk(a3, b2) {
  do {
    var c2 = Y$3;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d3 = M$6.memoizedState; null !== d3; ) {
          var e2 = d3.queue;
          null !== e2 && (e2.pending = null);
          d3 = d3.next;
        }
        Ih = false;
      }
      Hh = 0;
      O$6 = N$3 = M$6 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T$6 = 1;
        pk = b2;
        Y$3 = null;
        break;
      }
      a: {
        var f3 = a3, g2 = c2.return, h3 = c2, k2 = b2;
        b2 = Z$3;
        h3.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l3 = k2, m3 = h3, q2 = m3.tag;
          if (0 === (m3.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m3.alternate;
            r2 ? (m3.updateQueue = r2.updateQueue, m3.memoizedState = r2.memoizedState, m3.lanes = r2.lanes) : (m3.updateQueue = null, m3.memoizedState = null);
          }
          var y2 = Ui$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi$1(y2, g2, h3, f3, b2);
            y2.mode & 1 && Si$1(f3, l3, b2);
            b2 = y2;
            k2 = l3;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si$1(f3, l3, b2);
              tj();
              break a;
            }
            k2 = Error(p$6(426));
          }
        } else if (I$5 && h3.mode & 1) {
          var J2 = Ui$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi$1(J2, g2, h3, f3, b2);
            Jg(Ji$1(k2, h3));
            break a;
          }
        }
        f3 = k2 = Ji$1(k2, h3);
        4 !== T$6 && (T$6 = 2);
        null === sk ? sk = [f3] : sk.push(f3);
        f3 = g2;
        do {
          switch (f3.tag) {
            case 3:
              f3.flags |= 65536;
              b2 &= -b2;
              f3.lanes |= b2;
              var x2 = Ni$1(f3, k2, b2);
              ph(f3, x2);
              break a;
            case 1:
              h3 = k2;
              var w2 = f3.type, u3 = f3.stateNode;
              if (0 === (f3.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Ri$1 || !Ri$1.has(u3)))) {
                f3.flags |= 65536;
                b2 &= -b2;
                f3.lanes |= b2;
                var F2 = Qi$1(f3, h3, b2);
                ph(f3, F2);
                break a;
              }
          }
          f3 = f3.return;
        } while (null !== f3);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y$3 === c2 && null !== c2 && (Y$3 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a3 = mk.current;
  mk.current = Rh;
  return null === a3 ? Rh : a3;
}
function tj() {
  if (0 === T$6 || 3 === T$6 || 2 === T$6) T$6 = 4;
  null === Q$3 || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q$3, Z$3);
}
function Ik(a3, b2) {
  var c2 = K$3;
  K$3 |= 2;
  var d3 = Jk();
  if (Q$3 !== a3 || Z$3 !== b2) uk = null, Kk(a3, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a3, e2);
    }
  while (1);
  $g();
  K$3 = c2;
  mk.current = d3;
  if (null !== Y$3) throw Error(p$6(261));
  Q$3 = null;
  Z$3 = 0;
  return T$6;
}
function Tk() {
  for (; null !== Y$3; ) Uk(Y$3);
}
function Lk() {
  for (; null !== Y$3 && !cc(); ) Uk(Y$3);
}
function Uk(a3) {
  var b2 = Vk(a3.alternate, a3, fj);
  a3.memoizedProps = a3.pendingProps;
  null === b2 ? Sk(a3) : Y$3 = b2;
  nk.current = null;
}
function Sk(a3) {
  var b2 = a3;
  do {
    var c2 = b2.alternate;
    a3 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y$3 = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$3 = c2;
        return;
      }
      if (null !== a3) a3.flags |= 32768, a3.subtreeFlags = 0, a3.deletions = null;
      else {
        T$6 = 6;
        Y$3 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$3 = b2;
      return;
    }
    Y$3 = b2 = a3;
  } while (null !== b2);
  0 === T$6 && (T$6 = 5);
}
function Pk(a3, b2, c2) {
  var d3 = C$5, e2 = ok.transition;
  try {
    ok.transition = null, C$5 = 1, Wk(a3, b2, c2, d3);
  } finally {
    ok.transition = e2, C$5 = d3;
  }
  return null;
}
function Wk(a3, b2, c2, d3) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K$3 & 6)) throw Error(p$6(327));
  c2 = a3.finishedWork;
  var e2 = a3.finishedLanes;
  if (null === c2) return null;
  a3.finishedWork = null;
  a3.finishedLanes = 0;
  if (c2 === a3.current) throw Error(p$6(177));
  a3.callbackNode = null;
  a3.callbackPriority = 0;
  var f3 = c2.lanes | c2.childLanes;
  Bc(a3, f3);
  a3 === Q$3 && (Y$3 = Q$3 = null, Z$3 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f3 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f3) {
    f3 = ok.transition;
    ok.transition = null;
    var g2 = C$5;
    C$5 = 1;
    var h3 = K$3;
    K$3 |= 4;
    nk.current = null;
    Oj(a3, c2);
    dk(c2, a3);
    Oe$2(Df);
    dd = !!Cf;
    Df = Cf = null;
    a3.current = c2;
    hk(c2);
    dc();
    K$3 = h3;
    C$5 = g2;
    ok.transition = f3;
  } else a3.current = c2;
  vk && (vk = false, wk = a3, xk = e2);
  f3 = a3.pendingLanes;
  0 === f3 && (Ri$1 = null);
  mc(c2.stateNode);
  Dk(a3, B$2());
  if (null !== b2) for (d3 = a3.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d3(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi$1) throw Oi$1 = false, a3 = Pi$1, Pi$1 = null, a3;
  0 !== (xk & 1) && 0 !== a3.tag && Hk();
  f3 = a3.pendingLanes;
  0 !== (f3 & 1) ? a3 === zk ? yk++ : (yk = 0, zk = a3) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a3 = Dc(xk), b2 = ok.transition, c2 = C$5;
    try {
      ok.transition = null;
      C$5 = 16 > a3 ? 16 : a3;
      if (null === wk) var d3 = false;
      else {
        a3 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K$3 & 6)) throw Error(p$6(331));
        var e2 = K$3;
        K$3 |= 4;
        for (V$4 = a3.current; null !== V$4; ) {
          var f3 = V$4, g2 = f3.child;
          if (0 !== (V$4.flags & 16)) {
            var h3 = f3.deletions;
            if (null !== h3) {
              for (var k2 = 0; k2 < h3.length; k2++) {
                var l3 = h3[k2];
                for (V$4 = l3; null !== V$4; ) {
                  var m3 = V$4;
                  switch (m3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m3, f3);
                  }
                  var q2 = m3.child;
                  if (null !== q2) q2.return = m3, V$4 = q2;
                  else for (; null !== V$4; ) {
                    m3 = V$4;
                    var r2 = m3.sibling, y2 = m3.return;
                    Sj(m3);
                    if (m3 === l3) {
                      V$4 = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V$4 = r2;
                      break;
                    }
                    V$4 = y2;
                  }
                }
              }
              var n2 = f3.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$4 = f3;
            }
          }
          if (0 !== (f3.subtreeFlags & 2064) && null !== g2) g2.return = f3, V$4 = g2;
          else b: for (; null !== V$4; ) {
            f3 = V$4;
            if (0 !== (f3.flags & 2048)) switch (f3.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f3, f3.return);
            }
            var x2 = f3.sibling;
            if (null !== x2) {
              x2.return = f3.return;
              V$4 = x2;
              break b;
            }
            V$4 = f3.return;
          }
        }
        var w2 = a3.current;
        for (V$4 = w2; null !== V$4; ) {
          g2 = V$4;
          var u3 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u3) u3.return = g2, V$4 = u3;
          else b: for (g2 = w2; null !== V$4; ) {
            h3 = V$4;
            if (0 !== (h3.flags & 2048)) try {
              switch (h3.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h3);
              }
            } catch (na) {
              W$4(h3, h3.return, na);
            }
            if (h3 === g2) {
              V$4 = null;
              break b;
            }
            var F2 = h3.sibling;
            if (null !== F2) {
              F2.return = h3.return;
              V$4 = F2;
              break b;
            }
            V$4 = h3.return;
          }
        }
        K$3 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a3);
        } catch (na) {
        }
        d3 = true;
      }
      return d3;
    } finally {
      C$5 = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a3, b2, c2) {
  b2 = Ji$1(c2, b2);
  b2 = Ni$1(a3, b2, 1);
  a3 = nh(a3, b2, 1);
  b2 = R$5();
  null !== a3 && (Ac(a3, 1, b2), Dk(a3, b2));
}
function W$4(a3, b2, c2) {
  if (3 === a3.tag) Xk(a3, a3, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a3, c2);
      break;
    } else if (1 === b2.tag) {
      var d3 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Ri$1 || !Ri$1.has(d3))) {
        a3 = Ji$1(c2, a3);
        a3 = Qi$1(b2, a3, 1);
        b2 = nh(b2, a3, 1);
        a3 = R$5();
        null !== b2 && (Ac(b2, 1, a3), Dk(b2, a3));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti$1(a3, b2, c2) {
  var d3 = a3.pingCache;
  null !== d3 && d3.delete(b2);
  b2 = R$5();
  a3.pingedLanes |= a3.suspendedLanes & c2;
  Q$3 === a3 && (Z$3 & c2) === c2 && (4 === T$6 || 3 === T$6 && (Z$3 & 130023424) === Z$3 && 500 > B$2() - fk ? Kk(a3, 0) : rk |= c2);
  Dk(a3, b2);
}
function Yk(a3, b2) {
  0 === b2 && (0 === (a3.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R$5();
  a3 = ih(a3, b2);
  null !== a3 && (Ac(a3, b2, c2), Dk(a3, c2));
}
function uj(a3) {
  var b2 = a3.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a3, c2);
}
function bk(a3, b2) {
  var c2 = 0;
  switch (a3.tag) {
    case 13:
      var d3 = a3.stateNode;
      var e2 = a3.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d3 = a3.stateNode;
      break;
    default:
      throw Error(p$6(314));
  }
  null !== d3 && d3.delete(b2);
  Yk(a3, c2);
}
var Vk;
Vk = function(a3, b2, c2) {
  if (null !== a3) if (a3.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a3.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a3, b2, c2);
    dh = 0 !== (a3.flags & 131072) ? true : false;
  }
  else dh = false, I$5 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d3 = b2.type;
      ij(a3, b2);
      a3 = b2.pendingProps;
      var e2 = Yf(b2, H$5.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d3, a3, e2, c2);
      var f3 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d3) ? (f3 = true, cg(b2)) : f3 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei$1, b2.stateNode = e2, e2._reactInternals = b2, Ii$1(b2, d3, a3, c2), b2 = jj(null, b2, d3, true, f3, c2)) : (b2.tag = 0, I$5 && f3 && vg(b2), Xi$1(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d3 = b2.elementType;
      a: {
        ij(a3, b2);
        a3 = b2.pendingProps;
        e2 = d3._init;
        d3 = e2(d3._payload);
        b2.type = d3;
        e2 = b2.tag = Zk(d3);
        a3 = Ci$1(d3, a3);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d3, a3, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d3, a3, c2);
            break a;
          case 11:
            b2 = Yi$1(null, b2, d3, a3, c2);
            break a;
          case 14:
            b2 = $i$1(null, b2, d3, Ci$1(d3.type, a3), c2);
            break a;
        }
        throw Error(p$6(
          306,
          d3,
          ""
        ));
      }
      return b2;
    case 0:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci$1(d3, e2), cj(a3, b2, d3, e2, c2);
    case 1:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci$1(d3, e2), hj(a3, b2, d3, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a3) throw Error(p$6(387));
        d3 = b2.pendingProps;
        f3 = b2.memoizedState;
        e2 = f3.element;
        lh(a3, b2);
        qh(b2, d3, null, c2);
        var g2 = b2.memoizedState;
        d3 = g2.element;
        if (f3.isDehydrated) if (f3 = { element: d3, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f3, b2.memoizedState = f3, b2.flags & 256) {
          e2 = Ji$1(Error(p$6(423)), b2);
          b2 = lj(a3, b2, d3, c2, e2);
          break a;
        } else if (d3 !== e2) {
          e2 = Ji$1(Error(p$6(424)), b2);
          b2 = lj(a3, b2, d3, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$5 = true, zg = null, c2 = Vg(b2, null, d3, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d3 === e2) {
            b2 = Zi$1(a3, b2, c2);
            break a;
          }
          Xi$1(a3, b2, d3, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a3 && Eg(b2), d3 = b2.type, e2 = b2.pendingProps, f3 = null !== a3 ? a3.memoizedProps : null, g2 = e2.children, Ef(d3, e2) ? g2 = null : null !== f3 && Ef(d3, f3) && (b2.flags |= 32), gj(a3, b2), Xi$1(a3, b2, g2, c2), b2.child;
    case 6:
      return null === a3 && Eg(b2), null;
    case 13:
      return oj(a3, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d3 = b2.pendingProps, null === a3 ? b2.child = Ug(b2, null, d3, c2) : Xi$1(a3, b2, d3, c2), b2.child;
    case 11:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci$1(d3, e2), Yi$1(a3, b2, d3, e2, c2);
    case 7:
      return Xi$1(a3, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi$1(a3, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi$1(a3, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d3 = b2.type._context;
        e2 = b2.pendingProps;
        f3 = b2.memoizedProps;
        g2 = e2.value;
        G$3(Wg, d3._currentValue);
        d3._currentValue = g2;
        if (null !== f3) if (He$2(f3.value, g2)) {
          if (f3.children === e2.children && !Wf.current) {
            b2 = Zi$1(a3, b2, c2);
            break a;
          }
        } else for (f3 = b2.child, null !== f3 && (f3.return = b2); null !== f3; ) {
          var h3 = f3.dependencies;
          if (null !== h3) {
            g2 = f3.child;
            for (var k2 = h3.firstContext; null !== k2; ) {
              if (k2.context === d3) {
                if (1 === f3.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l3 = f3.updateQueue;
                  if (null !== l3) {
                    l3 = l3.shared;
                    var m3 = l3.pending;
                    null === m3 ? k2.next = k2 : (k2.next = m3.next, m3.next = k2);
                    l3.pending = k2;
                  }
                }
                f3.lanes |= c2;
                k2 = f3.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f3.return,
                  c2,
                  b2
                );
                h3.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f3.tag) g2 = f3.type === b2.type ? null : f3.child;
          else if (18 === f3.tag) {
            g2 = f3.return;
            if (null === g2) throw Error(p$6(341));
            g2.lanes |= c2;
            h3 = g2.alternate;
            null !== h3 && (h3.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f3.sibling;
          } else g2 = f3.child;
          if (null !== g2) g2.return = f3;
          else for (g2 = f3; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f3 = g2.sibling;
            if (null !== f3) {
              f3.return = g2.return;
              g2 = f3;
              break;
            }
            g2 = g2.return;
          }
          f3 = g2;
        }
        Xi$1(a3, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d3 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d3 = d3(e2), b2.flags |= 1, Xi$1(a3, b2, d3, c2), b2.child;
    case 14:
      return d3 = b2.type, e2 = Ci$1(d3, b2.pendingProps), e2 = Ci$1(d3.type, e2), $i$1(a3, b2, d3, e2, c2);
    case 15:
      return bj(a3, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d3 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d3 ? e2 : Ci$1(d3, e2), ij(a3, b2), b2.tag = 1, Zf(d3) ? (a3 = true, cg(b2)) : a3 = false, ch(b2, c2), Gi$1(b2, d3, e2), Ii$1(b2, d3, e2, c2), jj(null, b2, d3, true, a3, c2);
    case 19:
      return xj(a3, b2, c2);
    case 22:
      return dj(a3, b2, c2);
  }
  throw Error(p$6(156, b2.tag));
};
function Fk(a3, b2) {
  return ac(a3, b2);
}
function $k(a3, b2, c2, d3) {
  this.tag = a3;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d3;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a3, b2, c2, d3) {
  return new $k(a3, b2, c2, d3);
}
function aj(a3) {
  a3 = a3.prototype;
  return !(!a3 || !a3.isReactComponent);
}
function Zk(a3) {
  if ("function" === typeof a3) return aj(a3) ? 1 : 0;
  if (void 0 !== a3 && null !== a3) {
    a3 = a3.$$typeof;
    if (a3 === Da) return 11;
    if (a3 === Ga) return 14;
  }
  return 2;
}
function Pg(a3, b2) {
  var c2 = a3.alternate;
  null === c2 ? (c2 = Bg(a3.tag, b2, a3.key, a3.mode), c2.elementType = a3.elementType, c2.type = a3.type, c2.stateNode = a3.stateNode, c2.alternate = a3, a3.alternate = c2) : (c2.pendingProps = b2, c2.type = a3.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a3.flags & 14680064;
  c2.childLanes = a3.childLanes;
  c2.lanes = a3.lanes;
  c2.child = a3.child;
  c2.memoizedProps = a3.memoizedProps;
  c2.memoizedState = a3.memoizedState;
  c2.updateQueue = a3.updateQueue;
  b2 = a3.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a3.sibling;
  c2.index = a3.index;
  c2.ref = a3.ref;
  return c2;
}
function Rg(a3, b2, c2, d3, e2, f3) {
  var g2 = 2;
  d3 = a3;
  if ("function" === typeof a3) aj(a3) && (g2 = 1);
  else if ("string" === typeof a3) g2 = 5;
  else a: switch (a3) {
    case ya:
      return Tg(c2.children, e2, f3, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a3 = Bg(12, c2, b2, e2 | 2), a3.elementType = Aa, a3.lanes = f3, a3;
    case Ea:
      return a3 = Bg(13, c2, b2, e2), a3.elementType = Ea, a3.lanes = f3, a3;
    case Fa:
      return a3 = Bg(19, c2, b2, e2), a3.elementType = Fa, a3.lanes = f3, a3;
    case Ia:
      return pj(c2, e2, f3, b2);
    default:
      if ("object" === typeof a3 && null !== a3) switch (a3.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d3 = null;
          break a;
      }
      throw Error(p$6(130, null == a3 ? a3 : typeof a3, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a3;
  b2.type = d3;
  b2.lanes = f3;
  return b2;
}
function Tg(a3, b2, c2, d3) {
  a3 = Bg(7, a3, d3, b2);
  a3.lanes = c2;
  return a3;
}
function pj(a3, b2, c2, d3) {
  a3 = Bg(22, a3, d3, b2);
  a3.elementType = Ia;
  a3.lanes = c2;
  a3.stateNode = { isHidden: false };
  return a3;
}
function Qg(a3, b2, c2) {
  a3 = Bg(6, a3, null, b2);
  a3.lanes = c2;
  return a3;
}
function Sg(a3, b2, c2) {
  b2 = Bg(4, null !== a3.children ? a3.children : [], a3.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a3.containerInfo, pendingChildren: null, implementation: a3.implementation };
  return b2;
}
function al(a3, b2, c2, d3, e2) {
  this.tag = b2;
  this.containerInfo = a3;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d3;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a3, b2, c2, d3, e2, f3, g2, h3, k2) {
  a3 = new al(a3, b2, c2, h3, k2);
  1 === b2 ? (b2 = 1, true === f3 && (b2 |= 8)) : b2 = 0;
  f3 = Bg(3, null, null, b2);
  a3.current = f3;
  f3.stateNode = a3;
  f3.memoizedState = { element: d3, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f3);
  return a3;
}
function cl(a3, b2, c2) {
  var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d3 ? null : "" + d3, children: a3, containerInfo: b2, implementation: c2 };
}
function dl(a3) {
  if (!a3) return Vf;
  a3 = a3._reactInternals;
  a: {
    if (Vb(a3) !== a3 || 1 !== a3.tag) throw Error(p$6(170));
    var b2 = a3;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$6(171));
  }
  if (1 === a3.tag) {
    var c2 = a3.type;
    if (Zf(c2)) return bg(a3, c2, b2);
  }
  return b2;
}
function el(a3, b2, c2, d3, e2, f3, g2, h3, k2) {
  a3 = bl(c2, d3, true, a3, e2, f3, g2, h3, k2);
  a3.context = dl(null);
  c2 = a3.current;
  d3 = R$5();
  e2 = yi$1(c2);
  f3 = mh(d3, e2);
  f3.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f3, e2);
  a3.current.lanes = e2;
  Ac(a3, e2, d3);
  Dk(a3, d3);
  return a3;
}
function fl(a3, b2, c2, d3) {
  var e2 = b2.current, f3 = R$5(), g2 = yi$1(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f3, g2);
  b2.payload = { element: a3 };
  d3 = void 0 === d3 ? null : d3;
  null !== d3 && (b2.callback = d3);
  a3 = nh(e2, b2, g2);
  null !== a3 && (gi$1(a3, e2, g2, f3), oh(a3, e2, g2));
  return g2;
}
function gl(a3) {
  a3 = a3.current;
  if (!a3.child) return null;
  switch (a3.child.tag) {
    case 5:
      return a3.child.stateNode;
    default:
      return a3.child.stateNode;
  }
}
function hl(a3, b2) {
  a3 = a3.memoizedState;
  if (null !== a3 && null !== a3.dehydrated) {
    var c2 = a3.retryLane;
    a3.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a3, b2) {
  hl(a3, b2);
  (a3 = a3.alternate) && hl(a3, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a3) {
  console.error(a3);
};
function ll(a3) {
  this._internalRoot = a3;
}
ml.prototype.render = ll.prototype.render = function(a3) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$6(409));
  fl(a3, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a3 = this._internalRoot;
  if (null !== a3) {
    this._internalRoot = null;
    var b2 = a3.containerInfo;
    Rk(function() {
      fl(null, a3, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a3) {
  this._internalRoot = a3;
}
ml.prototype.unstable_scheduleHydration = function(a3) {
  if (a3) {
    var b2 = Hc();
    a3 = { blockedOn: null, target: a3, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a3);
    0 === c2 && Vc(a3);
  }
};
function nl(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType);
}
function ol(a3) {
  return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType && (8 !== a3.nodeType || " react-mount-point-unstable " !== a3.nodeValue));
}
function pl() {
}
function ql(a3, b2, c2, d3, e2) {
  if (e2) {
    if ("function" === typeof d3) {
      var f3 = d3;
      d3 = function() {
        var a22 = gl(g2);
        f3.call(a22);
      };
    }
    var g2 = el(b2, d3, a3, 0, null, false, false, "", pl);
    a3._reactRootContainer = g2;
    a3[uf] = g2.current;
    sf(8 === a3.nodeType ? a3.parentNode : a3);
    Rk();
    return g2;
  }
  for (; e2 = a3.lastChild; ) a3.removeChild(e2);
  if ("function" === typeof d3) {
    var h3 = d3;
    d3 = function() {
      var a22 = gl(k2);
      h3.call(a22);
    };
  }
  var k2 = bl(a3, 0, false, null, null, false, false, "", pl);
  a3._reactRootContainer = k2;
  a3[uf] = k2.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  Rk(function() {
    fl(b2, k2, c2, d3);
  });
  return k2;
}
function rl(a3, b2, c2, d3, e2) {
  var f3 = c2._reactRootContainer;
  if (f3) {
    var g2 = f3;
    if ("function" === typeof e2) {
      var h3 = e2;
      e2 = function() {
        var a22 = gl(g2);
        h3.call(a22);
      };
    }
    fl(b2, g2, a3, e2);
  } else g2 = ql(c2, b2, a3, e2, d3);
  return gl(g2);
}
Ec = function(a3) {
  switch (a3.tag) {
    case 3:
      var b2 = a3.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B$2()), 0 === (K$3 & 6) && (Gj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b22 = ih(a3, 1);
        if (null !== b22) {
          var c22 = R$5();
          gi$1(b22, a3, 1, c22);
        }
      }), il(a3, 1);
  }
};
Fc = function(a3) {
  if (13 === a3.tag) {
    var b2 = ih(a3, 134217728);
    if (null !== b2) {
      var c2 = R$5();
      gi$1(b2, a3, 134217728, c2);
    }
    il(a3, 134217728);
  }
};
Gc = function(a3) {
  if (13 === a3.tag) {
    var b2 = yi$1(a3), c2 = ih(a3, b2);
    if (null !== c2) {
      var d3 = R$5();
      gi$1(c2, a3, b2, d3);
    }
    il(a3, b2);
  }
};
Hc = function() {
  return C$5;
};
Ic = function(a3, b2) {
  var c2 = C$5;
  try {
    return C$5 = a3, b2();
  } finally {
    C$5 = c2;
  }
};
yb = function(a3, b2, c2) {
  switch (b2) {
    case "input":
      bb(a3, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a3; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d3 = c2[b2];
          if (d3 !== a3 && d3.form === a3.form) {
            var e2 = Db(d3);
            if (!e2) throw Error(p$6(90));
            Wa(d3);
            bb(d3, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a3, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a3, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue$4, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a3) {
  a3 = Zb(a3);
  return null === a3 ? null : a3.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a3) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a3, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$6(200));
  return cl(a3, b2, null, c2);
};
reactDom_production_min.createRoot = function(a3, b2) {
  if (!nl(a3)) throw Error(p$6(299));
  var c2 = false, d3 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d3 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a3, 1, false, null, null, c2, false, d3, e2);
  a3[uf] = b2.current;
  sf(8 === a3.nodeType ? a3.parentNode : a3);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a3) {
  if (null == a3) return null;
  if (1 === a3.nodeType) return a3;
  var b2 = a3._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a3.render) throw Error(p$6(188));
    a3 = Object.keys(a3).join(",");
    throw Error(p$6(268, a3));
  }
  a3 = Zb(b2);
  a3 = null === a3 ? null : a3.stateNode;
  return a3;
};
reactDom_production_min.flushSync = function(a3) {
  return Rk(a3);
};
reactDom_production_min.hydrate = function(a3, b2, c2) {
  if (!ol(b2)) throw Error(p$6(200));
  return rl(null, a3, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a3, b2, c2) {
  if (!nl(a3)) throw Error(p$6(405));
  var d3 = null != c2 && c2.hydratedSources || null, e2 = false, f3 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f3 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a3, 1, null != c2 ? c2 : null, e2, false, f3, g2);
  a3[uf] = b2.current;
  sf(a3);
  if (d3) for (a3 = 0; a3 < d3.length; a3++) c2 = d3[a3], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a3, b2, c2) {
  if (!ol(b2)) throw Error(p$6(200));
  return rl(null, a3, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a3) {
  if (!ol(a3)) throw Error(p$6(40));
  return a3._reactRootContainer ? (Rk(function() {
    rl(null, null, a3, false, function() {
      a3._reactRootContainer = null;
      a3[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a3, b2, c2, d3) {
  if (!ol(c2)) throw Error(p$6(200));
  if (null == a3 || void 0 === a3._reactInternals) throw Error(p$6(38));
  return rl(a3, b2, c2, false, d3);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var hydrateRoot;
var createRoot;
var m$6 = reactDomExports;
{
  createRoot = m$6.createRoot;
  hydrateRoot = m$6.hydrateRoot;
}
const DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
const SDK_VERSION = "8.48.0";
const GLOBAL_OBJ = globalThis;
function getGlobalSingleton(name, creator, obj) {
  const gbl = obj || GLOBAL_OBJ;
  const __SENTRY__ = gbl.__SENTRY__ = gbl.__SENTRY__ || {};
  const versionedCarrier = __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
  return versionedCarrier[name] || (versionedCarrier[name] = creator());
}
const DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
const PREFIX = "Sentry Logger ";
const CONSOLE_LEVELS = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
];
const originalConsoleMethods = {};
function consoleSandbox(callback) {
  if (!("console" in GLOBAL_OBJ)) {
    return callback();
  }
  const console2 = GLOBAL_OBJ.console;
  const wrappedFuncs = {};
  const wrappedLevels = Object.keys(originalConsoleMethods);
  wrappedLevels.forEach((level) => {
    const originalConsoleMethod = originalConsoleMethods[level];
    wrappedFuncs[level] = console2[level];
    console2[level] = originalConsoleMethod;
  });
  try {
    return callback();
  } finally {
    wrappedLevels.forEach((level) => {
      console2[level] = wrappedFuncs[level];
    });
  }
}
function makeLogger() {
  let enabled = false;
  const logger2 = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
    isEnabled: () => enabled
  };
  if (DEBUG_BUILD$2) {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach((name) => {
      logger2[name] = () => void 0;
    });
  }
  return logger2;
}
const logger = getGlobalSingleton("logger", makeLogger);
const STACKTRACE_FRAME_LIMIT = 50;
const UNKNOWN_FUNCTION = "?";
const WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/;
const STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(...parsers) {
  const sortedParsers = parsers.sort((a3, b2) => a3[0] - b2[0]).map((p3) => p3[1]);
  return (stack, skipFirstLines = 0, framesToPop = 0) => {
    const frames = [];
    const lines = stack.split("\n");
    for (let i2 = skipFirstLines; i2 < lines.length; i2++) {
      const line = lines[i2];
      if (line.length > 1024) {
        continue;
      }
      const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, "$1") : line;
      if (cleanedLine.match(/\S*Error: /)) {
        continue;
      }
      for (const parser2 of sortedParsers) {
        const frame = parser2(cleanedLine);
        if (frame) {
          frames.push(frame);
          break;
        }
      }
      if (frames.length >= STACKTRACE_FRAME_LIMIT + framesToPop) {
        break;
      }
    }
    return stripSentryFramesAndReverse(frames.slice(framesToPop));
  };
}
function stackParserFromStackParserOptions(stackParser) {
  if (Array.isArray(stackParser)) {
    return createStackParser(...stackParser);
  }
  return stackParser;
}
function stripSentryFramesAndReverse(stack) {
  if (!stack.length) {
    return [];
  }
  const localStack = Array.from(stack);
  if (/sentryWrapped/.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
  }
  localStack.reverse();
  if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
    localStack.pop();
    if (STRIP_FRAME_REGEXP.test(getLastStackFrame(localStack).function || "")) {
      localStack.pop();
    }
  }
  return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame) => ({
    ...frame,
    filename: frame.filename || getLastStackFrame(localStack).filename,
    function: frame.function || UNKNOWN_FUNCTION
  }));
}
function getLastStackFrame(arr) {
  return arr[arr.length - 1] || {};
}
const defaultFunctionName = "<anonymous>";
function getFunctionName(fn2) {
  try {
    if (!fn2 || typeof fn2 !== "function") {
      return defaultFunctionName;
    }
    return fn2.name || defaultFunctionName;
  } catch (e2) {
    return defaultFunctionName;
  }
}
function getFramesFromEvent(event) {
  const exception = event.exception;
  if (exception) {
    const frames = [];
    try {
      exception.values.forEach((value) => {
        if (value.stacktrace.frames) {
          frames.push(...value.stacktrace.frames);
        }
      });
      return frames;
    } catch (_oO) {
      return void 0;
    }
  }
  return void 0;
}
const handlers = {};
const instrumented = {};
function addHandler(type, handler) {
  handlers[type] = handlers[type] || [];
  handlers[type].push(handler);
}
function maybeInstrument(type, instrumentFn) {
  if (!instrumented[type]) {
    instrumented[type] = true;
    try {
      instrumentFn();
    } catch (e2) {
      DEBUG_BUILD$2 && logger.error(`Error while instrumenting ${type}`, e2);
    }
  }
}
function triggerHandlers(type, data) {
  const typeHandlers = type && handlers[type];
  if (!typeHandlers) {
    return;
  }
  for (const handler of typeHandlers) {
    try {
      handler(data);
    } catch (e2) {
      DEBUG_BUILD$2 && logger.error(
        `Error while triggering instrumentation handler.
Type: ${type}
Name: ${getFunctionName(handler)}
Error:`,
        e2
      );
    }
  }
}
let _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(handler) {
  const type = "error";
  addHandler(type, handler);
  maybeInstrument(type, instrumentError);
}
function instrumentError() {
  _oldOnErrorHandler = GLOBAL_OBJ.onerror;
  GLOBAL_OBJ.onerror = function(msg, url, line, column, error) {
    const handlerData = {
      column,
      error,
      line,
      msg,
      url
    };
    triggerHandlers("error", handlerData);
    if (_oldOnErrorHandler) {
      return _oldOnErrorHandler.apply(this, arguments);
    }
    return false;
  };
  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;
}
let _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(handler) {
  const type = "unhandledrejection";
  addHandler(type, handler);
  maybeInstrument(type, instrumentUnhandledRejection);
}
function instrumentUnhandledRejection() {
  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;
  GLOBAL_OBJ.onunhandledrejection = function(e2) {
    const handlerData = e2;
    triggerHandlers("unhandledrejection", handlerData);
    if (_oldOnUnhandledRejectionHandler) {
      return _oldOnUnhandledRejectionHandler.apply(this, arguments);
    }
    return true;
  };
  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
}
function getMainCarrier() {
  getSentryCarrier(GLOBAL_OBJ);
  return GLOBAL_OBJ;
}
function getSentryCarrier(carrier) {
  const __SENTRY__ = carrier.__SENTRY__ = carrier.__SENTRY__ || {};
  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;
  return __SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {};
}
const objectToString = Object.prototype.toString;
function isError(wat) {
  switch (objectToString.call(wat)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
      return true;
    default:
      return isInstanceOf(wat, Error);
  }
}
function isBuiltin(wat, className) {
  return objectToString.call(wat) === `[object ${className}]`;
}
function isErrorEvent$1(wat) {
  return isBuiltin(wat, "ErrorEvent");
}
function isDOMError(wat) {
  return isBuiltin(wat, "DOMError");
}
function isDOMException(wat) {
  return isBuiltin(wat, "DOMException");
}
function isString$1(wat) {
  return isBuiltin(wat, "String");
}
function isParameterizedString(wat) {
  return typeof wat === "object" && wat !== null && "__sentry_template_string__" in wat && "__sentry_template_values__" in wat;
}
function isPrimitive(wat) {
  return wat === null || isParameterizedString(wat) || typeof wat !== "object" && typeof wat !== "function";
}
function isPlainObject$3(wat) {
  return isBuiltin(wat, "Object");
}
function isEvent(wat) {
  return typeof Event !== "undefined" && isInstanceOf(wat, Event);
}
function isElement$1(wat) {
  return typeof Element !== "undefined" && isInstanceOf(wat, Element);
}
function isRegExp(wat) {
  return isBuiltin(wat, "RegExp");
}
function isThenable(wat) {
  return Boolean(wat && wat.then && typeof wat.then === "function");
}
function isSyntheticEvent(wat) {
  return isPlainObject$3(wat) && "nativeEvent" in wat && "preventDefault" in wat && "stopPropagation" in wat;
}
function isInstanceOf(wat, base) {
  try {
    return wat instanceof base;
  } catch (_e2) {
    return false;
  }
}
function isVueViewModel(wat) {
  return !!(typeof wat === "object" && wat !== null && (wat.__isVue || wat._isVue));
}
const WINDOW$4 = GLOBAL_OBJ;
const DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(elem, options2 = {}) {
  if (!elem) {
    return "<unknown>";
  }
  try {
    let currentElem = elem;
    const MAX_TRAVERSE_HEIGHT = 5;
    const out = [];
    let height = 0;
    let len = 0;
    const separator = " > ";
    const sepLength = separator.length;
    let nextStr;
    const keyAttrs = Array.isArray(options2) ? options2 : options2.keyAttrs;
    const maxStringLength = !Array.isArray(options2) && options2.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
    while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
      nextStr = _htmlElementAsString(currentElem, keyAttrs);
      if (nextStr === "html" || height > 1 && len + out.length * sepLength + nextStr.length >= maxStringLength) {
        break;
      }
      out.push(nextStr);
      len += nextStr.length;
      currentElem = currentElem.parentNode;
    }
    return out.reverse().join(separator);
  } catch (_oO) {
    return "<unknown>";
  }
}
function _htmlElementAsString(el2, keyAttrs) {
  const elem = el2;
  const out = [];
  if (!elem || !elem.tagName) {
    return "";
  }
  if (WINDOW$4.HTMLElement) {
    if (elem instanceof HTMLElement && elem.dataset) {
      if (elem.dataset["sentryComponent"]) {
        return elem.dataset["sentryComponent"];
      }
      if (elem.dataset["sentryElement"]) {
        return elem.dataset["sentryElement"];
      }
    }
  }
  out.push(elem.tagName.toLowerCase());
  const keyAttrPairs = keyAttrs && keyAttrs.length ? keyAttrs.filter((keyAttr) => elem.getAttribute(keyAttr)).map((keyAttr) => [keyAttr, elem.getAttribute(keyAttr)]) : null;
  if (keyAttrPairs && keyAttrPairs.length) {
    keyAttrPairs.forEach((keyAttrPair) => {
      out.push(`[${keyAttrPair[0]}="${keyAttrPair[1]}"]`);
    });
  } else {
    if (elem.id) {
      out.push(`#${elem.id}`);
    }
    const className = elem.className;
    if (className && isString$1(className)) {
      const classes = className.split(/\s+/);
      for (const c2 of classes) {
        out.push(`.${c2}`);
      }
    }
  }
  const allowedAttrs = ["aria-label", "type", "name", "title", "alt"];
  for (const k2 of allowedAttrs) {
    const attr = elem.getAttribute(k2);
    if (attr) {
      out.push(`[${k2}="${attr}"]`);
    }
  }
  return out.join("");
}
function getLocationHref() {
  try {
    return WINDOW$4.document.location.href;
  } catch (oO) {
    return "";
  }
}
function getComponentName(elem) {
  if (!WINDOW$4.HTMLElement) {
    return null;
  }
  let currentElem = elem;
  const MAX_TRAVERSE_HEIGHT = 5;
  for (let i2 = 0; i2 < MAX_TRAVERSE_HEIGHT; i2++) {
    if (!currentElem) {
      return null;
    }
    if (currentElem instanceof HTMLElement) {
      if (currentElem.dataset["sentryComponent"]) {
        return currentElem.dataset["sentryComponent"];
      }
      if (currentElem.dataset["sentryElement"]) {
        return currentElem.dataset["sentryElement"];
      }
    }
    currentElem = currentElem.parentNode;
  }
  return null;
}
function truncate(str, max2 = 0) {
  if (typeof str !== "string" || max2 === 0) {
    return str;
  }
  return str.length <= max2 ? str : `${str.slice(0, max2)}...`;
}
function safeJoin(input, delimiter) {
  if (!Array.isArray(input)) {
    return "";
  }
  const output = [];
  for (let i2 = 0; i2 < input.length; i2++) {
    const value = input[i2];
    try {
      if (isVueViewModel(value)) {
        output.push("[VueViewModel]");
      } else {
        output.push(String(value));
      }
    } catch (e2) {
      output.push("[value cannot be serialized]");
    }
  }
  return output.join(delimiter);
}
function isMatchingPattern(value, pattern, requireExactStringMatch = false) {
  if (!isString$1(value)) {
    return false;
  }
  if (isRegExp(pattern)) {
    return pattern.test(value);
  }
  if (isString$1(pattern)) {
    return requireExactStringMatch ? value === pattern : value.includes(pattern);
  }
  return false;
}
function stringMatchesSomePattern(testString, patterns = [], requireExactStringMatch = false) {
  return patterns.some((pattern) => isMatchingPattern(testString, pattern, requireExactStringMatch));
}
function fill(source, name, replacementFactory) {
  if (!(name in source)) {
    return;
  }
  const original = source[name];
  const wrapped = replacementFactory(original);
  if (typeof wrapped === "function") {
    markFunctionWrapped(wrapped, original);
  }
  try {
    source[name] = wrapped;
  } catch (e2) {
    DEBUG_BUILD$2 && logger.log(`Failed to replace method "${name}" in object`, source);
  }
}
function addNonEnumerableProperty(obj, name, value) {
  try {
    Object.defineProperty(obj, name, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value,
      writable: true,
      configurable: true
    });
  } catch (o_O) {
    DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${name}" to object`, obj);
  }
}
function markFunctionWrapped(wrapped, original) {
  try {
    const proto = original.prototype || {};
    wrapped.prototype = original.prototype = proto;
    addNonEnumerableProperty(wrapped, "__sentry_original__", original);
  } catch (o_O) {
  }
}
function getOriginalFunction(func) {
  return func.__sentry_original__;
}
function convertToPlainObject(value) {
  if (isError(value)) {
    return {
      message: value.message,
      name: value.name,
      stack: value.stack,
      ...getOwnProperties(value)
    };
  } else if (isEvent(value)) {
    const newObj = {
      type: value.type,
      target: serializeEventTarget(value.target),
      currentTarget: serializeEventTarget(value.currentTarget),
      ...getOwnProperties(value)
    };
    if (typeof CustomEvent !== "undefined" && isInstanceOf(value, CustomEvent)) {
      newObj.detail = value.detail;
    }
    return newObj;
  } else {
    return value;
  }
}
function serializeEventTarget(target) {
  try {
    return isElement$1(target) ? htmlTreeAsString(target) : Object.prototype.toString.call(target);
  } catch (_oO) {
    return "<unknown>";
  }
}
function getOwnProperties(obj) {
  if (typeof obj === "object" && obj !== null) {
    const extractedProps = {};
    for (const property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        extractedProps[property] = obj[property];
      }
    }
    return extractedProps;
  } else {
    return {};
  }
}
function extractExceptionKeysForMessage(exception, maxLength = 40) {
  const keys = Object.keys(convertToPlainObject(exception));
  keys.sort();
  const firstKey = keys[0];
  if (!firstKey) {
    return "[object has no keys]";
  }
  if (firstKey.length >= maxLength) {
    return truncate(firstKey, maxLength);
  }
  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {
    const serialized = keys.slice(0, includedKeys).join(", ");
    if (serialized.length > maxLength) {
      continue;
    }
    if (includedKeys === keys.length) {
      return serialized;
    }
    return truncate(serialized, maxLength);
  }
  return "";
}
function dropUndefinedKeys(inputValue) {
  const memoizationMap = /* @__PURE__ */ new Map();
  return _dropUndefinedKeys(inputValue, memoizationMap);
}
function _dropUndefinedKeys(inputValue, memoizationMap) {
  if (isPojo(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = {};
    memoizationMap.set(inputValue, returnValue);
    for (const key of Object.getOwnPropertyNames(inputValue)) {
      if (typeof inputValue[key] !== "undefined") {
        returnValue[key] = _dropUndefinedKeys(inputValue[key], memoizationMap);
      }
    }
    return returnValue;
  }
  if (Array.isArray(inputValue)) {
    const memoVal = memoizationMap.get(inputValue);
    if (memoVal !== void 0) {
      return memoVal;
    }
    const returnValue = [];
    memoizationMap.set(inputValue, returnValue);
    inputValue.forEach((item) => {
      returnValue.push(_dropUndefinedKeys(item, memoizationMap));
    });
    return returnValue;
  }
  return inputValue;
}
function isPojo(input) {
  if (!isPlainObject$3(input)) {
    return false;
  }
  try {
    const name = Object.getPrototypeOf(input).constructor.name;
    return !name || name === "Object";
  } catch (e2) {
    return true;
  }
}
const ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
  return Date.now() / ONE_SECOND_IN_MS;
}
function createUnixTimestampInSecondsFunc() {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return dateTimestampInSeconds;
  }
  const approxStartingTimeOrigin = Date.now() - performance2.now();
  const timeOrigin = performance2.timeOrigin == void 0 ? approxStartingTimeOrigin : performance2.timeOrigin;
  return () => {
    return (timeOrigin + performance2.now()) / ONE_SECOND_IN_MS;
  };
}
const timestampInSeconds = createUnixTimestampInSecondsFunc();
(() => {
  const { performance: performance2 } = GLOBAL_OBJ;
  if (!performance2 || !performance2.now) {
    return void 0;
  }
  const threshold = 3600 * 1e3;
  const performanceNow = performance2.now();
  const dateNow = Date.now();
  const timeOriginDelta = performance2.timeOrigin ? Math.abs(performance2.timeOrigin + performanceNow - dateNow) : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;
  const navigationStart = performance2.timing && performance2.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === "number";
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;
  if (timeOriginIsReliable || navigationStartIsReliable) {
    if (timeOriginDelta <= navigationStartDelta) {
      return performance2.timeOrigin;
    } else {
      return navigationStart;
    }
  }
  return dateNow;
})();
function uuid4() {
  const gbl = GLOBAL_OBJ;
  const crypto2 = gbl.crypto || gbl.msCrypto;
  let getRandomByte = () => Math.random() * 16;
  try {
    if (crypto2 && crypto2.randomUUID) {
      return crypto2.randomUUID().replace(/-/g, "");
    }
    if (crypto2 && crypto2.getRandomValues) {
      getRandomByte = () => {
        const typedArray = new Uint8Array(1);
        crypto2.getRandomValues(typedArray);
        return typedArray[0];
      };
    }
  } catch (_2) {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (c2) => (
      // eslint-disable-next-line no-bitwise
      (c2 ^ (getRandomByte() & 15) >> c2 / 4).toString(16)
    )
  );
}
function getFirstException(event) {
  return event.exception && event.exception.values ? event.exception.values[0] : void 0;
}
function getEventDescription(event) {
  const { message, event_id: eventId } = event;
  if (message) {
    return message;
  }
  const firstException = getFirstException(event);
  if (firstException) {
    if (firstException.type && firstException.value) {
      return `${firstException.type}: ${firstException.value}`;
    }
    return firstException.type || firstException.value || eventId || "<unknown>";
  }
  return eventId || "<unknown>";
}
function addExceptionTypeValue(event, value, type) {
  const exception = event.exception = event.exception || {};
  const values = exception.values = exception.values || [];
  const firstException = values[0] = values[0] || {};
  if (!firstException.value) {
    firstException.value = value || "";
  }
  if (!firstException.type) {
    firstException.type = "Error";
  }
}
function addExceptionMechanism(event, newMechanism) {
  const firstException = getFirstException(event);
  if (!firstException) {
    return;
  }
  const defaultMechanism = { type: "generic", handled: true };
  const currentMechanism = firstException.mechanism;
  firstException.mechanism = { ...defaultMechanism, ...currentMechanism, ...newMechanism };
  if (newMechanism && "data" in newMechanism) {
    const mergedData = { ...currentMechanism && currentMechanism.data, ...newMechanism.data };
    firstException.mechanism.data = mergedData;
  }
}
function checkOrSetAlreadyCaught(exception) {
  if (isAlreadyCaptured(exception)) {
    return true;
  }
  try {
    addNonEnumerableProperty(exception, "__sentry_captured__", true);
  } catch (err) {
  }
  return false;
}
function isAlreadyCaptured(exception) {
  try {
    return exception.__sentry_captured__;
  } catch (e2) {
  }
}
var States;
(function(States2) {
  const PENDING = 0;
  States2[States2["PENDING"] = PENDING] = "PENDING";
  const RESOLVED = 1;
  States2[States2["RESOLVED"] = RESOLVED] = "RESOLVED";
  const REJECTED = 2;
  States2[States2["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));
function resolvedSyncPromise(value) {
  return new SyncPromise((resolve) => {
    resolve(value);
  });
}
function rejectedSyncPromise(reason) {
  return new SyncPromise((_2, reject) => {
    reject(reason);
  });
}
class SyncPromise {
  constructor(executor) {
    SyncPromise.prototype.__init.call(this);
    SyncPromise.prototype.__init2.call(this);
    SyncPromise.prototype.__init3.call(this);
    SyncPromise.prototype.__init4.call(this);
    this._state = States.PENDING;
    this._handlers = [];
    try {
      executor(this._resolve, this._reject);
    } catch (e2) {
      this._reject(e2);
    }
  }
  /** JSDoc */
  then(onfulfilled, onrejected) {
    return new SyncPromise((resolve, reject) => {
      this._handlers.push([
        false,
        (result) => {
          if (!onfulfilled) {
            resolve(result);
          } else {
            try {
              resolve(onfulfilled(result));
            } catch (e2) {
              reject(e2);
            }
          }
        },
        (reason) => {
          if (!onrejected) {
            reject(reason);
          } else {
            try {
              resolve(onrejected(reason));
            } catch (e2) {
              reject(e2);
            }
          }
        }
      ]);
      this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(onrejected) {
    return this.then((val) => val, onrejected);
  }
  /** JSDoc */
  finally(onfinally) {
    return new SyncPromise((resolve, reject) => {
      let val;
      let isRejected;
      return this.then(
        (value) => {
          isRejected = false;
          val = value;
          if (onfinally) {
            onfinally();
          }
        },
        (reason) => {
          isRejected = true;
          val = reason;
          if (onfinally) {
            onfinally();
          }
        }
      ).then(() => {
        if (isRejected) {
          reject(val);
          return;
        }
        resolve(val);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (value) => {
      this._setResult(States.RESOLVED, value);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (reason) => {
      this._setResult(States.REJECTED, reason);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (state, value) => {
      if (this._state !== States.PENDING) {
        return;
      }
      if (isThenable(value)) {
        void value.then(this._resolve, this._reject);
        return;
      }
      this._state = state;
      this._value = value;
      this._executeHandlers();
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === States.PENDING) {
        return;
      }
      const cachedHandlers = this._handlers.slice();
      this._handlers = [];
      cachedHandlers.forEach((handler) => {
        if (handler[0]) {
          return;
        }
        if (this._state === States.RESOLVED) {
          handler[1](this._value);
        }
        if (this._state === States.REJECTED) {
          handler[2](this._value);
        }
        handler[0] = true;
      });
    };
  }
}
function makeSession(context2) {
  const startingTime = timestampInSeconds();
  const session = {
    sid: uuid4(),
    init: true,
    timestamp: startingTime,
    started: startingTime,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: false,
    toJSON: () => sessionToJSON(session)
  };
  if (context2) {
    updateSession(session, context2);
  }
  return session;
}
function updateSession(session, context2 = {}) {
  if (context2.user) {
    if (!session.ipAddress && context2.user.ip_address) {
      session.ipAddress = context2.user.ip_address;
    }
    if (!session.did && !context2.did) {
      session.did = context2.user.id || context2.user.email || context2.user.username;
    }
  }
  session.timestamp = context2.timestamp || timestampInSeconds();
  if (context2.abnormal_mechanism) {
    session.abnormal_mechanism = context2.abnormal_mechanism;
  }
  if (context2.ignoreDuration) {
    session.ignoreDuration = context2.ignoreDuration;
  }
  if (context2.sid) {
    session.sid = context2.sid.length === 32 ? context2.sid : uuid4();
  }
  if (context2.init !== void 0) {
    session.init = context2.init;
  }
  if (!session.did && context2.did) {
    session.did = `${context2.did}`;
  }
  if (typeof context2.started === "number") {
    session.started = context2.started;
  }
  if (session.ignoreDuration) {
    session.duration = void 0;
  } else if (typeof context2.duration === "number") {
    session.duration = context2.duration;
  } else {
    const duration = session.timestamp - session.started;
    session.duration = duration >= 0 ? duration : 0;
  }
  if (context2.release) {
    session.release = context2.release;
  }
  if (context2.environment) {
    session.environment = context2.environment;
  }
  if (!session.ipAddress && context2.ipAddress) {
    session.ipAddress = context2.ipAddress;
  }
  if (!session.userAgent && context2.userAgent) {
    session.userAgent = context2.userAgent;
  }
  if (typeof context2.errors === "number") {
    session.errors = context2.errors;
  }
  if (context2.status) {
    session.status = context2.status;
  }
}
function closeSession(session, status) {
  let context2 = {};
  if (session.status === "ok") {
    context2 = { status: "exited" };
  }
  updateSession(session, context2);
}
function sessionToJSON(session) {
  return dropUndefinedKeys({
    sid: `${session.sid}`,
    init: session.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(session.started * 1e3).toISOString(),
    timestamp: new Date(session.timestamp * 1e3).toISOString(),
    status: session.status,
    errors: session.errors,
    did: typeof session.did === "number" || typeof session.did === "string" ? `${session.did}` : void 0,
    duration: session.duration,
    abnormal_mechanism: session.abnormal_mechanism,
    attrs: {
      release: session.release,
      environment: session.environment,
      ip_address: session.ipAddress,
      user_agent: session.userAgent
    }
  });
}
function generateTraceId() {
  return uuid4();
}
function generateSpanId() {
  return uuid4().substring(16);
}
function merge(initialObj, mergeObj, levels = 2) {
  if (!mergeObj || typeof mergeObj !== "object" || levels <= 0) {
    return mergeObj;
  }
  if (initialObj && mergeObj && Object.keys(mergeObj).length === 0) {
    return initialObj;
  }
  const output = { ...initialObj };
  for (const key in mergeObj) {
    if (Object.prototype.hasOwnProperty.call(mergeObj, key)) {
      output[key] = merge(output[key], mergeObj[key], levels - 1);
    }
  }
  return output;
}
const SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(scope, span) {
  if (span) {
    addNonEnumerableProperty(scope, SCOPE_SPAN_FIELD, span);
  } else {
    delete scope[SCOPE_SPAN_FIELD];
  }
}
function _getSpanForScope(scope) {
  return scope[SCOPE_SPAN_FIELD];
}
const DEFAULT_MAX_BREADCRUMBS = 100;
class ScopeClass {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  // eslint-disable-next-line deprecation/deprecation
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = false;
    this._scopeListeners = [];
    this._eventProcessors = [];
    this._breadcrumbs = [];
    this._attachments = [];
    this._user = {};
    this._tags = {};
    this._extra = {};
    this._contexts = {};
    this._sdkProcessingMetadata = {};
    this._propagationContext = {
      traceId: generateTraceId(),
      spanId: generateSpanId()
    };
  }
  /**
   * @inheritDoc
   */
  clone() {
    const newScope = new ScopeClass();
    newScope._breadcrumbs = [...this._breadcrumbs];
    newScope._tags = { ...this._tags };
    newScope._extra = { ...this._extra };
    newScope._contexts = { ...this._contexts };
    if (this._contexts.flags) {
      newScope._contexts.flags = {
        values: [...this._contexts.flags.values]
      };
    }
    newScope._user = this._user;
    newScope._level = this._level;
    newScope._session = this._session;
    newScope._transactionName = this._transactionName;
    newScope._fingerprint = this._fingerprint;
    newScope._eventProcessors = [...this._eventProcessors];
    newScope._requestSession = this._requestSession;
    newScope._attachments = [...this._attachments];
    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };
    newScope._propagationContext = { ...this._propagationContext };
    newScope._client = this._client;
    newScope._lastEventId = this._lastEventId;
    _setSpanForScope(newScope, _getSpanForScope(this));
    return newScope;
  }
  /**
   * @inheritDoc
   */
  setClient(client) {
    this._client = client;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(lastEventId) {
    this._lastEventId = lastEventId;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(callback) {
    this._scopeListeners.push(callback);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(callback) {
    this._eventProcessors.push(callback);
    return this;
  }
  /**
   * @inheritDoc
   */
  setUser(user) {
    this._user = user || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    };
    if (this._session) {
      updateSession(this._session, { user });
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line deprecation/deprecation
  setRequestSession(requestSession) {
    this._requestSession = requestSession;
    return this;
  }
  /**
   * @inheritDoc
   */
  setTags(tags) {
    this._tags = {
      ...this._tags,
      ...tags
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setTag(key, value) {
    this._tags = { ...this._tags, [key]: value };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtras(extras2) {
    this._extra = {
      ...this._extra,
      ...extras2
    };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setExtra(key, extra) {
    this._extra = { ...this._extra, [key]: extra };
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(fingerprint) {
    this._fingerprint = fingerprint;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setLevel(level) {
    this._level = level;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(name) {
    this._transactionName = name;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setContext(key, context2) {
    if (context2 === null) {
      delete this._contexts[key];
    } else {
      this._contexts[key] = context2;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  setSession(session) {
    if (!session) {
      delete this._session;
    } else {
      this._session = session;
    }
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(captureContext) {
    if (!captureContext) {
      return this;
    }
    const scopeToMerge = typeof captureContext === "function" ? captureContext(this) : captureContext;
    const [scopeInstance, requestSession] = scopeToMerge instanceof Scope ? (
      // eslint-disable-next-line deprecation/deprecation
      [scopeToMerge.getScopeData(), scopeToMerge.getRequestSession()]
    ) : isPlainObject$3(scopeToMerge) ? [captureContext, captureContext.requestSession] : [];
    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};
    this._tags = { ...this._tags, ...tags };
    this._extra = { ...this._extra, ...extra };
    this._contexts = { ...this._contexts, ...contexts };
    if (user && Object.keys(user).length) {
      this._user = user;
    }
    if (level) {
      this._level = level;
    }
    if (fingerprint.length) {
      this._fingerprint = fingerprint;
    }
    if (propagationContext) {
      this._propagationContext = propagationContext;
    }
    if (requestSession) {
      this._requestSession = requestSession;
    }
    return this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    this._breadcrumbs = [];
    this._tags = {};
    this._extra = {};
    this._user = {};
    this._contexts = {};
    this._level = void 0;
    this._transactionName = void 0;
    this._fingerprint = void 0;
    this._requestSession = void 0;
    this._session = void 0;
    _setSpanForScope(this, void 0);
    this._attachments = [];
    this.setPropagationContext({ traceId: generateTraceId() });
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(breadcrumb, maxBreadcrumbs) {
    const maxCrumbs = typeof maxBreadcrumbs === "number" ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;
    if (maxCrumbs <= 0) {
      return this;
    }
    const mergedBreadcrumb = {
      timestamp: dateTimestampInSeconds(),
      ...breadcrumb
    };
    const breadcrumbs = this._breadcrumbs;
    breadcrumbs.push(mergedBreadcrumb);
    this._breadcrumbs = breadcrumbs.length > maxCrumbs ? breadcrumbs.slice(-maxCrumbs) : breadcrumbs;
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    this._breadcrumbs = [];
    this._notifyScopeListeners();
    return this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(attachment) {
    this._attachments.push(attachment);
    return this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    this._attachments = [];
    return this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: _getSpanForScope(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(newData) {
    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);
    return this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(context2) {
    this._propagationContext = {
      // eslint-disable-next-line deprecation/deprecation
      spanId: generateSpanId(),
      ...context2
    };
    return this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(exception, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture exception!");
      return eventId;
    }
    const syntheticException = new Error("Sentry syntheticException");
    this._client.captureException(
      exception,
      {
        originalException: exception,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureMessage(message, level, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture message!");
      return eventId;
    }
    const syntheticException = new Error(message);
    this._client.captureMessage(
      message,
      level,
      {
        originalException: message,
        syntheticException,
        ...hint,
        event_id: eventId
      },
      this
    );
    return eventId;
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint) {
    const eventId = hint && hint.event_id ? hint.event_id : uuid4();
    if (!this._client) {
      logger.warn("No client configured on scope - will not capture event!");
      return eventId;
    }
    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);
    return eventId;
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    if (!this._notifyingListeners) {
      this._notifyingListeners = true;
      this._scopeListeners.forEach((callback) => {
        callback(this);
      });
      this._notifyingListeners = false;
    }
  }
}
const Scope = ScopeClass;
function getDefaultCurrentScope() {
  return getGlobalSingleton("defaultCurrentScope", () => new Scope());
}
function getDefaultIsolationScope() {
  return getGlobalSingleton("defaultIsolationScope", () => new Scope());
}
class AsyncContextStack {
  constructor(scope, isolationScope) {
    let assignedScope;
    if (!scope) {
      assignedScope = new Scope();
    } else {
      assignedScope = scope;
    }
    let assignedIsolationScope;
    if (!isolationScope) {
      assignedIsolationScope = new Scope();
    } else {
      assignedIsolationScope = isolationScope;
    }
    this._stack = [{ scope: assignedScope }];
    this._isolationScope = assignedIsolationScope;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(callback) {
    const scope = this._pushScope();
    let maybePromiseResult;
    try {
      maybePromiseResult = callback(scope);
    } catch (e2) {
      this._popScope();
      throw e2;
    }
    if (isThenable(maybePromiseResult)) {
      return maybePromiseResult.then(
        (res) => {
          this._popScope();
          return res;
        },
        (e2) => {
          this._popScope();
          throw e2;
        }
      );
    }
    this._popScope();
    return maybePromiseResult;
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const scope = this.getScope().clone();
    this._stack.push({
      client: this.getClient(),
      scope
    });
    return scope;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    if (this._stack.length <= 1) return false;
    return !!this._stack.pop();
  }
}
function getAsyncContextStack() {
  const registry = getMainCarrier();
  const sentry = getSentryCarrier(registry);
  return sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope());
}
function withScope$1(callback) {
  return getAsyncContextStack().withScope(callback);
}
function withSetScope(scope, callback) {
  const stack = getAsyncContextStack();
  return stack.withScope(() => {
    stack.getStackTop().scope = scope;
    return callback(scope);
  });
}
function withIsolationScope(callback) {
  return getAsyncContextStack().withScope(() => {
    return callback(getAsyncContextStack().getIsolationScope());
  });
}
function getStackAsyncContextStrategy() {
  return {
    withIsolationScope,
    withScope: withScope$1,
    withSetScope,
    withSetIsolationScope: (_isolationScope, callback) => {
      return withIsolationScope(callback);
    },
    getCurrentScope: () => getAsyncContextStack().getScope(),
    getIsolationScope: () => getAsyncContextStack().getIsolationScope()
  };
}
function getAsyncContextStrategy(carrier) {
  const sentry = getSentryCarrier(carrier);
  if (sentry.acs) {
    return sentry.acs;
  }
  return getStackAsyncContextStrategy();
}
function getCurrentScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getCurrentScope();
}
function getIsolationScope() {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  return acs.getIsolationScope();
}
function getGlobalScope() {
  return getGlobalSingleton("globalScope", () => new Scope());
}
function withScope(...rest) {
  const carrier = getMainCarrier();
  const acs = getAsyncContextStrategy(carrier);
  if (rest.length === 2) {
    const [scope, callback] = rest;
    if (!scope) {
      return acs.withScope(callback);
    }
    return acs.withSetScope(scope, callback);
  }
  return acs.withScope(rest[0]);
}
function getClient() {
  return getCurrentScope().getClient();
}
function getTraceContextFromScope(scope) {
  const propagationContext = scope.getPropagationContext();
  const { traceId, spanId, parentSpanId } = propagationContext;
  const traceContext = dropUndefinedKeys({
    trace_id: traceId,
    span_id: spanId,
    parent_span_id: parentSpanId
  });
  return traceContext;
}
const METRICS_SPAN_FIELD = "_sentryMetrics";
function getMetricSummaryJsonForSpan(span) {
  const storage = span[METRICS_SPAN_FIELD];
  if (!storage) {
    return void 0;
  }
  const output = {};
  for (const [, [exportKey, summary]] of storage) {
    const arr = output[exportKey] || (output[exportKey] = []);
    arr.push(dropUndefinedKeys(summary));
  }
  return output;
}
const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source";
const SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate";
const SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op";
const SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin";
const SPAN_STATUS_UNSET = 0;
const SPAN_STATUS_OK = 1;
const SENTRY_BAGGAGE_KEY_PREFIX = "sentry-";
const SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
function baggageHeaderToDynamicSamplingContext(baggageHeader) {
  const baggageObject = parseBaggageHeader(baggageHeader);
  if (!baggageObject) {
    return void 0;
  }
  const dynamicSamplingContext = Object.entries(baggageObject).reduce((acc, [key, value]) => {
    if (key.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
      const nonPrefixedKey = key.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
      acc[nonPrefixedKey] = value;
    }
    return acc;
  }, {});
  if (Object.keys(dynamicSamplingContext).length > 0) {
    return dynamicSamplingContext;
  } else {
    return void 0;
  }
}
function parseBaggageHeader(baggageHeader) {
  if (!baggageHeader || !isString$1(baggageHeader) && !Array.isArray(baggageHeader)) {
    return void 0;
  }
  if (Array.isArray(baggageHeader)) {
    return baggageHeader.reduce((acc, curr) => {
      const currBaggageObject = baggageHeaderToObject(curr);
      Object.entries(currBaggageObject).forEach(([key, value]) => {
        acc[key] = value;
      });
      return acc;
    }, {});
  }
  return baggageHeaderToObject(baggageHeader);
}
function baggageHeaderToObject(baggageHeader) {
  return baggageHeader.split(",").map((baggageEntry) => baggageEntry.split("=").map((keyOrValue) => decodeURIComponent(keyOrValue.trim()))).reduce((acc, [key, value]) => {
    if (key && value) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
const TRACE_FLAG_SAMPLED = 1;
let hasShownSpanDropWarning = false;
function spanToTraceContext(span) {
  const { spanId, traceId: trace_id, isRemote } = span.spanContext();
  const parent_span_id = isRemote ? spanId : spanToJSON(span).parent_span_id;
  const span_id = isRemote ? generateSpanId() : spanId;
  return dropUndefinedKeys({
    parent_span_id,
    span_id,
    trace_id
  });
}
function spanTimeInputToSeconds(input) {
  if (typeof input === "number") {
    return ensureTimestampInSeconds(input);
  }
  if (Array.isArray(input)) {
    return input[0] + input[1] / 1e9;
  }
  if (input instanceof Date) {
    return ensureTimestampInSeconds(input.getTime());
  }
  return timestampInSeconds();
}
function ensureTimestampInSeconds(timestamp) {
  const isMs = timestamp > 9999999999;
  return isMs ? timestamp / 1e3 : timestamp;
}
function spanToJSON(span) {
  if (spanIsSentrySpan(span)) {
    return span.getSpanJSON();
  }
  try {
    const { spanId: span_id, traceId: trace_id } = span.spanContext();
    if (spanIsOpenTelemetrySdkTraceBaseSpan(span)) {
      const { attributes, startTime, name, endTime, parentSpanId, status } = span;
      return dropUndefinedKeys({
        span_id,
        trace_id,
        data: attributes,
        description: name,
        parent_span_id: parentSpanId,
        start_timestamp: spanTimeInputToSeconds(startTime),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: spanTimeInputToSeconds(endTime) || void 0,
        status: getStatusMessage(status),
        op: attributes[SEMANTIC_ATTRIBUTE_SENTRY_OP],
        origin: attributes[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
        _metrics_summary: getMetricSummaryJsonForSpan(span)
      });
    }
    return {
      span_id,
      trace_id
    };
  } catch (e2) {
    return {};
  }
}
function spanIsOpenTelemetrySdkTraceBaseSpan(span) {
  const castSpan = span;
  return !!castSpan.attributes && !!castSpan.startTime && !!castSpan.name && !!castSpan.endTime && !!castSpan.status;
}
function spanIsSentrySpan(span) {
  return typeof span.getSpanJSON === "function";
}
function spanIsSampled(span) {
  const { traceFlags } = span.spanContext();
  return traceFlags === TRACE_FLAG_SAMPLED;
}
function getStatusMessage(status) {
  if (!status || status.code === SPAN_STATUS_UNSET) {
    return void 0;
  }
  if (status.code === SPAN_STATUS_OK) {
    return "ok";
  }
  return status.message || "unknown_error";
}
const ROOT_SPAN_FIELD = "_sentryRootSpan";
function getRootSpan(span) {
  return span[ROOT_SPAN_FIELD] || span;
}
function showSpanDropWarning() {
  if (!hasShownSpanDropWarning) {
    consoleSandbox(() => {
      console.warn(
        "[Sentry] Deprecation warning: Returning null from `beforeSendSpan` will be disallowed from SDK version 9.0.0 onwards. The callback will only support mutating spans. To drop certain spans, configure the respective integrations directly."
      );
    });
    hasShownSpanDropWarning = true;
  }
}
function hasTracingEnabled(maybeOptions) {
  if (typeof __SENTRY_TRACING__ === "boolean" && !__SENTRY_TRACING__) {
    return false;
  }
  const client = getClient();
  const options2 = client && client.getOptions();
  return !!options2 && (options2.enableTracing || "tracesSampleRate" in options2 || "tracesSampler" in options2);
}
const DEFAULT_ENVIRONMENT = "production";
const FROZEN_DSC_FIELD = "_frozenDsc";
function getDynamicSamplingContextFromClient(trace_id, client) {
  const options2 = client.getOptions();
  const { publicKey: public_key } = client.getDsn() || {};
  const dsc = dropUndefinedKeys({
    environment: options2.environment || DEFAULT_ENVIRONMENT,
    release: options2.release,
    public_key,
    trace_id
  });
  client.emit("createDsc", dsc);
  return dsc;
}
function getDynamicSamplingContextFromScope(client, scope) {
  const propagationContext = scope.getPropagationContext();
  return propagationContext.dsc || getDynamicSamplingContextFromClient(propagationContext.traceId, client);
}
function getDynamicSamplingContextFromSpan(span) {
  const client = getClient();
  if (!client) {
    return {};
  }
  const rootSpan = getRootSpan(span);
  const frozenDsc = rootSpan[FROZEN_DSC_FIELD];
  if (frozenDsc) {
    return frozenDsc;
  }
  const traceState = rootSpan.spanContext().traceState;
  const traceStateDsc = traceState && traceState.get("sentry.dsc");
  const dscOnTraceState = traceStateDsc && baggageHeaderToDynamicSamplingContext(traceStateDsc);
  if (dscOnTraceState) {
    return dscOnTraceState;
  }
  const dsc = getDynamicSamplingContextFromClient(span.spanContext().traceId, client);
  const jsonSpan = spanToJSON(rootSpan);
  const attributes = jsonSpan.data || {};
  const maybeSampleRate = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
  if (maybeSampleRate != null) {
    dsc.sample_rate = `${maybeSampleRate}`;
  }
  const source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];
  const name = jsonSpan.description;
  if (source !== "url" && name) {
    dsc.transaction = name;
  }
  if (hasTracingEnabled()) {
    dsc.sampled = String(spanIsSampled(rootSpan));
  }
  client.emit("createDsc", dsc, rootSpan);
  return dsc;
}
function parseSampleRate(sampleRate) {
  if (typeof sampleRate === "boolean") {
    return Number(sampleRate);
  }
  const rate = typeof sampleRate === "string" ? parseFloat(sampleRate) : sampleRate;
  if (typeof rate !== "number" || isNaN(rate) || rate < 0 || rate > 1) {
    DEBUG_BUILD$3 && logger.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        sampleRate
      )} of type ${JSON.stringify(typeof sampleRate)}.`
    );
    return void 0;
  }
  return rate;
}
const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(protocol) {
  return protocol === "http" || protocol === "https";
}
function dsnToString(dsn, withPassword = false) {
  const { host: host2, path, pass, port, projectId, protocol, publicKey } = dsn;
  return `${protocol}://${publicKey}${withPassword && pass ? `:${pass}` : ""}@${host2}${port ? `:${port}` : ""}/${path ? `${path}/` : path}${projectId}`;
}
function dsnFromString(str) {
  const match = DSN_REGEX.exec(str);
  if (!match) {
    consoleSandbox(() => {
      console.error(`Invalid Sentry Dsn: ${str}`);
    });
    return void 0;
  }
  const [protocol, publicKey, pass = "", host2 = "", port = "", lastPath = ""] = match.slice(1);
  let path = "";
  let projectId = lastPath;
  const split2 = projectId.split("/");
  if (split2.length > 1) {
    path = split2.slice(0, -1).join("/");
    projectId = split2.pop();
  }
  if (projectId) {
    const projectMatch = projectId.match(/^\d+/);
    if (projectMatch) {
      projectId = projectMatch[0];
    }
  }
  return dsnFromComponents({ host: host2, pass, path, projectId, port, protocol, publicKey });
}
function dsnFromComponents(components) {
  return {
    protocol: components.protocol,
    publicKey: components.publicKey || "",
    pass: components.pass || "",
    host: components.host,
    port: components.port || "",
    path: components.path || "",
    projectId: components.projectId
  };
}
function validateDsn(dsn) {
  if (!DEBUG_BUILD$2) {
    return true;
  }
  const { port, projectId, protocol } = dsn;
  const requiredComponents = ["protocol", "publicKey", "host", "projectId"];
  const hasMissingRequiredComponent = requiredComponents.find((component) => {
    if (!dsn[component]) {
      logger.error(`Invalid Sentry Dsn: ${component} missing`);
      return true;
    }
    return false;
  });
  if (hasMissingRequiredComponent) {
    return false;
  }
  if (!projectId.match(/^\d+$/)) {
    logger.error(`Invalid Sentry Dsn: Invalid projectId ${projectId}`);
    return false;
  }
  if (!isValidProtocol(protocol)) {
    logger.error(`Invalid Sentry Dsn: Invalid protocol ${protocol}`);
    return false;
  }
  if (port && isNaN(parseInt(port, 10))) {
    logger.error(`Invalid Sentry Dsn: Invalid port ${port}`);
    return false;
  }
  return true;
}
function makeDsn(from2) {
  const components = typeof from2 === "string" ? dsnFromString(from2) : dsnFromComponents(from2);
  if (!components || !validateDsn(components)) {
    return void 0;
  }
  return components;
}
function memoBuilder() {
  const hasWeakSet = typeof WeakSet === "function";
  const inner2 = hasWeakSet ? /* @__PURE__ */ new WeakSet() : [];
  function memoize(obj) {
    if (hasWeakSet) {
      if (inner2.has(obj)) {
        return true;
      }
      inner2.add(obj);
      return false;
    }
    for (let i2 = 0; i2 < inner2.length; i2++) {
      const value = inner2[i2];
      if (value === obj) {
        return true;
      }
    }
    inner2.push(obj);
    return false;
  }
  function unmemoize(obj) {
    if (hasWeakSet) {
      inner2.delete(obj);
    } else {
      for (let i2 = 0; i2 < inner2.length; i2++) {
        if (inner2[i2] === obj) {
          inner2.splice(i2, 1);
          break;
        }
      }
    }
  }
  return [memoize, unmemoize];
}
function normalize$2(input, depth = 100, maxProperties = Infinity) {
  try {
    return visit$2("", input, depth, maxProperties);
  } catch (err) {
    return { ERROR: `**non-serializable** (${err})` };
  }
}
function normalizeToSize(object, depth = 3, maxSize = 100 * 1024) {
  const normalized = normalize$2(object, depth);
  if (jsonSize(normalized) > maxSize) {
    return normalizeToSize(object, depth - 1, maxSize);
  }
  return normalized;
}
function visit$2(key, value, depth = Infinity, maxProperties = Infinity, memo = memoBuilder()) {
  const [memoize, unmemoize] = memo;
  if (value == null || // this matches null and undefined -> eqeq not eqeqeq
  ["boolean", "string"].includes(typeof value) || typeof value === "number" && Number.isFinite(value)) {
    return value;
  }
  const stringified = stringifyValue$2(key, value);
  if (!stringified.startsWith("[object ")) {
    return stringified;
  }
  if (value["__sentry_skip_normalization__"]) {
    return value;
  }
  const remainingDepth = typeof value["__sentry_override_normalization_depth__"] === "number" ? value["__sentry_override_normalization_depth__"] : depth;
  if (remainingDepth === 0) {
    return stringified.replace("object ", "");
  }
  if (memoize(value)) {
    return "[Circular ~]";
  }
  const valueWithToJSON = value;
  if (valueWithToJSON && typeof valueWithToJSON.toJSON === "function") {
    try {
      const jsonValue = valueWithToJSON.toJSON();
      return visit$2("", jsonValue, remainingDepth - 1, maxProperties, memo);
    } catch (err) {
    }
  }
  const normalized = Array.isArray(value) ? [] : {};
  let numAdded = 0;
  const visitable = convertToPlainObject(value);
  for (const visitKey in visitable) {
    if (!Object.prototype.hasOwnProperty.call(visitable, visitKey)) {
      continue;
    }
    if (numAdded >= maxProperties) {
      normalized[visitKey] = "[MaxProperties ~]";
      break;
    }
    const visitValue = visitable[visitKey];
    normalized[visitKey] = visit$2(visitKey, visitValue, remainingDepth - 1, maxProperties, memo);
    numAdded++;
  }
  unmemoize(value);
  return normalized;
}
function stringifyValue$2(key, value) {
  try {
    if (key === "domain" && value && typeof value === "object" && value._events) {
      return "[Domain]";
    }
    if (key === "domainEmitter") {
      return "[DomainEmitter]";
    }
    if (typeof global !== "undefined" && value === global) {
      return "[Global]";
    }
    if (typeof window !== "undefined" && value === window) {
      return "[Window]";
    }
    if (typeof document !== "undefined" && value === document) {
      return "[Document]";
    }
    if (isVueViewModel(value)) {
      return "[VueViewModel]";
    }
    if (isSyntheticEvent(value)) {
      return "[SyntheticEvent]";
    }
    if (typeof value === "number" && !Number.isFinite(value)) {
      return `[${value}]`;
    }
    if (typeof value === "function") {
      return `[Function: ${getFunctionName(value)}]`;
    }
    if (typeof value === "symbol") {
      return `[${String(value)}]`;
    }
    if (typeof value === "bigint") {
      return `[BigInt: ${String(value)}]`;
    }
    const objName = getConstructorName(value);
    if (/^HTML(\w*)Element$/.test(objName)) {
      return `[HTMLElement: ${objName}]`;
    }
    return `[object ${objName}]`;
  } catch (err) {
    return `**non-serializable** (${err})`;
  }
}
function getConstructorName(value) {
  const prototype2 = Object.getPrototypeOf(value);
  return prototype2 ? prototype2.constructor.name : "null prototype";
}
function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}
function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}
function createEnvelope(headers, items = []) {
  return [headers, items];
}
function addItemToEnvelope(envelope, newItem) {
  const [headers, items] = envelope;
  return [headers, [...items, newItem]];
}
function forEachEnvelopeItem(envelope, callback) {
  const envelopeItems = envelope[1];
  for (const envelopeItem of envelopeItems) {
    const envelopeItemType = envelopeItem[0].type;
    const result = callback(envelopeItem, envelopeItemType);
    if (result) {
      return true;
    }
  }
  return false;
}
function encodeUTF8(input) {
  return GLOBAL_OBJ.__SENTRY__ && GLOBAL_OBJ.__SENTRY__.encodePolyfill ? GLOBAL_OBJ.__SENTRY__.encodePolyfill(input) : new TextEncoder().encode(input);
}
function serializeEnvelope(envelope) {
  const [envHeaders, items] = envelope;
  let parts = JSON.stringify(envHeaders);
  function append(next) {
    if (typeof parts === "string") {
      parts = typeof next === "string" ? parts + next : [encodeUTF8(parts), next];
    } else {
      parts.push(typeof next === "string" ? encodeUTF8(next) : next);
    }
  }
  for (const item of items) {
    const [itemHeaders, payload] = item;
    append(`
${JSON.stringify(itemHeaders)}
`);
    if (typeof payload === "string" || payload instanceof Uint8Array) {
      append(payload);
    } else {
      let stringifiedPayload;
      try {
        stringifiedPayload = JSON.stringify(payload);
      } catch (e2) {
        stringifiedPayload = JSON.stringify(normalize$2(payload));
      }
      append(stringifiedPayload);
    }
  }
  return typeof parts === "string" ? parts : concatBuffers(parts);
}
function concatBuffers(buffers) {
  const totalLength = buffers.reduce((acc, buf) => acc + buf.length, 0);
  const merged = new Uint8Array(totalLength);
  let offset2 = 0;
  for (const buffer of buffers) {
    merged.set(buffer, offset2);
    offset2 += buffer.length;
  }
  return merged;
}
function createAttachmentEnvelopeItem(attachment) {
  const buffer = typeof attachment.data === "string" ? encodeUTF8(attachment.data) : attachment.data;
  return [
    dropUndefinedKeys({
      type: "attachment",
      length: buffer.length,
      filename: attachment.filename,
      content_type: attachment.contentType,
      attachment_type: attachment.attachmentType
    }),
    buffer
  ];
}
const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  profile_chunk: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket",
  raw_security: "security"
};
function envelopeItemTypeToDataCategory(type) {
  return ITEM_TYPE_TO_DATA_CATEGORY_MAP[type];
}
function getSdkMetadataForEnvelopeHeader(metadataOrEvent) {
  if (!metadataOrEvent || !metadataOrEvent.sdk) {
    return;
  }
  const { name, version: version2 } = metadataOrEvent.sdk;
  return { name, version: version2 };
}
function createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn) {
  const dynamicSamplingContext = event.sdkProcessingMetadata && event.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: event.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) },
    ...dynamicSamplingContext && {
      trace: dropUndefinedKeys({ ...dynamicSamplingContext })
    }
  };
}
function enhanceEventWithSdkInfo(event, sdkInfo) {
  if (!sdkInfo) {
    return event;
  }
  event.sdk = event.sdk || {};
  event.sdk.name = event.sdk.name || sdkInfo.name;
  event.sdk.version = event.sdk.version || sdkInfo.version;
  event.sdk.integrations = [...event.sdk.integrations || [], ...sdkInfo.integrations || []];
  event.sdk.packages = [...event.sdk.packages || [], ...sdkInfo.packages || []];
  return event;
}
function createSessionEnvelope(session, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const envelopeHeaders = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...sdkInfo && { sdk: sdkInfo },
    ...!!tunnel && dsn && { dsn: dsnToString(dsn) }
  };
  const envelopeItem = "aggregates" in session ? [{ type: "sessions" }, session] : [{ type: "session" }, session.toJSON()];
  return createEnvelope(envelopeHeaders, [envelopeItem]);
}
function createEventEnvelope(event, dsn, metadata, tunnel) {
  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);
  const eventType = event.type && event.type !== "replay_event" ? event.type : "event";
  enhanceEventWithSdkInfo(event, metadata && metadata.sdk);
  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);
  delete event.sdkProcessingMetadata;
  const eventItem = [{ type: eventType }, event];
  return createEnvelope(envelopeHeaders, [eventItem]);
}
function notifyEventProcessors(processors, event, hint, index2 = 0) {
  return new SyncPromise((resolve, reject) => {
    const processor = processors[index2];
    if (event === null || typeof processor !== "function") {
      resolve(event);
    } else {
      const result = processor({ ...event }, hint);
      DEBUG_BUILD$3 && processor.id && result === null && logger.log(`Event processor "${processor.id}" dropped event`);
      if (isThenable(result)) {
        void result.then((final) => notifyEventProcessors(processors, final, hint, index2 + 1).then(resolve)).then(null, reject);
      } else {
        void notifyEventProcessors(processors, result, hint, index2 + 1).then(resolve).then(null, reject);
      }
    }
  });
}
let parsedStackResults;
let lastKeysCount;
let cachedFilenameDebugIds;
function getFilenameToDebugIdMap(stackParser) {
  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;
  if (!debugIdMap) {
    return {};
  }
  const debugIdKeys = Object.keys(debugIdMap);
  if (cachedFilenameDebugIds && debugIdKeys.length === lastKeysCount) {
    return cachedFilenameDebugIds;
  }
  lastKeysCount = debugIdKeys.length;
  cachedFilenameDebugIds = debugIdKeys.reduce((acc, stackKey) => {
    if (!parsedStackResults) {
      parsedStackResults = {};
    }
    const result = parsedStackResults[stackKey];
    if (result) {
      acc[result[0]] = result[1];
    } else {
      const parsedStack = stackParser(stackKey);
      for (let i2 = parsedStack.length - 1; i2 >= 0; i2--) {
        const stackFrame = parsedStack[i2];
        const filename = stackFrame && stackFrame.filename;
        const debugId = debugIdMap[stackKey];
        if (filename && debugId) {
          acc[filename] = debugId;
          parsedStackResults[stackKey] = [filename, debugId];
          break;
        }
      }
    }
    return acc;
  }, {});
  return cachedFilenameDebugIds;
}
function applyScopeDataToEvent(event, data) {
  const { fingerprint, span, breadcrumbs, sdkProcessingMetadata } = data;
  applyDataToEvent(event, data);
  if (span) {
    applySpanToEvent(event, span);
  }
  applyFingerprintToEvent(event, fingerprint);
  applyBreadcrumbsToEvent(event, breadcrumbs);
  applySdkMetadataToEvent(event, sdkProcessingMetadata);
}
function mergeScopeData(data, mergeData) {
  const {
    extra,
    tags,
    user,
    contexts,
    level,
    sdkProcessingMetadata,
    breadcrumbs,
    fingerprint,
    eventProcessors,
    attachments,
    propagationContext,
    transactionName,
    span
  } = mergeData;
  mergeAndOverwriteScopeData(data, "extra", extra);
  mergeAndOverwriteScopeData(data, "tags", tags);
  mergeAndOverwriteScopeData(data, "user", user);
  mergeAndOverwriteScopeData(data, "contexts", contexts);
  data.sdkProcessingMetadata = merge(data.sdkProcessingMetadata, sdkProcessingMetadata, 2);
  if (level) {
    data.level = level;
  }
  if (transactionName) {
    data.transactionName = transactionName;
  }
  if (span) {
    data.span = span;
  }
  if (breadcrumbs.length) {
    data.breadcrumbs = [...data.breadcrumbs, ...breadcrumbs];
  }
  if (fingerprint.length) {
    data.fingerprint = [...data.fingerprint, ...fingerprint];
  }
  if (eventProcessors.length) {
    data.eventProcessors = [...data.eventProcessors, ...eventProcessors];
  }
  if (attachments.length) {
    data.attachments = [...data.attachments, ...attachments];
  }
  data.propagationContext = { ...data.propagationContext, ...propagationContext };
}
function mergeAndOverwriteScopeData(data, prop, mergeVal) {
  data[prop] = merge(data[prop], mergeVal, 1);
}
function applyDataToEvent(event, data) {
  const { extra, tags, user, contexts, level, transactionName } = data;
  const cleanedExtra = dropUndefinedKeys(extra);
  if (cleanedExtra && Object.keys(cleanedExtra).length) {
    event.extra = { ...cleanedExtra, ...event.extra };
  }
  const cleanedTags = dropUndefinedKeys(tags);
  if (cleanedTags && Object.keys(cleanedTags).length) {
    event.tags = { ...cleanedTags, ...event.tags };
  }
  const cleanedUser = dropUndefinedKeys(user);
  if (cleanedUser && Object.keys(cleanedUser).length) {
    event.user = { ...cleanedUser, ...event.user };
  }
  const cleanedContexts = dropUndefinedKeys(contexts);
  if (cleanedContexts && Object.keys(cleanedContexts).length) {
    event.contexts = { ...cleanedContexts, ...event.contexts };
  }
  if (level) {
    event.level = level;
  }
  if (transactionName && event.type !== "transaction") {
    event.transaction = transactionName;
  }
}
function applyBreadcrumbsToEvent(event, breadcrumbs) {
  const mergedBreadcrumbs = [...event.breadcrumbs || [], ...breadcrumbs];
  event.breadcrumbs = mergedBreadcrumbs.length ? mergedBreadcrumbs : void 0;
}
function applySdkMetadataToEvent(event, sdkProcessingMetadata) {
  event.sdkProcessingMetadata = {
    ...event.sdkProcessingMetadata,
    ...sdkProcessingMetadata
  };
}
function applySpanToEvent(event, span) {
  event.contexts = {
    trace: spanToTraceContext(span),
    ...event.contexts
  };
  event.sdkProcessingMetadata = {
    dynamicSamplingContext: getDynamicSamplingContextFromSpan(span),
    ...event.sdkProcessingMetadata
  };
  const rootSpan = getRootSpan(span);
  const transactionName = spanToJSON(rootSpan).description;
  if (transactionName && !event.transaction && event.type === "transaction") {
    event.transaction = transactionName;
  }
}
function applyFingerprintToEvent(event, fingerprint) {
  event.fingerprint = event.fingerprint ? Array.isArray(event.fingerprint) ? event.fingerprint : [event.fingerprint] : [];
  if (fingerprint) {
    event.fingerprint = event.fingerprint.concat(fingerprint);
  }
  if (event.fingerprint && !event.fingerprint.length) {
    delete event.fingerprint;
  }
}
function prepareEvent(options2, event, hint, scope, client, isolationScope) {
  const { normalizeDepth = 3, normalizeMaxBreadth = 1e3 } = options2;
  const prepared = {
    ...event,
    event_id: event.event_id || hint.event_id || uuid4(),
    timestamp: event.timestamp || dateTimestampInSeconds()
  };
  const integrations = hint.integrations || options2.integrations.map((i2) => i2.name);
  applyClientOptions(prepared, options2);
  applyIntegrationsMetadata(prepared, integrations);
  if (client) {
    client.emit("applyFrameMetadata", event);
  }
  if (event.type === void 0) {
    applyDebugIds(prepared, options2.stackParser);
  }
  const finalScope = getFinalScope(scope, hint.captureContext);
  if (hint.mechanism) {
    addExceptionMechanism(prepared, hint.mechanism);
  }
  const clientEventProcessors = client ? client.getEventProcessors() : [];
  const data = getGlobalScope().getScopeData();
  if (isolationScope) {
    const isolationData = isolationScope.getScopeData();
    mergeScopeData(data, isolationData);
  }
  if (finalScope) {
    const finalScopeData = finalScope.getScopeData();
    mergeScopeData(data, finalScopeData);
  }
  const attachments = [...hint.attachments || [], ...data.attachments];
  if (attachments.length) {
    hint.attachments = attachments;
  }
  applyScopeDataToEvent(prepared, data);
  const eventProcessors = [
    ...clientEventProcessors,
    // Run scope event processors _after_ all other processors
    ...data.eventProcessors
  ];
  const result = notifyEventProcessors(eventProcessors, prepared, hint);
  return result.then((evt) => {
    if (evt) {
      applyDebugMeta(evt);
    }
    if (typeof normalizeDepth === "number" && normalizeDepth > 0) {
      return normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);
    }
    return evt;
  });
}
function applyClientOptions(event, options2) {
  const { environment, release, dist, maxValueLength = 250 } = options2;
  event.environment = event.environment || environment || DEFAULT_ENVIRONMENT;
  if (!event.release && release) {
    event.release = release;
  }
  if (!event.dist && dist) {
    event.dist = dist;
  }
  if (event.message) {
    event.message = truncate(event.message, maxValueLength);
  }
  const exception = event.exception && event.exception.values && event.exception.values[0];
  if (exception && exception.value) {
    exception.value = truncate(exception.value, maxValueLength);
  }
  const request = event.request;
  if (request && request.url) {
    request.url = truncate(request.url, maxValueLength);
  }
}
function applyDebugIds(event, stackParser) {
  const filenameDebugIdMap = getFilenameToDebugIdMap(stackParser);
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (filenameDebugIdMap && frame.filename) {
          frame.debug_id = filenameDebugIdMap[frame.filename];
        }
      });
    });
  } catch (e2) {
  }
}
function applyDebugMeta(event) {
  const filenameDebugIdMap = {};
  try {
    event.exception.values.forEach((exception) => {
      exception.stacktrace.frames.forEach((frame) => {
        if (frame.debug_id) {
          if (frame.abs_path) {
            filenameDebugIdMap[frame.abs_path] = frame.debug_id;
          } else if (frame.filename) {
            filenameDebugIdMap[frame.filename] = frame.debug_id;
          }
          delete frame.debug_id;
        }
      });
    });
  } catch (e2) {
  }
  if (Object.keys(filenameDebugIdMap).length === 0) {
    return;
  }
  event.debug_meta = event.debug_meta || {};
  event.debug_meta.images = event.debug_meta.images || [];
  const images = event.debug_meta.images;
  Object.entries(filenameDebugIdMap).forEach(([filename, debug_id]) => {
    images.push({
      type: "sourcemap",
      code_file: filename,
      debug_id
    });
  });
}
function applyIntegrationsMetadata(event, integrationNames) {
  if (integrationNames.length > 0) {
    event.sdk = event.sdk || {};
    event.sdk.integrations = [...event.sdk.integrations || [], ...integrationNames];
  }
}
function normalizeEvent(event, depth, maxBreadth) {
  if (!event) {
    return null;
  }
  const normalized = {
    ...event,
    ...event.breadcrumbs && {
      breadcrumbs: event.breadcrumbs.map((b2) => ({
        ...b2,
        ...b2.data && {
          data: normalize$2(b2.data, depth, maxBreadth)
        }
      }))
    },
    ...event.user && {
      user: normalize$2(event.user, depth, maxBreadth)
    },
    ...event.contexts && {
      contexts: normalize$2(event.contexts, depth, maxBreadth)
    },
    ...event.extra && {
      extra: normalize$2(event.extra, depth, maxBreadth)
    }
  };
  if (event.contexts && event.contexts.trace && normalized.contexts) {
    normalized.contexts.trace = event.contexts.trace;
    if (event.contexts.trace.data) {
      normalized.contexts.trace.data = normalize$2(event.contexts.trace.data, depth, maxBreadth);
    }
  }
  if (event.spans) {
    normalized.spans = event.spans.map((span) => {
      return {
        ...span,
        ...span.data && {
          data: normalize$2(span.data, depth, maxBreadth)
        }
      };
    });
  }
  if (event.contexts && event.contexts.flags && normalized.contexts) {
    normalized.contexts.flags = normalize$2(event.contexts.flags, 3, maxBreadth);
  }
  return normalized;
}
function getFinalScope(scope, captureContext) {
  if (!captureContext) {
    return scope;
  }
  const finalScope = scope ? scope.clone() : new Scope();
  finalScope.update(captureContext);
  return finalScope;
}
function parseEventHintOrCaptureContext(hint) {
  if (!hint) {
    return void 0;
  }
  if (hintIsScopeOrFunction(hint)) {
    return { captureContext: hint };
  }
  if (hintIsScopeContext(hint)) {
    return {
      captureContext: hint
    };
  }
  return hint;
}
function hintIsScopeOrFunction(hint) {
  return hint instanceof Scope || typeof hint === "function";
}
const captureContextKeys = [
  "user",
  "level",
  "extra",
  "contexts",
  "tags",
  "fingerprint",
  "requestSession",
  "propagationContext"
];
function hintIsScopeContext(hint) {
  return Object.keys(hint).some((key) => captureContextKeys.includes(key));
}
function captureException(exception, hint) {
  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));
}
function captureMessage(message, captureContext) {
  const level = typeof captureContext === "string" ? captureContext : void 0;
  const context2 = typeof captureContext !== "string" ? { captureContext } : void 0;
  return getCurrentScope().captureMessage(message, level, context2);
}
function captureEvent(event, hint) {
  return getCurrentScope().captureEvent(event, hint);
}
function setContext$1(name, context2) {
  getIsolationScope().setContext(name, context2);
}
function startSession(context2) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const { release, environment = DEFAULT_ENVIRONMENT } = client && client.getOptions() || {};
  const { userAgent } = GLOBAL_OBJ.navigator || {};
  const session = makeSession({
    release,
    environment,
    user: currentScope.getUser() || isolationScope.getUser(),
    ...userAgent && { userAgent },
    ...context2
  });
  const currentSession = isolationScope.getSession();
  if (currentSession && currentSession.status === "ok") {
    updateSession(currentSession, { status: "exited" });
  }
  endSession();
  isolationScope.setSession(session);
  currentScope.setSession(session);
  return session;
}
function endSession() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session) {
    closeSession(session);
  }
  _sendSessionUpdate();
  isolationScope.setSession();
  currentScope.setSession();
}
function _sendSessionUpdate() {
  const isolationScope = getIsolationScope();
  const currentScope = getCurrentScope();
  const client = getClient();
  const session = currentScope.getSession() || isolationScope.getSession();
  if (session && client) {
    client.captureSession(session);
  }
}
function captureSession(end = false) {
  if (end) {
    endSession();
    return;
  }
  _sendSessionUpdate();
}
const SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(dsn) {
  const protocol = dsn.protocol ? `${dsn.protocol}:` : "";
  const port = dsn.port ? `:${dsn.port}` : "";
  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ""}/api/`;
}
function _getIngestEndpoint(dsn) {
  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;
}
function _encodedAuth(dsn, sdkInfo) {
  const params = {
    sentry_version: SENTRY_API_VERSION
  };
  if (dsn.publicKey) {
    params.sentry_key = dsn.publicKey;
  }
  if (sdkInfo) {
    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;
  }
  return new URLSearchParams(params).toString();
}
function getEnvelopeEndpointWithUrlEncodedAuth(dsn, tunnel, sdkInfo) {
  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;
}
const installedIntegrations = [];
function filterDuplicates(integrations) {
  const integrationsByName = {};
  integrations.forEach((currentInstance) => {
    const { name } = currentInstance;
    const existingInstance = integrationsByName[name];
    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {
      return;
    }
    integrationsByName[name] = currentInstance;
  });
  return Object.values(integrationsByName);
}
function getIntegrationsToSetup(options2) {
  const defaultIntegrations = options2.defaultIntegrations || [];
  const userIntegrations = options2.integrations;
  defaultIntegrations.forEach((integration) => {
    integration.isDefaultInstance = true;
  });
  let integrations;
  if (Array.isArray(userIntegrations)) {
    integrations = [...defaultIntegrations, ...userIntegrations];
  } else if (typeof userIntegrations === "function") {
    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);
    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];
  } else {
    integrations = defaultIntegrations;
  }
  const finalIntegrations = filterDuplicates(integrations);
  const debugIndex = finalIntegrations.findIndex((integration) => integration.name === "Debug");
  if (debugIndex > -1) {
    const [debugInstance] = finalIntegrations.splice(debugIndex, 1);
    finalIntegrations.push(debugInstance);
  }
  return finalIntegrations;
}
function setupIntegrations(client, integrations) {
  const integrationIndex = {};
  integrations.forEach((integration) => {
    if (integration) {
      setupIntegration(client, integration, integrationIndex);
    }
  });
  return integrationIndex;
}
function afterSetupIntegrations(client, integrations) {
  for (const integration of integrations) {
    if (integration && integration.afterAllSetup) {
      integration.afterAllSetup(client);
    }
  }
}
function setupIntegration(client, integration, integrationIndex) {
  if (integrationIndex[integration.name]) {
    DEBUG_BUILD$3 && logger.log(`Integration skipped because it was already installed: ${integration.name}`);
    return;
  }
  integrationIndex[integration.name] = integration;
  if (installedIntegrations.indexOf(integration.name) === -1 && typeof integration.setupOnce === "function") {
    integration.setupOnce();
    installedIntegrations.push(integration.name);
  }
  if (integration.setup && typeof integration.setup === "function") {
    integration.setup(client);
  }
  if (typeof integration.preprocessEvent === "function") {
    const callback = integration.preprocessEvent.bind(integration);
    client.on("preprocessEvent", (event, hint) => callback(event, hint, client));
  }
  if (typeof integration.processEvent === "function") {
    const callback = integration.processEvent.bind(integration);
    const processor = Object.assign((event, hint) => callback(event, hint, client), {
      id: integration.name
    });
    client.addEventProcessor(processor);
  }
  DEBUG_BUILD$3 && logger.log(`Integration installed: ${integration.name}`);
}
function defineIntegration(fn2) {
  return fn2;
}
function createClientReportEnvelope(discarded_events, dsn, timestamp) {
  const clientReportItem = [
    { type: "client_report" },
    {
      timestamp: dateTimestampInSeconds(),
      discarded_events
    }
  ];
  return createEnvelope(dsn ? { dsn } : {}, [clientReportItem]);
}
class SentryError extends Error {
  /** Display name of this error instance. */
  constructor(message, logLevel = "warn") {
    super(message);
    this.message = message;
    this.name = new.target.prototype.constructor.name;
    Object.setPrototypeOf(this, new.target.prototype);
    this.logLevel = logLevel;
  }
}
const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured.";
class BaseClient {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(options2) {
    this._options = options2;
    this._integrations = {};
    this._numProcessing = 0;
    this._outcomes = {};
    this._hooks = {};
    this._eventProcessors = [];
    if (options2.dsn) {
      this._dsn = makeDsn(options2.dsn);
    } else {
      DEBUG_BUILD$3 && logger.warn("No DSN provided, client will not send events.");
    }
    if (this._dsn) {
      const url = getEnvelopeEndpointWithUrlEncodedAuth(
        this._dsn,
        options2.tunnel,
        options2._metadata ? options2._metadata.sdk : void 0
      );
      this._transport = options2.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...options2.transportOptions,
        url
      });
    }
    const tracingOptions = ["enableTracing", "tracesSampleRate", "tracesSampler"];
    const undefinedOption = tracingOptions.find((option) => option in options2 && options2[option] == void 0);
    if (undefinedOption) {
      consoleSandbox(() => {
        console.warn(
          `[Sentry] Deprecation warning: \`${undefinedOption}\` is set to undefined, which leads to tracing being enabled. In v9, a value of \`undefined\` will result in tracing being disabled.`
        );
      });
    }
  }
  /**
   * @inheritDoc
   */
  captureException(exception, hint, scope) {
    const eventId = uuid4();
    if (checkOrSetAlreadyCaught(exception)) {
      DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    this._process(
      this.eventFromException(exception, hintWithEventId).then(
        (event) => this._captureEvent(event, hintWithEventId, scope)
      )
    );
    return hintWithEventId.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(message, level, hint, currentScope) {
    const hintWithEventId = {
      event_id: uuid4(),
      ...hint
    };
    const eventMessage = isParameterizedString(message) ? message : String(message);
    const promisedEvent = isPrimitive(message) ? this.eventFromMessage(eventMessage, level, hintWithEventId) : this.eventFromException(message, hintWithEventId);
    this._process(promisedEvent.then((event) => this._captureEvent(event, hintWithEventId, currentScope)));
    return hintWithEventId.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(event, hint, currentScope) {
    const eventId = uuid4();
    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {
      DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR);
      return eventId;
    }
    const hintWithEventId = {
      event_id: eventId,
      ...hint
    };
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanScope = sdkProcessingMetadata.capturedSpanScope;
    this._process(this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope));
    return hintWithEventId.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(session) {
    if (!(typeof session.release === "string")) {
      DEBUG_BUILD$3 && logger.warn("Discarded session because of missing or non-string release");
    } else {
      this.sendSession(session);
      updateSession(session, { init: false });
    }
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(timeout) {
    const transport = this._transport;
    if (transport) {
      this.emit("flush");
      return this._isClientDoneProcessing(timeout).then((clientFinished) => {
        return transport.flush(timeout).then((transportFlushed) => clientFinished && transportFlushed);
      });
    } else {
      return resolvedSyncPromise(true);
    }
  }
  /**
   * @inheritDoc
   */
  close(timeout) {
    return this.flush(timeout).then((result) => {
      this.getOptions().enabled = false;
      this.emit("close");
      return result;
    });
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(eventProcessor) {
    this._eventProcessors.push(eventProcessor);
  }
  /** @inheritdoc */
  init() {
    if (this._isEnabled() || // Force integrations to be setup even if no DSN was set when we have
    // Spotlight enabled. This is particularly important for browser as we
    // don't support the `spotlight` option there and rely on the users
    // adding the `spotlightBrowserIntegration()` to their integrations which
    // wouldn't get initialized with the check below when there's no DSN set.
    this._options.integrations.some(({ name }) => name.startsWith("Spotlight"))) {
      this._setupIntegrations();
    }
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(integrationName) {
    return this._integrations[integrationName];
  }
  /**
   * @inheritDoc
   */
  addIntegration(integration) {
    const isAlreadyInstalled = this._integrations[integration.name];
    setupIntegration(this, integration, this._integrations);
    if (!isAlreadyInstalled) {
      afterSetupIntegrations(this, [integration]);
    }
  }
  /**
   * @inheritDoc
   */
  sendEvent(event, hint = {}) {
    this.emit("beforeSendEvent", event, hint);
    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);
    for (const attachment of hint.attachments || []) {
      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));
    }
    const promise = this.sendEnvelope(env);
    if (promise) {
      promise.then((sendResponse) => this.emit("afterSendEvent", event, sendResponse), null);
    }
  }
  /**
   * @inheritDoc
   */
  sendSession(session) {
    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(env);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(reason, category, eventOrCount) {
    if (this._options.sendClientReports) {
      const count2 = typeof eventOrCount === "number" ? eventOrCount : 1;
      const key = `${reason}:${category}`;
      DEBUG_BUILD$3 && logger.log(`Recording outcome: "${key}"${count2 > 1 ? ` (${count2} times)` : ""}`);
      this._outcomes[key] = (this._outcomes[key] || 0) + count2;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(hook, callback) {
    const hooks2 = this._hooks[hook] = this._hooks[hook] || [];
    hooks2.push(callback);
    return () => {
      const cbIndex = hooks2.indexOf(callback);
      if (cbIndex > -1) {
        hooks2.splice(cbIndex, 1);
      }
    };
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(hook, ...rest) {
    const callbacks = this._hooks[hook];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...rest));
    }
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(envelope) {
    this.emit("beforeEnvelope", envelope);
    if (this._isEnabled() && this._transport) {
      return this._transport.send(envelope).then(null, (reason) => {
        DEBUG_BUILD$3 && logger.error("Error while sending envelope:", reason);
        return reason;
      });
    }
    DEBUG_BUILD$3 && logger.error("Transport disabled");
    return resolvedSyncPromise({});
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations } = this._options;
    this._integrations = setupIntegrations(this, integrations);
    afterSetupIntegrations(this, integrations);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(session, event) {
    let crashed = false;
    let errored = false;
    const exceptions = event.exception && event.exception.values;
    if (exceptions) {
      errored = true;
      for (const ex of exceptions) {
        const mechanism = ex.mechanism;
        if (mechanism && mechanism.handled === false) {
          crashed = true;
          break;
        }
      }
    }
    const sessionNonTerminal = session.status === "ok";
    const shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;
    if (shouldUpdateAndSend) {
      updateSession(session, {
        ...crashed && { status: "crashed" },
        errors: session.errors || Number(errored || crashed)
      });
      this.captureSession(session);
    }
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(timeout) {
    return new SyncPromise((resolve) => {
      let ticked = 0;
      const tick = 1;
      const interval = setInterval(() => {
        if (this._numProcessing == 0) {
          clearInterval(interval);
          resolve(true);
        } else {
          ticked += tick;
          if (timeout && ticked >= timeout) {
            clearInterval(interval);
            resolve(false);
          }
        }
      }, tick);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== false && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(event, hint, currentScope = getCurrentScope(), isolationScope = getIsolationScope()) {
    const options2 = this.getOptions();
    const integrations = Object.keys(this._integrations);
    if (!hint.integrations && integrations.length > 0) {
      hint.integrations = integrations;
    }
    this.emit("preprocessEvent", event, hint);
    if (!event.type) {
      isolationScope.setLastEventId(event.event_id || hint.event_id);
    }
    return prepareEvent(options2, event, hint, currentScope, this, isolationScope).then((evt) => {
      if (evt === null) {
        return evt;
      }
      evt.contexts = {
        trace: getTraceContextFromScope(currentScope),
        ...evt.contexts
      };
      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);
      evt.sdkProcessingMetadata = {
        dynamicSamplingContext,
        ...evt.sdkProcessingMetadata
      };
      return evt;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(event, hint = {}, scope) {
    return this._processEvent(event, hint, scope).then(
      (finalEvent) => {
        return finalEvent.event_id;
      },
      (reason) => {
        if (DEBUG_BUILD$3) {
          const sentryError = reason;
          if (sentryError.logLevel === "log") {
            logger.log(sentryError.message);
          } else {
            logger.warn(sentryError);
          }
        }
        return void 0;
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(event, hint, currentScope) {
    const options2 = this.getOptions();
    const { sampleRate } = options2;
    const isTransaction = isTransactionEvent(event);
    const isError2 = isErrorEvent(event);
    const eventType = event.type || "error";
    const beforeSendLabel = `before send for type \`${eventType}\``;
    const parsedSampleRate = typeof sampleRate === "undefined" ? void 0 : parseSampleRate(sampleRate);
    if (isError2 && typeof parsedSampleRate === "number" && Math.random() > parsedSampleRate) {
      this.recordDroppedEvent("sample_rate", "error", event);
      return rejectedSyncPromise(
        new SentryError(
          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,
          "log"
        )
      );
    }
    const dataCategory = eventType === "replay_event" ? "replay" : eventType;
    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};
    const capturedSpanIsolationScope = sdkProcessingMetadata.capturedSpanIsolationScope;
    return this._prepareEvent(event, hint, currentScope, capturedSpanIsolationScope).then((prepared) => {
      if (prepared === null) {
        this.recordDroppedEvent("event_processor", dataCategory, event);
        throw new SentryError("An event processor returned `null`, will not send event.", "log");
      }
      const isInternalException = hint.data && hint.data.__sentry__ === true;
      if (isInternalException) {
        return prepared;
      }
      const result = processBeforeSend(this, options2, prepared, hint);
      return _validateBeforeSendResult(result, beforeSendLabel);
    }).then((processedEvent) => {
      if (processedEvent === null) {
        this.recordDroppedEvent("before_send", dataCategory, event);
        if (isTransaction) {
          const spans = event.spans || [];
          const spanCount = 1 + spans.length;
          this.recordDroppedEvent("before_send", "span", spanCount);
        }
        throw new SentryError(`${beforeSendLabel} returned \`null\`, will not send event.`, "log");
      }
      const session = currentScope && currentScope.getSession();
      if (!isTransaction && session) {
        this._updateSessionFromEvent(session, processedEvent);
      }
      if (isTransaction) {
        const spanCountBefore = processedEvent.sdkProcessingMetadata && processedEvent.sdkProcessingMetadata.spanCountBeforeProcessing || 0;
        const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;
        const droppedSpanCount = spanCountBefore - spanCountAfter;
        if (droppedSpanCount > 0) {
          this.recordDroppedEvent("before_send", "span", droppedSpanCount);
        }
      }
      const transactionInfo = processedEvent.transaction_info;
      if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {
        const source = "custom";
        processedEvent.transaction_info = {
          ...transactionInfo,
          source
        };
      }
      this.sendEvent(processedEvent, hint);
      return processedEvent;
    }).then(null, (reason) => {
      if (reason instanceof SentryError) {
        throw reason;
      }
      this.captureException(reason, {
        data: {
          __sentry__: true
        },
        originalException: reason
      });
      throw new SentryError(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${reason}`
      );
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(promise) {
    this._numProcessing++;
    void promise.then(
      (value) => {
        this._numProcessing--;
        return value;
      },
      (reason) => {
        this._numProcessing--;
        return reason;
      }
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const outcomes = this._outcomes;
    this._outcomes = {};
    return Object.entries(outcomes).map(([key, quantity]) => {
      const [reason, category] = key.split(":");
      return {
        reason,
        category,
        quantity
      };
    });
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    DEBUG_BUILD$3 && logger.log("Flushing outcomes...");
    const outcomes = this._clearOutcomes();
    if (outcomes.length === 0) {
      DEBUG_BUILD$3 && logger.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      DEBUG_BUILD$3 && logger.log("No dsn provided, will not send outcomes");
      return;
    }
    DEBUG_BUILD$3 && logger.log("Sending outcomes:", outcomes);
    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));
    this.sendEnvelope(envelope);
  }
  /**
   * @inheritDoc
   */
}
function _validateBeforeSendResult(beforeSendResult, beforeSendLabel) {
  const invalidValueError = `${beforeSendLabel} must return \`null\` or a valid event.`;
  if (isThenable(beforeSendResult)) {
    return beforeSendResult.then(
      (event) => {
        if (!isPlainObject$3(event) && event !== null) {
          throw new SentryError(invalidValueError);
        }
        return event;
      },
      (e2) => {
        throw new SentryError(`${beforeSendLabel} rejected with ${e2}`);
      }
    );
  } else if (!isPlainObject$3(beforeSendResult) && beforeSendResult !== null) {
    throw new SentryError(invalidValueError);
  }
  return beforeSendResult;
}
function processBeforeSend(client, options2, event, hint) {
  const { beforeSend, beforeSendTransaction, beforeSendSpan } = options2;
  if (isErrorEvent(event) && beforeSend) {
    return beforeSend(event, hint);
  }
  if (isTransactionEvent(event)) {
    if (event.spans && beforeSendSpan) {
      const processedSpans = [];
      for (const span of event.spans) {
        const processedSpan = beforeSendSpan(span);
        if (processedSpan) {
          processedSpans.push(processedSpan);
        } else {
          showSpanDropWarning();
          client.recordDroppedEvent("before_send", "span");
        }
      }
      event.spans = processedSpans;
    }
    if (beforeSendTransaction) {
      if (event.spans) {
        const spanCountBefore = event.spans.length;
        event.sdkProcessingMetadata = {
          ...event.sdkProcessingMetadata,
          spanCountBeforeProcessing: spanCountBefore
        };
      }
      return beforeSendTransaction(event, hint);
    }
  }
  return event;
}
function isErrorEvent(event) {
  return event.type === void 0;
}
function isTransactionEvent(event) {
  return event.type === "transaction";
}
function initAndBind(clientClass, options2) {
  if (options2.debug === true) {
    if (DEBUG_BUILD$3) {
      logger.enable();
    } else {
      consoleSandbox(() => {
        console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
      });
    }
  }
  const scope = getCurrentScope();
  scope.update(options2.initialScope);
  const client = new clientClass(options2);
  setCurrentClient(client);
  client.init();
  return client;
}
function setCurrentClient(client) {
  getCurrentScope().setClient(client);
}
function makePromiseBuffer(limit) {
  const buffer = [];
  function isReady() {
    return limit === void 0 || buffer.length < limit;
  }
  function remove(task) {
    return buffer.splice(buffer.indexOf(task), 1)[0] || Promise.resolve(void 0);
  }
  function add(taskProducer) {
    if (!isReady()) {
      return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
    }
    const task = taskProducer();
    if (buffer.indexOf(task) === -1) {
      buffer.push(task);
    }
    void task.then(() => remove(task)).then(
      null,
      () => remove(task).then(null, () => {
      })
    );
    return task;
  }
  function drain(timeout) {
    return new SyncPromise((resolve, reject) => {
      let counter = buffer.length;
      if (!counter) {
        return resolve(true);
      }
      const capturedSetTimeout = setTimeout(() => {
        if (timeout && timeout > 0) {
          resolve(false);
        }
      }, timeout);
      buffer.forEach((item) => {
        void resolvedSyncPromise(item).then(() => {
          if (!--counter) {
            clearTimeout(capturedSetTimeout);
            resolve(true);
          }
        }, reject);
      });
    });
  }
  return {
    $: buffer,
    add,
    drain
  };
}
const DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(header, now = Date.now()) {
  const headerDelay = parseInt(`${header}`, 10);
  if (!isNaN(headerDelay)) {
    return headerDelay * 1e3;
  }
  const headerDate = Date.parse(`${header}`);
  if (!isNaN(headerDate)) {
    return headerDate - now;
  }
  return DEFAULT_RETRY_AFTER;
}
function disabledUntil(limits, dataCategory) {
  return limits[dataCategory] || limits.all || 0;
}
function isRateLimited(limits, dataCategory, now = Date.now()) {
  return disabledUntil(limits, dataCategory) > now;
}
function updateRateLimits(limits, { statusCode, headers }, now = Date.now()) {
  const updatedRateLimits = {
    ...limits
  };
  const rateLimitHeader = headers && headers["x-sentry-rate-limits"];
  const retryAfterHeader = headers && headers["retry-after"];
  if (rateLimitHeader) {
    for (const limit of rateLimitHeader.trim().split(",")) {
      const [retryAfter, categories, , , namespaces] = limit.split(":", 5);
      const headerDelay = parseInt(retryAfter, 10);
      const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1e3;
      if (!categories) {
        updatedRateLimits.all = now + delay;
      } else {
        for (const category of categories.split(";")) {
          if (category === "metric_bucket") {
            if (!namespaces || namespaces.split(";").includes("custom")) {
              updatedRateLimits[category] = now + delay;
            }
          } else {
            updatedRateLimits[category] = now + delay;
          }
        }
      }
    }
  } else if (retryAfterHeader) {
    updatedRateLimits.all = now + parseRetryAfterHeader(retryAfterHeader, now);
  } else if (statusCode === 429) {
    updatedRateLimits.all = now + 60 * 1e3;
  }
  return updatedRateLimits;
}
const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(options2, makeRequest, buffer = makePromiseBuffer(
  options2.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE
)) {
  let rateLimits = {};
  const flush = (timeout) => buffer.drain(timeout);
  function send(envelope) {
    const filteredEnvelopeItems = [];
    forEachEnvelopeItem(envelope, (item, type) => {
      const dataCategory = envelopeItemTypeToDataCategory(type);
      if (isRateLimited(rateLimits, dataCategory)) {
        const event = getEventForEnvelopeItem(item, type);
        options2.recordDroppedEvent("ratelimit_backoff", dataCategory, event);
      } else {
        filteredEnvelopeItems.push(item);
      }
    });
    if (filteredEnvelopeItems.length === 0) {
      return resolvedSyncPromise({});
    }
    const filteredEnvelope = createEnvelope(envelope[0], filteredEnvelopeItems);
    const recordEnvelopeLoss = (reason) => {
      forEachEnvelopeItem(filteredEnvelope, (item, type) => {
        const event = getEventForEnvelopeItem(item, type);
        options2.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type), event);
      });
    };
    const requestTask = () => makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(
      (response) => {
        if (response.statusCode !== void 0 && (response.statusCode < 200 || response.statusCode >= 300)) {
          DEBUG_BUILD$3 && logger.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);
        }
        rateLimits = updateRateLimits(rateLimits, response);
        return response;
      },
      (error) => {
        recordEnvelopeLoss("network_error");
        throw error;
      }
    );
    return buffer.add(requestTask).then(
      (result) => result,
      (error) => {
        if (error instanceof SentryError) {
          DEBUG_BUILD$3 && logger.error("Skipped sending event because buffer is full.");
          recordEnvelopeLoss("queue_overflow");
          return resolvedSyncPromise({});
        } else {
          throw error;
        }
      }
    );
  }
  return {
    send,
    flush
  };
}
function getEventForEnvelopeItem(item, type) {
  if (type !== "event" && type !== "transaction") {
    return void 0;
  }
  return Array.isArray(item) ? item[1] : void 0;
}
function applySdkMetadata(options2, name, names = [name], source = "npm") {
  const metadata = options2._metadata || {};
  if (!metadata.sdk) {
    metadata.sdk = {
      name: `sentry.javascript.${name}`,
      packages: names.map((name2) => ({
        name: `${source}:@sentry/${name2}`,
        version: SDK_VERSION
      })),
      version: SDK_VERSION
    };
  }
  options2._metadata = metadata;
}
const DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(breadcrumb, hint) {
  const client = getClient();
  const isolationScope = getIsolationScope();
  if (!client) return;
  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();
  if (maxBreadcrumbs <= 0) return;
  const timestamp = dateTimestampInSeconds();
  const mergedBreadcrumb = { timestamp, ...breadcrumb };
  const finalBreadcrumb = beforeBreadcrumb ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint)) : mergedBreadcrumb;
  if (finalBreadcrumb === null) return;
  if (client.emit) {
    client.emit("beforeAddBreadcrumb", finalBreadcrumb, hint);
  }
  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);
}
let originalFunctionToString;
const INTEGRATION_NAME$7 = "FunctionToString";
const SETUP_CLIENTS = /* @__PURE__ */ new WeakMap();
const _functionToStringIntegration = () => {
  return {
    name: INTEGRATION_NAME$7,
    setupOnce() {
      originalFunctionToString = Function.prototype.toString;
      try {
        Function.prototype.toString = function(...args) {
          const originalFunction = getOriginalFunction(this);
          const context2 = SETUP_CLIENTS.has(getClient()) && originalFunction !== void 0 ? originalFunction : this;
          return originalFunctionToString.apply(context2, args);
        };
      } catch (e2) {
      }
    },
    setup(client) {
      SETUP_CLIENTS.set(client, true);
    }
  };
};
const functionToStringIntegration = defineIntegration(_functionToStringIntegration);
const DEFAULT_IGNORE_ERRORS = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  // The browser logs this when a ResizeObserver handler takes a bit longer. Usually this is not an actual issue though. It indicates slowness.
  /^Cannot redefine property: googletag$/,
  // This is thrown when google tag manager is used in combination with an ad blocker
  "undefined is not an object (evaluating 'a.L')",
  // Random error that happens but not actionable or noticeable to end-users.
  `can't redefine non-configurable property "solana"`,
  // Probably a browser extension or custom browser (Brave) throwing this error
  "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)",
  // Error thrown by GTM, seemingly not affecting end-users
  "Can't find variable: _AutofillCallbackHandler",
  // Unactionable error in instagram webview https://developers.facebook.com/community/threads/320013549791141/
  /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/
  // unactionable error from CEFSharp, a .NET library that embeds chromium in .NET apps
];
const INTEGRATION_NAME$6 = "InboundFilters";
const _inboundFiltersIntegration = (options2 = {}) => {
  return {
    name: INTEGRATION_NAME$6,
    processEvent(event, _hint, client) {
      const clientOptions = client.getOptions();
      const mergedOptions = _mergeOptions(options2, clientOptions);
      return _shouldDropEvent$1(event, mergedOptions) ? null : event;
    }
  };
};
const inboundFiltersIntegration = defineIntegration(_inboundFiltersIntegration);
function _mergeOptions(internalOptions = {}, clientOptions = {}) {
  return {
    allowUrls: [...internalOptions.allowUrls || [], ...clientOptions.allowUrls || []],
    denyUrls: [...internalOptions.denyUrls || [], ...clientOptions.denyUrls || []],
    ignoreErrors: [
      ...internalOptions.ignoreErrors || [],
      ...clientOptions.ignoreErrors || [],
      ...internalOptions.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS
    ],
    ignoreTransactions: [...internalOptions.ignoreTransactions || [], ...clientOptions.ignoreTransactions || []],
    ignoreInternal: internalOptions.ignoreInternal !== void 0 ? internalOptions.ignoreInternal : true
  };
}
function _shouldDropEvent$1(event, options2) {
  if (options2.ignoreInternal && _isSentryError(event)) {
    DEBUG_BUILD$3 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(event)}`);
    return true;
  }
  if (_isIgnoredError(event, options2.ignoreErrors)) {
    DEBUG_BUILD$3 && logger.warn(
      `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(event)}`
    );
    return true;
  }
  if (_isUselessError(event)) {
    DEBUG_BUILD$3 && logger.warn(
      `Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(
        event
      )}`
    );
    return true;
  }
  if (_isIgnoredTransaction(event, options2.ignoreTransactions)) {
    DEBUG_BUILD$3 && logger.warn(
      `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(event)}`
    );
    return true;
  }
  if (_isDeniedUrl(event, options2.denyUrls)) {
    DEBUG_BUILD$3 && logger.warn(
      `Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(
        event
      )}.
Url: ${_getEventFilterUrl(event)}`
    );
    return true;
  }
  if (!_isAllowedUrl(event, options2.allowUrls)) {
    DEBUG_BUILD$3 && logger.warn(
      `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(
        event
      )}.
Url: ${_getEventFilterUrl(event)}`
    );
    return true;
  }
  return false;
}
function _isIgnoredError(event, ignoreErrors) {
  if (event.type || !ignoreErrors || !ignoreErrors.length) {
    return false;
  }
  return _getPossibleEventMessages(event).some((message) => stringMatchesSomePattern(message, ignoreErrors));
}
function _isIgnoredTransaction(event, ignoreTransactions) {
  if (event.type !== "transaction" || !ignoreTransactions || !ignoreTransactions.length) {
    return false;
  }
  const name = event.transaction;
  return name ? stringMatchesSomePattern(name, ignoreTransactions) : false;
}
function _isDeniedUrl(event, denyUrls) {
  if (!denyUrls || !denyUrls.length) {
    return false;
  }
  const url = _getEventFilterUrl(event);
  return !url ? false : stringMatchesSomePattern(url, denyUrls);
}
function _isAllowedUrl(event, allowUrls) {
  if (!allowUrls || !allowUrls.length) {
    return true;
  }
  const url = _getEventFilterUrl(event);
  return !url ? true : stringMatchesSomePattern(url, allowUrls);
}
function _getPossibleEventMessages(event) {
  const possibleMessages = [];
  if (event.message) {
    possibleMessages.push(event.message);
  }
  let lastException;
  try {
    lastException = event.exception.values[event.exception.values.length - 1];
  } catch (e2) {
  }
  if (lastException) {
    if (lastException.value) {
      possibleMessages.push(lastException.value);
      if (lastException.type) {
        possibleMessages.push(`${lastException.type}: ${lastException.value}`);
      }
    }
  }
  return possibleMessages;
}
function _isSentryError(event) {
  try {
    return event.exception.values[0].type === "SentryError";
  } catch (e2) {
  }
  return false;
}
function _getLastValidUrl(frames = []) {
  for (let i2 = frames.length - 1; i2 >= 0; i2--) {
    const frame = frames[i2];
    if (frame && frame.filename !== "<anonymous>" && frame.filename !== "[native code]") {
      return frame.filename || null;
    }
  }
  return null;
}
function _getEventFilterUrl(event) {
  try {
    let frames;
    try {
      frames = event.exception.values[0].stacktrace.frames;
    } catch (e2) {
    }
    return frames ? _getLastValidUrl(frames) : null;
  } catch (oO) {
    DEBUG_BUILD$3 && logger.error(`Cannot extract url for event ${getEventDescription(event)}`);
    return null;
  }
}
function _isUselessError(event) {
  if (event.type) {
    return false;
  }
  if (!event.exception || !event.exception.values || event.exception.values.length === 0) {
    return false;
  }
  return (
    // No top-level message
    !event.message && // There are no exception values that have a stacktrace, a non-generic-Error type or value
    !event.exception.values.some((value) => value.stacktrace || value.type && value.type !== "Error" || value.value)
  );
}
function applyAggregateErrorsToEvent(exceptionFromErrorImplementation, parser2, maxValueLimit = 250, key, limit, event, hint) {
  if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
    return;
  }
  const originalException = event.exception.values.length > 0 ? event.exception.values[event.exception.values.length - 1] : void 0;
  if (originalException) {
    event.exception.values = truncateAggregateExceptions(
      aggregateExceptionsFromError(
        exceptionFromErrorImplementation,
        parser2,
        limit,
        hint.originalException,
        key,
        event.exception.values,
        originalException,
        0
      ),
      maxValueLimit
    );
  }
}
function aggregateExceptionsFromError(exceptionFromErrorImplementation, parser2, limit, error, key, prevExceptions, exception, exceptionId) {
  if (prevExceptions.length >= limit + 1) {
    return prevExceptions;
  }
  let newExceptions = [...prevExceptions];
  if (isInstanceOf(error[key], Error)) {
    applyExceptionGroupFieldsForParentException(exception, exceptionId);
    const newException = exceptionFromErrorImplementation(parser2, error[key]);
    const newExceptionId = newExceptions.length;
    applyExceptionGroupFieldsForChildException(newException, key, newExceptionId, exceptionId);
    newExceptions = aggregateExceptionsFromError(
      exceptionFromErrorImplementation,
      parser2,
      limit,
      error[key],
      key,
      [newException, ...newExceptions],
      newException,
      newExceptionId
    );
  }
  if (Array.isArray(error.errors)) {
    error.errors.forEach((childError, i2) => {
      if (isInstanceOf(childError, Error)) {
        applyExceptionGroupFieldsForParentException(exception, exceptionId);
        const newException = exceptionFromErrorImplementation(parser2, childError);
        const newExceptionId = newExceptions.length;
        applyExceptionGroupFieldsForChildException(newException, `errors[${i2}]`, newExceptionId, exceptionId);
        newExceptions = aggregateExceptionsFromError(
          exceptionFromErrorImplementation,
          parser2,
          limit,
          childError,
          key,
          [newException, ...newExceptions],
          newException,
          newExceptionId
        );
      }
    });
  }
  return newExceptions;
}
function applyExceptionGroupFieldsForParentException(exception, exceptionId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    ...exception.type === "AggregateError" && { is_exception_group: true },
    exception_id: exceptionId
  };
}
function applyExceptionGroupFieldsForChildException(exception, source, exceptionId, parentId) {
  exception.mechanism = exception.mechanism || { type: "generic", handled: true };
  exception.mechanism = {
    ...exception.mechanism,
    type: "chained",
    source,
    exception_id: exceptionId,
    parent_id: parentId
  };
}
function truncateAggregateExceptions(exceptions, maxValueLength) {
  return exceptions.map((exception) => {
    if (exception.value) {
      exception.value = truncate(exception.value, maxValueLength);
    }
    return exception;
  });
}
function parseUrl$1(url) {
  if (!url) {
    return {};
  }
  const match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!match) {
    return {};
  }
  const query = match[6] || "";
  const fragment = match[8] || "";
  return {
    host: match[4],
    path: match[5],
    protocol: match[2],
    search: query,
    hash: fragment,
    relative: match[5] + query + fragment
    // everything minus origin
  };
}
function addConsoleInstrumentationHandler(handler) {
  const type = "console";
  addHandler(type, handler);
  maybeInstrument(type, instrumentConsole);
}
function instrumentConsole() {
  if (!("console" in GLOBAL_OBJ)) {
    return;
  }
  CONSOLE_LEVELS.forEach(function(level) {
    if (!(level in GLOBAL_OBJ.console)) {
      return;
    }
    fill(GLOBAL_OBJ.console, level, function(originalConsoleMethod) {
      originalConsoleMethods[level] = originalConsoleMethod;
      return function(...args) {
        const handlerData = { args, level };
        triggerHandlers("console", handlerData);
        const log = originalConsoleMethods[level];
        log && log.apply(GLOBAL_OBJ.console, args);
      };
    });
  });
}
function severityLevelFromString(level) {
  return level === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(level) ? level : "log";
}
const INTEGRATION_NAME$5 = "CaptureConsole";
const _captureConsoleIntegration = (options2 = {}) => {
  const levels = options2.levels || CONSOLE_LEVELS;
  const handled = !!options2.handled;
  return {
    name: INTEGRATION_NAME$5,
    setup(client) {
      if (!("console" in GLOBAL_OBJ)) {
        return;
      }
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient() !== client || !levels.includes(level)) {
          return;
        }
        consoleHandler(args, level, handled);
      });
    }
  };
};
const captureConsoleIntegration = defineIntegration(_captureConsoleIntegration);
function consoleHandler(args, level, handled) {
  const captureContext = {
    level: severityLevelFromString(level),
    extra: {
      arguments: args
    }
  };
  withScope((scope) => {
    scope.addEventProcessor((event) => {
      event.logger = "console";
      addExceptionMechanism(event, {
        handled,
        type: "console"
      });
      return event;
    });
    if (level === "assert") {
      if (!args[0]) {
        const message2 = `Assertion failed: ${safeJoin(args.slice(1), " ") || "console.assert"}`;
        scope.setExtra("arguments", args.slice(1));
        captureMessage(message2, captureContext);
      }
      return;
    }
    const error = args.find((arg) => arg instanceof Error);
    if (error) {
      captureException(error, captureContext);
      return;
    }
    const message = safeJoin(args, " ");
    captureMessage(message, captureContext);
  });
}
const INTEGRATION_NAME$4 = "Dedupe";
const _dedupeIntegration = () => {
  let previousEvent;
  return {
    name: INTEGRATION_NAME$4,
    processEvent(currentEvent) {
      if (currentEvent.type) {
        return currentEvent;
      }
      try {
        if (_shouldDropEvent(currentEvent, previousEvent)) {
          DEBUG_BUILD$3 && logger.warn("Event dropped due to being a duplicate of previously captured event.");
          return null;
        }
      } catch (_oO) {
      }
      return previousEvent = currentEvent;
    }
  };
};
const dedupeIntegration = defineIntegration(_dedupeIntegration);
function _shouldDropEvent(currentEvent, previousEvent) {
  if (!previousEvent) {
    return false;
  }
  if (_isSameMessageEvent(currentEvent, previousEvent)) {
    return true;
  }
  if (_isSameExceptionEvent(currentEvent, previousEvent)) {
    return true;
  }
  return false;
}
function _isSameMessageEvent(currentEvent, previousEvent) {
  const currentMessage = currentEvent.message;
  const previousMessage = previousEvent.message;
  if (!currentMessage && !previousMessage) {
    return false;
  }
  if (currentMessage && !previousMessage || !currentMessage && previousMessage) {
    return false;
  }
  if (currentMessage !== previousMessage) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameExceptionEvent(currentEvent, previousEvent) {
  const previousException = _getExceptionFromEvent(previousEvent);
  const currentException = _getExceptionFromEvent(currentEvent);
  if (!previousException || !currentException) {
    return false;
  }
  if (previousException.type !== currentException.type || previousException.value !== currentException.value) {
    return false;
  }
  if (!_isSameFingerprint(currentEvent, previousEvent)) {
    return false;
  }
  if (!_isSameStacktrace(currentEvent, previousEvent)) {
    return false;
  }
  return true;
}
function _isSameStacktrace(currentEvent, previousEvent) {
  let currentFrames = getFramesFromEvent(currentEvent);
  let previousFrames = getFramesFromEvent(previousEvent);
  if (!currentFrames && !previousFrames) {
    return true;
  }
  if (currentFrames && !previousFrames || !currentFrames && previousFrames) {
    return false;
  }
  currentFrames = currentFrames;
  previousFrames = previousFrames;
  if (previousFrames.length !== currentFrames.length) {
    return false;
  }
  for (let i2 = 0; i2 < previousFrames.length; i2++) {
    const frameA = previousFrames[i2];
    const frameB = currentFrames[i2];
    if (frameA.filename !== frameB.filename || frameA.lineno !== frameB.lineno || frameA.colno !== frameB.colno || frameA.function !== frameB.function) {
      return false;
    }
  }
  return true;
}
function _isSameFingerprint(currentEvent, previousEvent) {
  let currentFingerprint = currentEvent.fingerprint;
  let previousFingerprint = previousEvent.fingerprint;
  if (!currentFingerprint && !previousFingerprint) {
    return true;
  }
  if (currentFingerprint && !previousFingerprint || !currentFingerprint && previousFingerprint) {
    return false;
  }
  currentFingerprint = currentFingerprint;
  previousFingerprint = previousFingerprint;
  try {
    return !!(currentFingerprint.join("") === previousFingerprint.join(""));
  } catch (_oO) {
    return false;
  }
}
function _getExceptionFromEvent(event) {
  return event.exception && event.exception.values && event.exception.values[0];
}
function getBreadcrumbLogLevelFromHttpStatusCode(statusCode) {
  if (statusCode === void 0) {
    return void 0;
  } else if (statusCode >= 400 && statusCode < 500) {
    return "warning";
  } else if (statusCode >= 500) {
    return "error";
  } else {
    return void 0;
  }
}
const WINDOW$3 = GLOBAL_OBJ;
function supportsFetch() {
  if (!("fetch" in WINDOW$3)) {
    return false;
  }
  try {
    new Headers();
    new Request("http://www.example.com");
    new Response();
    return true;
  } catch (e2) {
    return false;
  }
}
function isNativeFunction(func) {
  return func && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
}
function supportsNativeFetch() {
  if (typeof EdgeRuntime === "string") {
    return true;
  }
  if (!supportsFetch()) {
    return false;
  }
  if (isNativeFunction(WINDOW$3.fetch)) {
    return true;
  }
  let result = false;
  const doc = WINDOW$3.document;
  if (doc && typeof doc.createElement === "function") {
    try {
      const sandbox = doc.createElement("iframe");
      sandbox.hidden = true;
      doc.head.appendChild(sandbox);
      if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
        result = isNativeFunction(sandbox.contentWindow.fetch);
      }
      doc.head.removeChild(sandbox);
    } catch (err) {
      DEBUG_BUILD$2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", err);
    }
  }
  return result;
}
function addFetchInstrumentationHandler(handler, skipNativeFetchCheck) {
  const type = "fetch";
  addHandler(type, handler);
  maybeInstrument(type, () => instrumentFetch(void 0, skipNativeFetchCheck));
}
function instrumentFetch(onFetchResolved, skipNativeFetchCheck = false) {
  if (skipNativeFetchCheck && !supportsNativeFetch()) {
    return;
  }
  fill(GLOBAL_OBJ, "fetch", function(originalFetch) {
    return function(...args) {
      const virtualError = new Error();
      const { method, url } = parseFetchArgs(args);
      const handlerData = {
        args,
        fetchData: {
          method,
          url
        },
        startTimestamp: timestampInSeconds() * 1e3,
        // // Adding the error to be able to fingerprint the failed fetch event in HttpClient instrumentation
        virtualError
      };
      {
        triggerHandlers("fetch", {
          ...handlerData
        });
      }
      return originalFetch.apply(GLOBAL_OBJ, args).then(
        async (response) => {
          {
            triggerHandlers("fetch", {
              ...handlerData,
              endTimestamp: timestampInSeconds() * 1e3,
              response
            });
          }
          return response;
        },
        (error) => {
          triggerHandlers("fetch", {
            ...handlerData,
            endTimestamp: timestampInSeconds() * 1e3,
            error
          });
          if (isError(error) && error.stack === void 0) {
            error.stack = virtualError.stack;
            addNonEnumerableProperty(error, "framesToPop", 1);
          }
          throw error;
        }
      );
    };
  });
}
function hasProp(obj, prop) {
  return !!obj && typeof obj === "object" && !!obj[prop];
}
function getUrlFromResource(resource) {
  if (typeof resource === "string") {
    return resource;
  }
  if (!resource) {
    return "";
  }
  if (hasProp(resource, "url")) {
    return resource.url;
  }
  if (resource.toString) {
    return resource.toString();
  }
  return "";
}
function parseFetchArgs(fetchArgs) {
  if (fetchArgs.length === 0) {
    return { method: "GET", url: "" };
  }
  if (fetchArgs.length === 2) {
    const [url, options2] = fetchArgs;
    return {
      url: getUrlFromResource(url),
      method: hasProp(options2, "method") ? String(options2.method).toUpperCase() : "GET"
    };
  }
  const arg = fetchArgs[0];
  return {
    url: getUrlFromResource(arg),
    method: hasProp(arg, "method") ? String(arg.method).toUpperCase() : "GET"
  };
}
function getSDKSource() {
  return "npm";
}
const WINDOW$2 = GLOBAL_OBJ;
function supportsHistory() {
  const chromeVar = WINDOW$2.chrome;
  const isChromePackagedApp = chromeVar && chromeVar.app && chromeVar.app.runtime;
  const hasHistoryApi = "history" in WINDOW$2 && !!WINDOW$2.history.pushState && !!WINDOW$2.history.replaceState;
  return !isChromePackagedApp && hasHistoryApi;
}
const WINDOW$1 = GLOBAL_OBJ;
let ignoreOnError = 0;
function shouldIgnoreOnError() {
  return ignoreOnError > 0;
}
function ignoreNextOnError() {
  ignoreOnError++;
  setTimeout(() => {
    ignoreOnError--;
  });
}
function wrap$4(fn2, options2 = {}) {
  function isFunction(fn22) {
    return typeof fn22 === "function";
  }
  if (!isFunction(fn2)) {
    return fn2;
  }
  try {
    const wrapper = fn2.__sentry_wrapped__;
    if (wrapper) {
      if (typeof wrapper === "function") {
        return wrapper;
      } else {
        return fn2;
      }
    }
    if (getOriginalFunction(fn2)) {
      return fn2;
    }
  } catch (e2) {
    return fn2;
  }
  const sentryWrapped = function(...args) {
    try {
      const wrappedArguments = args.map((arg) => wrap$4(arg, options2));
      return fn2.apply(this, wrappedArguments);
    } catch (ex) {
      ignoreNextOnError();
      withScope((scope) => {
        scope.addEventProcessor((event) => {
          if (options2.mechanism) {
            addExceptionTypeValue(event, void 0);
            addExceptionMechanism(event, options2.mechanism);
          }
          event.extra = {
            ...event.extra,
            arguments: args
          };
          return event;
        });
        captureException(ex);
      });
      throw ex;
    }
  };
  try {
    for (const property in fn2) {
      if (Object.prototype.hasOwnProperty.call(fn2, property)) {
        sentryWrapped[property] = fn2[property];
      }
    }
  } catch (e2) {
  }
  markFunctionWrapped(sentryWrapped, fn2);
  addNonEnumerableProperty(fn2, "__sentry_wrapped__", sentryWrapped);
  try {
    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, "name");
    if (descriptor.configurable) {
      Object.defineProperty(sentryWrapped, "name", {
        get() {
          return fn2.name;
        }
      });
    }
  } catch (e3) {
  }
  return sentryWrapped;
}
const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
function exceptionFromError(stackParser, ex) {
  const frames = parseStackFrames(stackParser, ex);
  const exception = {
    type: extractType(ex),
    value: extractMessage(ex)
  };
  if (frames.length) {
    exception.stacktrace = { frames };
  }
  if (exception.type === void 0 && exception.value === "") {
    exception.value = "Unrecoverable error caught";
  }
  return exception;
}
function eventFromPlainObject(stackParser, exception, syntheticException, isUnhandledRejection) {
  const client = getClient();
  const normalizeDepth = client && client.getOptions().normalizeDepth;
  const errorFromProp = getErrorPropertyFromObject(exception);
  const extra = {
    __serialized__: normalizeToSize(exception, normalizeDepth)
  };
  if (errorFromProp) {
    return {
      exception: {
        values: [exceptionFromError(stackParser, errorFromProp)]
      },
      extra
    };
  }
  const event = {
    exception: {
      values: [
        {
          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? "UnhandledRejection" : "Error",
          value: getNonErrorObjectExceptionValue(exception, { isUnhandledRejection })
        }
      ]
    },
    extra
  };
  if (syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception.values[0].stacktrace = { frames };
    }
  }
  return event;
}
function eventFromError(stackParser, ex) {
  return {
    exception: {
      values: [exceptionFromError(stackParser, ex)]
    }
  };
}
function parseStackFrames(stackParser, ex) {
  const stacktrace = ex.stacktrace || ex.stack || "";
  const skipLines = getSkipFirstStackStringLines(ex);
  const framesToPop = getPopFirstTopFrames(ex);
  try {
    return stackParser(stacktrace, skipLines, framesToPop);
  } catch (e2) {
  }
  return [];
}
const reactMinifiedRegexp = /Minified React error #\d+;/i;
function getSkipFirstStackStringLines(ex) {
  if (ex && reactMinifiedRegexp.test(ex.message)) {
    return 1;
  }
  return 0;
}
function getPopFirstTopFrames(ex) {
  if (typeof ex.framesToPop === "number") {
    return ex.framesToPop;
  }
  return 0;
}
function isWebAssemblyException(exception) {
  if (typeof WebAssembly !== "undefined" && typeof WebAssembly.Exception !== "undefined") {
    return exception instanceof WebAssembly.Exception;
  } else {
    return false;
  }
}
function extractType(ex) {
  const name = ex && ex.name;
  if (!name && isWebAssemblyException(ex)) {
    const hasTypeInMessage = ex.message && Array.isArray(ex.message) && ex.message.length == 2;
    return hasTypeInMessage ? ex.message[0] : "WebAssembly.Exception";
  }
  return name;
}
function extractMessage(ex) {
  const message = ex && ex.message;
  if (!message) {
    return "No error message";
  }
  if (message.error && typeof message.error.message === "string") {
    return message.error.message;
  }
  if (isWebAssemblyException(ex) && Array.isArray(ex.message) && ex.message.length == 2) {
    return ex.message[1];
  }
  return message;
}
function eventFromException(stackParser, exception, hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionMechanism(event);
  event.level = "error";
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromMessage(stackParser, message, level = "info", hint, attachStacktrace) {
  const syntheticException = hint && hint.syntheticException || void 0;
  const event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
  event.level = level;
  if (hint && hint.event_id) {
    event.event_id = hint.event_id;
  }
  return resolvedSyncPromise(event);
}
function eventFromUnknownInput(stackParser, exception, syntheticException, attachStacktrace, isUnhandledRejection) {
  let event;
  if (isErrorEvent$1(exception) && exception.error) {
    const errorEvent = exception;
    return eventFromError(stackParser, errorEvent.error);
  }
  if (isDOMError(exception) || isDOMException(exception)) {
    const domException = exception;
    if ("stack" in exception) {
      event = eventFromError(stackParser, exception);
    } else {
      const name = domException.name || (isDOMError(domException) ? "DOMError" : "DOMException");
      const message = domException.message ? `${name}: ${domException.message}` : name;
      event = eventFromString(stackParser, message, syntheticException, attachStacktrace);
      addExceptionTypeValue(event, message);
    }
    if ("code" in domException) {
      event.tags = { ...event.tags, "DOMException.code": `${domException.code}` };
    }
    return event;
  }
  if (isError(exception)) {
    return eventFromError(stackParser, exception);
  }
  if (isPlainObject$3(exception) || isEvent(exception)) {
    const objectException = exception;
    event = eventFromPlainObject(stackParser, objectException, syntheticException, isUnhandledRejection);
    addExceptionMechanism(event, {
      synthetic: true
    });
    return event;
  }
  event = eventFromString(stackParser, exception, syntheticException, attachStacktrace);
  addExceptionTypeValue(event, `${exception}`);
  addExceptionMechanism(event, {
    synthetic: true
  });
  return event;
}
function eventFromString(stackParser, message, syntheticException, attachStacktrace) {
  const event = {};
  if (attachStacktrace && syntheticException) {
    const frames = parseStackFrames(stackParser, syntheticException);
    if (frames.length) {
      event.exception = {
        values: [{ value: message, stacktrace: { frames } }]
      };
    }
    addExceptionMechanism(event, { synthetic: true });
  }
  if (isParameterizedString(message)) {
    const { __sentry_template_string__, __sentry_template_values__ } = message;
    event.logentry = {
      message: __sentry_template_string__,
      params: __sentry_template_values__
    };
    return event;
  }
  event.message = message;
  return event;
}
function getNonErrorObjectExceptionValue(exception, { isUnhandledRejection }) {
  const keys = extractExceptionKeysForMessage(exception);
  const captureType = isUnhandledRejection ? "promise rejection" : "exception";
  if (isErrorEvent$1(exception)) {
    return `Event \`ErrorEvent\` captured as ${captureType} with message \`${exception.message}\``;
  }
  if (isEvent(exception)) {
    const className = getObjectClassName(exception);
    return `Event \`${className}\` (type=${exception.type}) captured as ${captureType}`;
  }
  return `Object captured as ${captureType} with keys: ${keys}`;
}
function getObjectClassName(obj) {
  try {
    const prototype2 = Object.getPrototypeOf(obj);
    return prototype2 ? prototype2.constructor.name : void 0;
  } catch (e2) {
  }
}
function getErrorPropertyFromObject(obj) {
  for (const prop in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
      const value = obj[prop];
      if (value instanceof Error) {
        return value;
      }
    }
  }
  return void 0;
}
function createUserFeedbackEnvelope(feedback, {
  metadata,
  tunnel,
  dsn
}) {
  const headers = {
    event_id: feedback.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...metadata && metadata.sdk && {
      sdk: {
        name: metadata.sdk.name,
        version: metadata.sdk.version
      }
    },
    ...!!tunnel && !!dsn && { dsn: dsnToString(dsn) }
  };
  const item = createUserFeedbackEnvelopeItem(feedback);
  return createEnvelope(headers, [item]);
}
function createUserFeedbackEnvelopeItem(feedback) {
  const feedbackHeaders = {
    type: "user_report"
  };
  return [feedbackHeaders, feedback];
}
class BrowserClient extends BaseClient {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(options2) {
    const opts = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: true,
      ...options2
    };
    const sdkSource = WINDOW$1.SENTRY_SDK_SOURCE || getSDKSource();
    applySdkMetadata(opts, "browser", ["browser"], sdkSource);
    super(opts);
    if (opts.sendClientReports && WINDOW$1.document) {
      WINDOW$1.document.addEventListener("visibilitychange", () => {
        if (WINDOW$1.document.visibilityState === "hidden") {
          this._flushOutcomes();
        }
      });
    }
  }
  /**
   * @inheritDoc
   */
  eventFromException(exception, hint) {
    return eventFromException(this._options.stackParser, exception, hint, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(message, level = "info", hint) {
    return eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(feedback) {
    if (!this._isEnabled()) {
      DEBUG_BUILD$1 && logger.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const envelope = createUserFeedbackEnvelope(feedback, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(envelope);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(event, hint, scope) {
    event.platform = event.platform || "javascript";
    return super._prepareEvent(event, hint, scope);
  }
}
const DEBUG_BUILD = typeof __SENTRY_DEBUG__ === "undefined" || __SENTRY_DEBUG__;
const WINDOW = GLOBAL_OBJ;
const DEBOUNCE_DURATION = 1e3;
let debounceTimerID;
let lastCapturedEventType;
let lastCapturedEventTargetId;
function addClickKeypressInstrumentationHandler(handler) {
  const type = "dom";
  addHandler(type, handler);
  maybeInstrument(type, instrumentDOM);
}
function instrumentDOM() {
  if (!WINDOW.document) {
    return;
  }
  const triggerDOMHandler = triggerHandlers.bind(null, "dom");
  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
  WINDOW.document.addEventListener("click", globalDOMEventHandler, false);
  WINDOW.document.addEventListener("keypress", globalDOMEventHandler, false);
  ["EventTarget", "Node"].forEach((target) => {
    const globalObject = WINDOW;
    const targetObj = globalObject[target];
    const proto = targetObj && targetObj.prototype;
    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
      return;
    }
    fill(proto, "addEventListener", function(originalAddEventListener) {
      return function(type, listener, options2) {
        if (type === "click" || type == "keypress") {
          try {
            const handlers2 = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {};
            const handlerForType = handlers2[type] = handlers2[type] || { refCount: 0 };
            if (!handlerForType.handler) {
              const handler = makeDOMEventHandler(triggerDOMHandler);
              handlerForType.handler = handler;
              originalAddEventListener.call(this, type, handler, options2);
            }
            handlerForType.refCount++;
          } catch (e2) {
          }
        }
        return originalAddEventListener.call(this, type, listener, options2);
      };
    });
    fill(
      proto,
      "removeEventListener",
      function(originalRemoveEventListener) {
        return function(type, listener, options2) {
          if (type === "click" || type == "keypress") {
            try {
              const handlers2 = this.__sentry_instrumentation_handlers__ || {};
              const handlerForType = handlers2[type];
              if (handlerForType) {
                handlerForType.refCount--;
                if (handlerForType.refCount <= 0) {
                  originalRemoveEventListener.call(this, type, handlerForType.handler, options2);
                  handlerForType.handler = void 0;
                  delete handlers2[type];
                }
                if (Object.keys(handlers2).length === 0) {
                  delete this.__sentry_instrumentation_handlers__;
                }
              }
            } catch (e2) {
            }
          }
          return originalRemoveEventListener.call(this, type, listener, options2);
        };
      }
    );
  });
}
function isSimilarToLastCapturedEvent(event) {
  if (event.type !== lastCapturedEventType) {
    return false;
  }
  try {
    if (!event.target || event.target._sentryId !== lastCapturedEventTargetId) {
      return false;
    }
  } catch (e2) {
  }
  return true;
}
function shouldSkipDOMEvent(eventType, target) {
  if (eventType !== "keypress") {
    return false;
  }
  if (!target || !target.tagName) {
    return true;
  }
  if (target.tagName === "INPUT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
    return false;
  }
  return true;
}
function makeDOMEventHandler(handler, globalListener = false) {
  return (event) => {
    if (!event || event["_sentryCaptured"]) {
      return;
    }
    const target = getEventTarget(event);
    if (shouldSkipDOMEvent(event.type, target)) {
      return;
    }
    addNonEnumerableProperty(event, "_sentryCaptured", true);
    if (target && !target._sentryId) {
      addNonEnumerableProperty(target, "_sentryId", uuid4());
    }
    const name = event.type === "keypress" ? "input" : event.type;
    if (!isSimilarToLastCapturedEvent(event)) {
      const handlerData = { event, name, global: globalListener };
      handler(handlerData);
      lastCapturedEventType = event.type;
      lastCapturedEventTargetId = target ? target._sentryId : void 0;
    }
    clearTimeout(debounceTimerID);
    debounceTimerID = WINDOW.setTimeout(() => {
      lastCapturedEventTargetId = void 0;
      lastCapturedEventType = void 0;
    }, DEBOUNCE_DURATION);
  };
}
function getEventTarget(event) {
  try {
    return event.target;
  } catch (e2) {
    return null;
  }
}
let lastHref;
function addHistoryInstrumentationHandler(handler) {
  const type = "history";
  addHandler(type, handler);
  maybeInstrument(type, instrumentHistory);
}
function instrumentHistory() {
  if (!supportsHistory()) {
    return;
  }
  const oldOnPopState = WINDOW.onpopstate;
  WINDOW.onpopstate = function(...args) {
    const to2 = WINDOW.location.href;
    const from2 = lastHref;
    lastHref = to2;
    const handlerData = { from: from2, to: to2 };
    triggerHandlers("history", handlerData);
    if (oldOnPopState) {
      try {
        return oldOnPopState.apply(this, args);
      } catch (_oO) {
      }
    }
  };
  function historyReplacementFunction(originalHistoryFunction) {
    return function(...args) {
      const url = args.length > 2 ? args[2] : void 0;
      if (url) {
        const from2 = lastHref;
        const to2 = String(url);
        lastHref = to2;
        const handlerData = { from: from2, to: to2 };
        triggerHandlers("history", handlerData);
      }
      return originalHistoryFunction.apply(this, args);
    };
  }
  fill(WINDOW.history, "pushState", historyReplacementFunction);
  fill(WINDOW.history, "replaceState", historyReplacementFunction);
}
const cachedImplementations = {};
function getNativeImplementation(name) {
  const cached = cachedImplementations[name];
  if (cached) {
    return cached;
  }
  let impl = WINDOW[name];
  if (isNativeFunction(impl)) {
    return cachedImplementations[name] = impl.bind(WINDOW);
  }
  const document2 = WINDOW.document;
  if (document2 && typeof document2.createElement === "function") {
    try {
      const sandbox = document2.createElement("iframe");
      sandbox.hidden = true;
      document2.head.appendChild(sandbox);
      const contentWindow = sandbox.contentWindow;
      if (contentWindow && contentWindow[name]) {
        impl = contentWindow[name];
      }
      document2.head.removeChild(sandbox);
    } catch (e2) {
      DEBUG_BUILD && logger.warn(`Could not create sandbox iframe for ${name} check, bailing to window.${name}: `, e2);
    }
  }
  if (!impl) {
    return impl;
  }
  return cachedImplementations[name] = impl.bind(WINDOW);
}
function clearCachedImplementation(name) {
  cachedImplementations[name] = void 0;
}
const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
function addXhrInstrumentationHandler(handler) {
  const type = "xhr";
  addHandler(type, handler);
  maybeInstrument(type, instrumentXHR);
}
function instrumentXHR() {
  if (!WINDOW.XMLHttpRequest) {
    return;
  }
  const xhrproto = XMLHttpRequest.prototype;
  xhrproto.open = new Proxy(xhrproto.open, {
    apply(originalOpen, xhrOpenThisArg, xhrOpenArgArray) {
      const virtualError = new Error();
      const startTimestamp = timestampInSeconds() * 1e3;
      const method = isString$1(xhrOpenArgArray[0]) ? xhrOpenArgArray[0].toUpperCase() : void 0;
      const url = parseUrl(xhrOpenArgArray[1]);
      if (!method || !url) {
        return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
      }
      xhrOpenThisArg[SENTRY_XHR_DATA_KEY] = {
        method,
        url,
        request_headers: {}
      };
      if (method === "POST" && url.match(/sentry_key/)) {
        xhrOpenThisArg.__sentry_own_request__ = true;
      }
      const onreadystatechangeHandler = () => {
        const xhrInfo = xhrOpenThisArg[SENTRY_XHR_DATA_KEY];
        if (!xhrInfo) {
          return;
        }
        if (xhrOpenThisArg.readyState === 4) {
          try {
            xhrInfo.status_code = xhrOpenThisArg.status;
          } catch (e2) {
          }
          const handlerData = {
            endTimestamp: timestampInSeconds() * 1e3,
            startTimestamp,
            xhr: xhrOpenThisArg,
            virtualError
          };
          triggerHandlers("xhr", handlerData);
        }
      };
      if ("onreadystatechange" in xhrOpenThisArg && typeof xhrOpenThisArg.onreadystatechange === "function") {
        xhrOpenThisArg.onreadystatechange = new Proxy(xhrOpenThisArg.onreadystatechange, {
          apply(originalOnreadystatechange, onreadystatechangeThisArg, onreadystatechangeArgArray) {
            onreadystatechangeHandler();
            return originalOnreadystatechange.apply(onreadystatechangeThisArg, onreadystatechangeArgArray);
          }
        });
      } else {
        xhrOpenThisArg.addEventListener("readystatechange", onreadystatechangeHandler);
      }
      xhrOpenThisArg.setRequestHeader = new Proxy(xhrOpenThisArg.setRequestHeader, {
        apply(originalSetRequestHeader, setRequestHeaderThisArg, setRequestHeaderArgArray) {
          const [header, value] = setRequestHeaderArgArray;
          const xhrInfo = setRequestHeaderThisArg[SENTRY_XHR_DATA_KEY];
          if (xhrInfo && isString$1(header) && isString$1(value)) {
            xhrInfo.request_headers[header.toLowerCase()] = value;
          }
          return originalSetRequestHeader.apply(setRequestHeaderThisArg, setRequestHeaderArgArray);
        }
      });
      return originalOpen.apply(xhrOpenThisArg, xhrOpenArgArray);
    }
  });
  xhrproto.send = new Proxy(xhrproto.send, {
    apply(originalSend, sendThisArg, sendArgArray) {
      const sentryXhrData = sendThisArg[SENTRY_XHR_DATA_KEY];
      if (!sentryXhrData) {
        return originalSend.apply(sendThisArg, sendArgArray);
      }
      if (sendArgArray[0] !== void 0) {
        sentryXhrData.body = sendArgArray[0];
      }
      const handlerData = {
        startTimestamp: timestampInSeconds() * 1e3,
        xhr: sendThisArg
      };
      triggerHandlers("xhr", handlerData);
      return originalSend.apply(sendThisArg, sendArgArray);
    }
  });
}
function parseUrl(url) {
  if (isString$1(url)) {
    return url;
  }
  try {
    return url.toString();
  } catch (e2) {
  }
  return void 0;
}
function makeFetchTransport(options2, nativeFetch = getNativeImplementation("fetch")) {
  let pendingBodySize = 0;
  let pendingCount = 0;
  function makeRequest(request) {
    const requestSize = request.body.length;
    pendingBodySize += requestSize;
    pendingCount++;
    const requestOptions = {
      body: request.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: options2.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. when finishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: pendingBodySize <= 6e4 && pendingCount < 15,
      ...options2.fetchOptions
    };
    if (!nativeFetch) {
      clearCachedImplementation("fetch");
      return rejectedSyncPromise("No fetch implementation available");
    }
    try {
      return nativeFetch(options2.url, requestOptions).then((response) => {
        pendingBodySize -= requestSize;
        pendingCount--;
        return {
          statusCode: response.status,
          headers: {
            "x-sentry-rate-limits": response.headers.get("X-Sentry-Rate-Limits"),
            "retry-after": response.headers.get("Retry-After")
          }
        };
      });
    } catch (e2) {
      clearCachedImplementation("fetch");
      pendingBodySize -= requestSize;
      pendingCount--;
      return rejectedSyncPromise(e2);
    }
  }
  return createTransport(options2, makeRequest);
}
const CHROME_PRIORITY = 30;
const GECKO_PRIORITY = 50;
function createFrame(filename, func, lineno, colno) {
  const frame = {
    filename,
    function: func === "<anonymous>" ? UNKNOWN_FUNCTION : func,
    in_app: true
    // All browser frames are considered in_app
  };
  if (lineno !== void 0) {
    frame.lineno = lineno;
  }
  if (colno !== void 0) {
    frame.colno = colno;
  }
  return frame;
}
const chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i;
const chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
const chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/;
const chromeStackParserFn = (line) => {
  const noFnParts = chromeRegexNoFnName.exec(line);
  if (noFnParts) {
    const [, filename, line2, col] = noFnParts;
    return createFrame(filename, UNKNOWN_FUNCTION, +line2, +col);
  }
  const parts = chromeRegex.exec(line);
  if (parts) {
    const isEval = parts[2] && parts[2].indexOf("eval") === 0;
    if (isEval) {
      const subMatch = chromeEvalRegex.exec(parts[2]);
      if (subMatch) {
        parts[2] = subMatch[1];
        parts[3] = subMatch[2];
        parts[4] = subMatch[3];
      }
    }
    const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);
    return createFrame(filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);
  }
  return;
};
const chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn];
const geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
const geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
const gecko = (line) => {
  const parts = geckoREgex.exec(line);
  if (parts) {
    const isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
    if (isEval) {
      const subMatch = geckoEvalRegex.exec(parts[3]);
      if (subMatch) {
        parts[1] = parts[1] || "eval";
        parts[3] = subMatch[1];
        parts[4] = subMatch[2];
        parts[5] = "";
      }
    }
    let filename = parts[3];
    let func = parts[1] || UNKNOWN_FUNCTION;
    [func, filename] = extractSafariExtensionDetails(func, filename);
    return createFrame(filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);
  }
  return;
};
const geckoStackLineParser = [GECKO_PRIORITY, gecko];
const defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser];
const defaultStackParser = createStackParser(...defaultStackLineParsers);
const extractSafariExtensionDetails = (func, filename) => {
  const isSafariExtension = func.indexOf("safari-extension") !== -1;
  const isSafariWebExtension = func.indexOf("safari-web-extension") !== -1;
  return isSafariExtension || isSafariWebExtension ? [
    func.indexOf("@") !== -1 ? func.split("@")[0] : UNKNOWN_FUNCTION,
    isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`
  ] : [func, filename];
};
const MAX_ALLOWED_STRING_LENGTH = 1024;
const INTEGRATION_NAME$3 = "Breadcrumbs";
const _breadcrumbsIntegration = (options2 = {}) => {
  const _options = {
    console: true,
    dom: true,
    fetch: true,
    history: true,
    sentry: true,
    xhr: true,
    ...options2
  };
  return {
    name: INTEGRATION_NAME$3,
    setup(client) {
      if (_options.console) {
        addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(client));
      }
      if (_options.dom) {
        addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(client, _options.dom));
      }
      if (_options.xhr) {
        addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(client));
      }
      if (_options.fetch) {
        addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(client));
      }
      if (_options.history) {
        addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(client));
      }
      if (_options.sentry) {
        client.on("beforeSendEvent", _getSentryBreadcrumbHandler(client));
      }
    }
  };
};
const breadcrumbsIntegration = defineIntegration(_breadcrumbsIntegration);
function _getSentryBreadcrumbHandler(client) {
  return function addSentryBreadcrumb(event) {
    if (getClient() !== client) {
      return;
    }
    addBreadcrumb(
      {
        category: `sentry.${event.type === "transaction" ? "transaction" : "event"}`,
        event_id: event.event_id,
        level: event.level,
        message: getEventDescription(event)
      },
      {
        event
      }
    );
  };
}
function _getDomBreadcrumbHandler(client, dom) {
  return function _innerDomBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let target;
    let componentName;
    let keyAttrs = typeof dom === "object" ? dom.serializeAttribute : void 0;
    let maxStringLength = typeof dom === "object" && typeof dom.maxStringLength === "number" ? dom.maxStringLength : void 0;
    if (maxStringLength && maxStringLength > MAX_ALLOWED_STRING_LENGTH) {
      DEBUG_BUILD$1 && logger.warn(
        `\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${maxStringLength} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`
      );
      maxStringLength = MAX_ALLOWED_STRING_LENGTH;
    }
    if (typeof keyAttrs === "string") {
      keyAttrs = [keyAttrs];
    }
    try {
      const event = handlerData.event;
      const element = _isEvent(event) ? event.target : event;
      target = htmlTreeAsString(element, { keyAttrs, maxStringLength });
      componentName = getComponentName(element);
    } catch (e2) {
      target = "<unknown>";
    }
    if (target.length === 0) {
      return;
    }
    const breadcrumb = {
      category: `ui.${handlerData.name}`,
      message: target
    };
    if (componentName) {
      breadcrumb.data = { "ui.component_name": componentName };
    }
    addBreadcrumb(breadcrumb, {
      event: handlerData.event,
      name: handlerData.name,
      global: handlerData.global
    });
  };
}
function _getConsoleBreadcrumbHandler(client) {
  return function _consoleBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const breadcrumb = {
      category: "console",
      data: {
        arguments: handlerData.args,
        logger: "console"
      },
      level: severityLevelFromString(handlerData.level),
      message: safeJoin(handlerData.args, " ")
    };
    if (handlerData.level === "assert") {
      if (handlerData.args[0] === false) {
        breadcrumb.message = `Assertion failed: ${safeJoin(handlerData.args.slice(1), " ") || "console.assert"}`;
        breadcrumb.data.arguments = handlerData.args.slice(1);
      } else {
        return;
      }
    }
    addBreadcrumb(breadcrumb, {
      input: handlerData.args,
      level: handlerData.level
    });
  };
}
function _getXhrBreadcrumbHandler(client) {
  return function _xhrBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    const sentryXhrData = handlerData.xhr[SENTRY_XHR_DATA_KEY];
    if (!startTimestamp || !endTimestamp || !sentryXhrData) {
      return;
    }
    const { method, url, status_code, body } = sentryXhrData;
    const data = {
      method,
      url,
      status_code
    };
    const hint = {
      xhr: handlerData.xhr,
      input: body,
      startTimestamp,
      endTimestamp
    };
    const level = getBreadcrumbLogLevelFromHttpStatusCode(status_code);
    addBreadcrumb(
      {
        category: "xhr",
        data,
        type: "http",
        level
      },
      hint
    );
  };
}
function _getFetchBreadcrumbHandler(client) {
  return function _fetchBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    const { startTimestamp, endTimestamp } = handlerData;
    if (!endTimestamp) {
      return;
    }
    if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === "POST") {
      return;
    }
    if (handlerData.error) {
      const data = handlerData.fetchData;
      const hint = {
        data: handlerData.error,
        input: handlerData.args,
        startTimestamp,
        endTimestamp
      };
      addBreadcrumb(
        {
          category: "fetch",
          data,
          level: "error",
          type: "http"
        },
        hint
      );
    } else {
      const response = handlerData.response;
      const data = {
        ...handlerData.fetchData,
        status_code: response && response.status
      };
      const hint = {
        input: handlerData.args,
        response,
        startTimestamp,
        endTimestamp
      };
      const level = getBreadcrumbLogLevelFromHttpStatusCode(data.status_code);
      addBreadcrumb(
        {
          category: "fetch",
          data,
          type: "http",
          level
        },
        hint
      );
    }
  };
}
function _getHistoryBreadcrumbHandler(client) {
  return function _historyBreadcrumb(handlerData) {
    if (getClient() !== client) {
      return;
    }
    let from2 = handlerData.from;
    let to2 = handlerData.to;
    const parsedLoc = parseUrl$1(WINDOW$1.location.href);
    let parsedFrom = from2 ? parseUrl$1(from2) : void 0;
    const parsedTo = parseUrl$1(to2);
    if (!parsedFrom || !parsedFrom.path) {
      parsedFrom = parsedLoc;
    }
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
      to2 = parsedTo.relative;
    }
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
      from2 = parsedFrom.relative;
    }
    addBreadcrumb({
      category: "navigation",
      data: {
        from: from2,
        to: to2
      }
    });
  };
}
function _isEvent(event) {
  return !!event && !!event.target;
}
const DEFAULT_EVENT_TARGET = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
];
const INTEGRATION_NAME$2 = "BrowserApiErrors";
const _browserApiErrorsIntegration = (options2 = {}) => {
  const _options = {
    XMLHttpRequest: true,
    eventTarget: true,
    requestAnimationFrame: true,
    setInterval: true,
    setTimeout: true,
    ...options2
  };
  return {
    name: INTEGRATION_NAME$2,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      if (_options.setTimeout) {
        fill(WINDOW$1, "setTimeout", _wrapTimeFunction);
      }
      if (_options.setInterval) {
        fill(WINDOW$1, "setInterval", _wrapTimeFunction);
      }
      if (_options.requestAnimationFrame) {
        fill(WINDOW$1, "requestAnimationFrame", _wrapRAF);
      }
      if (_options.XMLHttpRequest && "XMLHttpRequest" in WINDOW$1) {
        fill(XMLHttpRequest.prototype, "send", _wrapXHR);
      }
      const eventTargetOption = _options.eventTarget;
      if (eventTargetOption) {
        const eventTarget = Array.isArray(eventTargetOption) ? eventTargetOption : DEFAULT_EVENT_TARGET;
        eventTarget.forEach(_wrapEventTarget);
      }
    }
  };
};
const browserApiErrorsIntegration = defineIntegration(_browserApiErrorsIntegration);
function _wrapTimeFunction(original) {
  return function(...args) {
    const originalCallback = args[0];
    args[0] = wrap$4(originalCallback, {
      mechanism: {
        data: { function: getFunctionName(original) },
        handled: false,
        type: "instrument"
      }
    });
    return original.apply(this, args);
  };
}
function _wrapRAF(original) {
  return function(callback) {
    return original.apply(this, [
      wrap$4(callback, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: getFunctionName(original)
          },
          handled: false,
          type: "instrument"
        }
      })
    ]);
  };
}
function _wrapXHR(originalSend) {
  return function(...args) {
    const xhr = this;
    const xmlHttpRequestProps = ["onload", "onerror", "onprogress", "onreadystatechange"];
    xmlHttpRequestProps.forEach((prop) => {
      if (prop in xhr && typeof xhr[prop] === "function") {
        fill(xhr, prop, function(original) {
          const wrapOptions = {
            mechanism: {
              data: {
                function: prop,
                handler: getFunctionName(original)
              },
              handled: false,
              type: "instrument"
            }
          };
          const originalFunction = getOriginalFunction(original);
          if (originalFunction) {
            wrapOptions.mechanism.data.handler = getFunctionName(originalFunction);
          }
          return wrap$4(original, wrapOptions);
        });
      }
    });
    return originalSend.apply(this, args);
  };
}
function _wrapEventTarget(target) {
  const globalObject = WINDOW$1;
  const targetObj = globalObject[target];
  const proto = targetObj && targetObj.prototype;
  if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty("addEventListener")) {
    return;
  }
  fill(proto, "addEventListener", function(original) {
    return function(eventName, fn2, options2) {
      try {
        if (isEventListenerObject(fn2)) {
          fn2.handleEvent = wrap$4(fn2.handleEvent, {
            mechanism: {
              data: {
                function: "handleEvent",
                handler: getFunctionName(fn2),
                target
              },
              handled: false,
              type: "instrument"
            }
          });
        }
      } catch (e2) {
      }
      return original.apply(this, [
        eventName,
        wrap$4(fn2, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: getFunctionName(fn2),
              target
            },
            handled: false,
            type: "instrument"
          }
        }),
        options2
      ]);
    };
  });
  fill(proto, "removeEventListener", function(originalRemoveEventListener) {
    return function(eventName, fn2, options2) {
      try {
        const originalEventHandler = fn2.__sentry_wrapped__;
        if (originalEventHandler) {
          originalRemoveEventListener.call(this, eventName, originalEventHandler, options2);
        }
      } catch (e2) {
      }
      return originalRemoveEventListener.call(this, eventName, fn2, options2);
    };
  });
}
function isEventListenerObject(obj) {
  return typeof obj.handleEvent === "function";
}
const browserSessionIntegration = defineIntegration(() => {
  return {
    name: "BrowserSession",
    setupOnce() {
      if (typeof WINDOW$1.document === "undefined") {
        DEBUG_BUILD$1 && logger.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
        return;
      }
      startSession({ ignoreDuration: true });
      captureSession();
      addHistoryInstrumentationHandler(({ from: from2, to: to2 }) => {
        if (from2 !== void 0 && from2 !== to2) {
          startSession({ ignoreDuration: true });
          captureSession();
        }
      });
    }
  };
});
const INTEGRATION_NAME$1 = "GlobalHandlers";
const _globalHandlersIntegration = (options2 = {}) => {
  const _options = {
    onerror: true,
    onunhandledrejection: true,
    ...options2
  };
  return {
    name: INTEGRATION_NAME$1,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(client) {
      if (_options.onerror) {
        _installGlobalOnErrorHandler(client);
        globalHandlerLog("onerror");
      }
      if (_options.onunhandledrejection) {
        _installGlobalOnUnhandledRejectionHandler(client);
        globalHandlerLog("onunhandledrejection");
      }
    }
  };
};
const globalHandlersIntegration = defineIntegration(_globalHandlersIntegration);
function _installGlobalOnErrorHandler(client) {
  addGlobalErrorInstrumentationHandler((data) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const { msg, url, line, column, error } = data;
    const event = _enhanceEventWithInitialFrame(
      eventFromUnknownInput(stackParser, error || msg, void 0, attachStacktrace, false),
      url,
      line,
      column
    );
    event.level = "error";
    captureEvent(event, {
      originalException: error,
      mechanism: {
        handled: false,
        type: "onerror"
      }
    });
  });
}
function _installGlobalOnUnhandledRejectionHandler(client) {
  addGlobalUnhandledRejectionInstrumentationHandler((e2) => {
    const { stackParser, attachStacktrace } = getOptions();
    if (getClient() !== client || shouldIgnoreOnError()) {
      return;
    }
    const error = _getUnhandledRejectionError(e2);
    const event = isPrimitive(error) ? _eventFromRejectionWithPrimitive(error) : eventFromUnknownInput(stackParser, error, void 0, attachStacktrace, true);
    event.level = "error";
    captureEvent(event, {
      originalException: error,
      mechanism: {
        handled: false,
        type: "onunhandledrejection"
      }
    });
  });
}
function _getUnhandledRejectionError(error) {
  if (isPrimitive(error)) {
    return error;
  }
  try {
    if ("reason" in error) {
      return error.reason;
    }
    if ("detail" in error && "reason" in error.detail) {
      return error.detail.reason;
    }
  } catch (e2) {
  }
  return error;
}
function _eventFromRejectionWithPrimitive(reason) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(reason)}`
        }
      ]
    }
  };
}
function _enhanceEventWithInitialFrame(event, url, line, column) {
  const e2 = event.exception = event.exception || {};
  const ev = e2.values = e2.values || [];
  const ev0 = ev[0] = ev[0] || {};
  const ev0s = ev0.stacktrace = ev0.stacktrace || {};
  const ev0sf = ev0s.frames = ev0s.frames || [];
  const colno = column;
  const lineno = line;
  const filename = isString$1(url) && url.length > 0 ? url : getLocationHref();
  if (ev0sf.length === 0) {
    ev0sf.push({
      colno,
      filename,
      function: UNKNOWN_FUNCTION,
      in_app: true,
      lineno
    });
  }
  return event;
}
function globalHandlerLog(type) {
  DEBUG_BUILD$1 && logger.log(`Global Handler attached: ${type}`);
}
function getOptions() {
  const client = getClient();
  const options2 = client && client.getOptions() || {
    stackParser: () => [],
    attachStacktrace: false
  };
  return options2;
}
const httpContextIntegration = defineIntegration(() => {
  return {
    name: "HttpContext",
    preprocessEvent(event) {
      if (!WINDOW$1.navigator && !WINDOW$1.location && !WINDOW$1.document) {
        return;
      }
      const url = event.request && event.request.url || WINDOW$1.location && WINDOW$1.location.href;
      const { referrer } = WINDOW$1.document || {};
      const { userAgent } = WINDOW$1.navigator || {};
      const headers = {
        ...event.request && event.request.headers,
        ...referrer && { Referer: referrer },
        ...userAgent && { "User-Agent": userAgent }
      };
      const request = { ...event.request, ...url && { url }, headers };
      event.request = request;
    }
  };
});
const DEFAULT_KEY = "cause";
const DEFAULT_LIMIT = 5;
const INTEGRATION_NAME = "LinkedErrors";
const _linkedErrorsIntegration = (options2 = {}) => {
  const limit = options2.limit || DEFAULT_LIMIT;
  const key = options2.key || DEFAULT_KEY;
  return {
    name: INTEGRATION_NAME,
    preprocessEvent(event, hint, client) {
      const options22 = client.getOptions();
      applyAggregateErrorsToEvent(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        exceptionFromError,
        options22.stackParser,
        options22.maxValueLength,
        key,
        limit,
        event,
        hint
      );
    }
  };
};
const linkedErrorsIntegration = defineIntegration(_linkedErrorsIntegration);
function getDefaultIntegrations(options2) {
  const integrations = [
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    browserApiErrorsIntegration(),
    breadcrumbsIntegration(),
    globalHandlersIntegration(),
    linkedErrorsIntegration(),
    dedupeIntegration(),
    httpContextIntegration()
  ];
  if (options2.autoSessionTracking !== false) {
    integrations.push(browserSessionIntegration());
  }
  return integrations;
}
function applyDefaultOptions(optionsArg = {}) {
  const defaultOptions2 = {
    defaultIntegrations: getDefaultIntegrations(optionsArg),
    release: typeof __SENTRY_RELEASE__ === "string" ? __SENTRY_RELEASE__ : WINDOW$1.SENTRY_RELEASE && WINDOW$1.SENTRY_RELEASE.id ? WINDOW$1.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: true,
    sendClientReports: true
  };
  if (optionsArg.defaultIntegrations == null) {
    delete optionsArg.defaultIntegrations;
  }
  return { ...defaultOptions2, ...optionsArg };
}
function shouldShowBrowserExtensionError() {
  const windowWithMaybeExtension = typeof WINDOW$1.window !== "undefined" && WINDOW$1;
  if (!windowWithMaybeExtension) {
    return false;
  }
  const extensionKey = windowWithMaybeExtension.chrome ? "chrome" : "browser";
  const extensionObject = windowWithMaybeExtension[extensionKey];
  const runtimeId = extensionObject && extensionObject.runtime && extensionObject.runtime.id;
  const href = WINDOW$1.location && WINDOW$1.location.href || "";
  const extensionProtocols = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"];
  const isDedicatedExtensionPage = !!runtimeId && WINDOW$1 === WINDOW$1.top && extensionProtocols.some((protocol) => href.startsWith(`${protocol}//`));
  const isNWjs = typeof windowWithMaybeExtension.nw !== "undefined";
  return !!runtimeId && !isDedicatedExtensionPage && !isNWjs;
}
function init$1(browserOptions = {}) {
  const options2 = applyDefaultOptions(browserOptions);
  if (!options2.skipBrowserExtensionCheck && shouldShowBrowserExtensionError()) {
    consoleSandbox(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  if (DEBUG_BUILD$1) {
    if (!supportsFetch()) {
      logger.warn(
        "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
      );
    }
  }
  const clientOptions = {
    ...options2,
    stackParser: stackParserFromStackParserOptions(options2.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup(options2),
    transport: options2.transport || makeFetchTransport
  };
  return initAndBind(BrowserClient, clientOptions);
}
function init(options2) {
  const opts = {
    ...options2
  };
  applySdkMetadata(opts, "react");
  setContext$1("react", { version: reactExports.version });
  return init$1(opts);
}
var e$5, t$5 = "undefined" != typeof window ? window : void 0, i$7 = "undefined" != typeof globalThis ? globalThis : t$5, n$7 = Array.prototype, r$4 = n$7.forEach, s$8 = n$7.indexOf, o$7 = null == i$7 ? void 0 : i$7.navigator, a$a = null == i$7 ? void 0 : i$7.document, l$5 = null == i$7 ? void 0 : i$7.location, u$8 = null == i$7 ? void 0 : i$7.fetch, c$5 = null != i$7 && i$7.XMLHttpRequest && "withCredentials" in new i$7.XMLHttpRequest() ? i$7.XMLHttpRequest : void 0, d$6 = null == i$7 ? void 0 : i$7.AbortController, h$5 = null == o$7 ? void 0 : o$7.userAgent, _$4 = null != t$5 ? t$5 : {}, p$5 = { DEBUG: false, LIB_VERSION: "1.205.0" }, v$3 = "$copy_autocapture", g$2 = ["$snapshot", "$pageview", "$pageleave", "$set", "survey dismissed", "survey sent", "survey shown", "$identify", "$groupidentify", "$create_alias", "$$client_ingestion_warning", "$web_experiment_applied", "$feature_enrollment_update", "$feature_flag_called"];
!function(e2) {
  e2.GZipJS = "gzip-js", e2.Base64 = "base64";
}(e$5 || (e$5 = {}));
function m$5(e2, t2) {
  return -1 !== e2.indexOf(t2);
}
var b$5 = function(e2) {
  return e2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}, y$5 = function(e2) {
  return e2.replace(/^\$/, "");
};
var w$5 = Array.isArray, S$4 = Object.prototype, E$4 = S$4.hasOwnProperty, k$1 = S$4.toString, x$3 = w$5 || function(e2) {
  return "[object Array]" === k$1.call(e2);
}, I$4 = (e2) => "function" == typeof e2, C$4 = (e2) => e2 === Object(e2) && !x$3(e2), P$5 = (e2) => {
  if (C$4(e2)) {
    for (var t2 in e2) if (E$4.call(e2, t2)) return false;
    return true;
  }
  return false;
}, F$4 = (e2) => void 0 === e2, R$4 = (e2) => "[object String]" == k$1.call(e2), T$5 = (e2) => R$4(e2) && 0 === e2.trim().length, $$3 = (e2) => null === e2, O$5 = (e2) => F$4(e2) || $$3(e2), M$5 = (e2) => "[object Number]" == k$1.call(e2), L$3 = (e2) => "[object Boolean]" === k$1.call(e2), A$4 = (e2) => e2 instanceof FormData, D$3 = (e2) => m$5(g$2, e2), N$2 = (e2) => {
  var i2 = { _log: function(i3) {
    if (t$5 && (p$5.DEBUG || _$4.POSTHOG_DEBUG) && !F$4(t$5.console) && t$5.console) {
      for (var n2 = ("__rrweb_original__" in t$5.console[i3]) ? t$5.console[i3].__rrweb_original__ : t$5.console[i3], r2 = arguments.length, s2 = new Array(r2 > 1 ? r2 - 1 : 0), o22 = 1; o22 < r2; o22++) s2[o22 - 1] = arguments[o22];
      n2(e2, ...s2);
    }
  }, info: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i2._log("log", ...t2);
  }, warn: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i2._log("warn", ...t2);
  }, error: function() {
    for (var e3 = arguments.length, t2 = new Array(e3), n2 = 0; n2 < e3; n2++) t2[n2] = arguments[n2];
    i2._log("error", ...t2);
  }, critical: function() {
    for (var t2 = arguments.length, i3 = new Array(t2), n2 = 0; n2 < t2; n2++) i3[n2] = arguments[n2];
    console.error(e2, ...i3);
  }, uninitializedWarning: (e3) => {
    i2.error("You must initialize PostHog before calling ".concat(e3));
  }, createLogger: (t2) => N$2("".concat(e2, " ").concat(t2)) };
  return i2;
}, q$2 = N$2("[PostHog.js]"), B$1 = q$2.createLogger, H$4 = B$1("[ExternalScriptsLoader]"), U$4 = (e2, t2, i2) => {
  if (e2.config.disable_external_dependency_loading) return H$4.warn("".concat(t2, " was requested but loading of external scripts is disabled.")), i2("Loading of external scripts is disabled");
  var n2 = () => {
    if (!a$a) return i2("document not found");
    var n3 = a$a.createElement("script");
    if (n3.type = "text/javascript", n3.crossOrigin = "anonymous", n3.src = t2, n3.onload = (e3) => i2(void 0, e3), n3.onerror = (e3) => i2(e3), e2.config.prepare_external_dependency_script && (n3 = e2.config.prepare_external_dependency_script(n3)), !n3) return i2("prepare_external_dependency_script returned null");
    var r2, s2 = a$a.querySelectorAll("body > script");
    s2.length > 0 ? null === (r2 = s2[0].parentNode) || void 0 === r2 || r2.insertBefore(n3, s2[0]) : a$a.body.appendChild(n3);
  };
  null != a$a && a$a.body ? n2() : null == a$a || a$a.addEventListener("DOMContentLoaded", n2);
};
function z$1(e2, t2) {
  var i2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var n2 = Object.getOwnPropertySymbols(e2);
    t2 && (n2 = n2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), i2.push.apply(i2, n2);
  }
  return i2;
}
function j$5(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var i2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? z$1(Object(i2), true).forEach(function(t3) {
      W$3(e2, t3, i2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(i2)) : z$1(Object(i2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(i2, t3));
    });
  }
  return e2;
}
function W$3(e2, t2, i2) {
  return t2 in e2 ? Object.defineProperty(e2, t2, { value: i2, enumerable: true, configurable: true, writable: true }) : e2[t2] = i2, e2;
}
function V$3(e2, t2) {
  if (null == e2) return {};
  var i2, n2, r2 = function(e3, t3) {
    if (null == e3) return {};
    var i3, n3, r3 = {}, s3 = Object.keys(e3);
    for (n3 = 0; n3 < s3.length; n3++) i3 = s3[n3], t3.indexOf(i3) >= 0 || (r3[i3] = e3[i3]);
    return r3;
  }(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var s2 = Object.getOwnPropertySymbols(e2);
    for (n2 = 0; n2 < s2.length; n2++) i2 = s2[n2], t2.indexOf(i2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, i2) && (r2[i2] = e2[i2]);
  }
  return r2;
}
_$4.__PosthogExtensions__ = _$4.__PosthogExtensions__ || {}, _$4.__PosthogExtensions__.loadExternalDependency = (e2, t2, i2) => {
  var n2 = "/static/".concat(t2, ".js") + "?v=".concat(e2.version);
  if ("remote-config" === t2 && (n2 = "/array/".concat(e2.config.token, "/config.js")), "toolbar" === t2) {
    var r2 = 3e5, s2 = Math.floor(Date.now() / r2) * r2;
    n2 = "".concat(n2, "&t=").concat(s2);
  }
  var o22 = e2.requestRouter.endpointFor("assets", n2);
  U$4(e2, o22, i2);
}, _$4.__PosthogExtensions__.loadSiteApp = (e2, t2, i2) => {
  var n2 = e2.requestRouter.endpointFor("api", t2);
  U$4(e2, n2, i2);
};
var G$2 = {};
function J$4(e2, t2, i2) {
  if (x$3(e2)) {
    if (r$4 && e2.forEach === r$4) e2.forEach(t2, i2);
    else if ("length" in e2 && e2.length === +e2.length) {
      for (var n2 = 0, s2 = e2.length; n2 < s2; n2++) if (n2 in e2 && t2.call(i2, e2[n2], n2) === G$2) return;
    }
  }
}
function Y$2(e2, t2, i2) {
  if (!O$5(e2)) {
    if (x$3(e2)) return J$4(e2, t2, i2);
    if (A$4(e2)) {
      for (var n2 of e2.entries()) if (t2.call(i2, n2[1], n2[0]) === G$2) return;
    } else for (var r2 in e2) if (E$4.call(e2, r2) && t2.call(i2, e2[r2], r2) === G$2) return;
  }
}
var K$2 = function(e2) {
  for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
  return J$4(i2, function(t3) {
    for (var i3 in t3) void 0 !== t3[i3] && (e2[i3] = t3[i3]);
  }), e2;
};
function X$4(e2) {
  for (var t2 = Object.keys(e2), i2 = t2.length, n2 = new Array(i2); i2--; ) n2[i2] = [t2[i2], e2[t2[i2]]];
  return n2;
}
var Q$2 = function(e2) {
  try {
    return e2();
  } catch (e3) {
    return;
  }
}, Z$2 = function(e2) {
  return function() {
    try {
      for (var t2 = arguments.length, i2 = new Array(t2), n2 = 0; n2 < t2; n2++) i2[n2] = arguments[n2];
      return e2.apply(this, i2);
    } catch (e3) {
      q$2.critical("Implementation error. Please turn on debug mode and open a ticket on https://app.posthog.com/home#panel=support%3Asupport%3A."), q$2.critical(e3);
    }
  };
}, ee$2 = function(e2) {
  var t2 = {};
  return Y$2(e2, function(e3, i2) {
    R$4(e3) && e3.length > 0 && (t2[i2] = e3);
  }), t2;
};
function te$2(e2, t2) {
  return i2 = e2, n2 = (e3) => R$4(e3) && !$$3(t2) ? e3.slice(0, t2) : e3, r2 = /* @__PURE__ */ new Set(), function e3(t3, i3) {
    return t3 !== Object(t3) ? n2 ? n2(t3, i3) : t3 : r2.has(t3) ? void 0 : (r2.add(t3), x$3(t3) ? (s2 = [], J$4(t3, (t4) => {
      s2.push(e3(t4));
    })) : (s2 = {}, Y$2(t3, (t4, i4) => {
      r2.has(t4) || (s2[i4] = e3(t4, i4));
    })), s2);
    var s2;
  }(i2);
  var i2, n2, r2;
}
var ie$1 = function() {
  function e2(t2) {
    return t2 && (t2.preventDefault = e2.preventDefault, t2.stopPropagation = e2.stopPropagation), t2;
  }
  return e2.preventDefault = function() {
    this.returnValue = false;
  }, e2.stopPropagation = function() {
    this.cancelBubble = true;
  }, function(i2, n2, r2, s2, o22) {
    if (i2) if (i2.addEventListener && !s2) i2.addEventListener(n2, r2, !!o22);
    else {
      var a22 = "on" + n2, l22 = i2[a22];
      i2[a22] = /* @__PURE__ */ function(i3, n3, r3) {
        return function(s3) {
          if (s3 = s3 || e2(null == t$5 ? void 0 : t$5.event)) {
            var o3, a3 = true;
            I$4(r3) && (o3 = r3(s3));
            var l3 = n3.call(i3, s3);
            return false !== o3 && false !== l3 || (a3 = false), a3;
          }
        };
      }(i2, r2, l22);
    }
    else q$2.error("No valid element provided to register_event");
  };
}();
function ne$1(e2, t2) {
  for (var i2 = 0; i2 < e2.length; i2++) if (t2(e2[i2])) return e2[i2];
}
var re$2 = "$people_distinct_id", se$2 = "__alias", oe$1 = "__timers", ae = "$autocapture_disabled_server_side", le$1 = "$heatmaps_enabled_server_side", ue$3 = "$exception_capture_enabled_server_side", ce$1 = "$web_vitals_enabled_server_side", de$2 = "$dead_clicks_enabled_server_side", he$1 = "$web_vitals_allowed_metrics", _e$1 = "$session_recording_enabled_server_side", pe$2 = "$console_log_recording_enabled_server_side", ve$1 = "$session_recording_network_payload_capture", ge$2 = "$session_recording_canvas_recording", fe$2 = "$replay_sample_rate", me$1 = "$replay_minimum_duration", be$3 = "$replay_script_config", ye$2 = "$sesid", we = "$session_is_sampled", Se$1 = "$session_recording_url_trigger_activated_session", Ee$2 = "$session_recording_event_trigger_activated_session", ke = "$enabled_feature_flags", xe$2 = "$early_access_features", Ie$2 = "$stored_person_properties", Ce = "$stored_group_properties", Pe = "$surveys", Fe$2 = "$surveys_activated", Re$2 = "$flag_call_reported", Te$2 = "$user_state", $e = "$client_session_props", Oe$1 = "$capture_rate_limit", Me$2 = "$initial_campaign_params", Le$1 = "$initial_referrer_info", Ae$2 = "$initial_person_info", De$1 = "$epp", Ne = "__POSTHOG_TOOLBAR__", qe = "$posthog_cklsh", Be = [re$2, se$2, "__cmpns", oe$1, _e$1, le$1, ye$2, ke, Te$2, xe$2, Ce, Ie$2, Pe, Re$2, $e, Oe$1, Me$2, Le$1, De$1], He$1 = B$1("[FeatureFlags]"), Ue = "$active_feature_flags", ze$1 = "$override_feature_flags", je = "$feature_flag_payloads", We = (e2) => {
  var t2 = {};
  for (var [i2, n2] of X$4(e2 || {})) n2 && (t2[i2] = n2);
  return t2;
};
class Ve {
  constructor(e2) {
    W$3(this, "_override_warning", false), W$3(this, "_hasLoadedFlags", false), W$3(this, "_requestInFlight", false), W$3(this, "_reloadingDisabled", false), W$3(this, "_additionalReloadRequested", false), W$3(this, "_decideCalled", false), W$3(this, "_flagsLoadedFromRemote", false), this.instance = e2, this.featureFlagEventHandlers = [];
  }
  decide() {
    if (this.instance.config.__preview_remote_config) this._decideCalled = true;
    else {
      var e2 = !this._reloadDebouncer && (this.instance.config.advanced_disable_feature_flags || this.instance.config.advanced_disable_feature_flags_on_first_load);
      this._callDecideEndpoint({ disableFlags: e2 });
    }
  }
  get hasLoadedFlags() {
    return this._hasLoadedFlags;
  }
  getFlags() {
    return Object.keys(this.getFlagVariants());
  }
  getFlagVariants() {
    var e2 = this.instance.get_property(ke), t2 = this.instance.get_property(ze$1);
    if (!t2) return e2 || {};
    for (var i2 = K$2({}, e2), n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++) i2[n2[r2]] = t2[n2[r2]];
    return this._override_warning || (He$1.warn(" Overriding feature flags!", { enabledFlags: e2, overriddenFlags: t2, finalFlags: i2 }), this._override_warning = true), i2;
  }
  getFlagPayloads() {
    return this.instance.get_property(je) || {};
  }
  reloadFeatureFlags() {
    this._reloadingDisabled || this.instance.config.advanced_disable_feature_flags || this._reloadDebouncer || (this._reloadDebouncer = setTimeout(() => {
      this._callDecideEndpoint();
    }, 5));
  }
  clearDebouncer() {
    clearTimeout(this._reloadDebouncer), this._reloadDebouncer = void 0;
  }
  ensureFlagsLoaded() {
    this._hasLoadedFlags || this._requestInFlight || this._reloadDebouncer || this.reloadFeatureFlags();
  }
  setAnonymousDistinctId(e2) {
    this.$anon_distinct_id = e2;
  }
  setReloadingPaused(e2) {
    this._reloadingDisabled = e2;
  }
  _callDecideEndpoint(t2) {
    if (this.clearDebouncer(), !this.instance.config.advanced_disable_decide) if (this._requestInFlight) this._additionalReloadRequested = true;
    else {
      var i2 = { token: this.instance.config.token, distinct_id: this.instance.get_distinct_id(), groups: this.instance.getGroups(), $anon_distinct_id: this.$anon_distinct_id, person_properties: this.instance.get_property(Ie$2), group_properties: this.instance.get_property(Ce) };
      (null != t2 && t2.disableFlags || this.instance.config.advanced_disable_feature_flags) && (i2.disable_flags = true), this._requestInFlight = true, this.instance._send_request({ method: "POST", url: this.instance.requestRouter.endpointFor("api", "/decide/?v=3"), data: i2, compression: this.instance.config.disable_compression ? void 0 : e$5.Base64, timeout: this.instance.config.feature_flag_request_timeout_ms, callback: (e2) => {
        var t3, n2, r2 = true;
        (200 === e2.statusCode && (this.$anon_distinct_id = void 0, r2 = false), this._requestInFlight = false, this._decideCalled) || (this._decideCalled = true, this.instance._onRemoteConfig(null !== (n2 = e2.json) && void 0 !== n2 ? n2 : {}));
        i2.disable_flags || (this._flagsLoadedFromRemote = !r2, this.receivedFeatureFlags(null !== (t3 = e2.json) && void 0 !== t3 ? t3 : {}, r2), this._additionalReloadRequested && (this._additionalReloadRequested = false, this._callDecideEndpoint()));
      } });
    }
  }
  getFeatureFlag(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) {
      var i2, n2, r2, s2, o22, a22 = this.getFlagVariants()[e2], l22 = "".concat(a22), u22 = this.instance.get_property(Re$2) || {};
      if (t2.send_event || !("send_event" in t2)) {
        if (!(e2 in u22) || !u22[e2].includes(l22)) x$3(u22[e2]) ? u22[e2].push(l22) : u22[e2] = [l22], null === (i2 = this.instance.persistence) || void 0 === i2 || i2.register({ [Re$2]: u22 }), this.instance.capture("$feature_flag_called", { $feature_flag: e2, $feature_flag_response: a22, $feature_flag_payload: this.getFeatureFlagPayload(e2) || null, $feature_flag_bootstrapped_response: (null === (n2 = this.instance.config.bootstrap) || void 0 === n2 || null === (r2 = n2.featureFlags) || void 0 === r2 ? void 0 : r2[e2]) || null, $feature_flag_bootstrapped_payload: (null === (s2 = this.instance.config.bootstrap) || void 0 === s2 || null === (o22 = s2.featureFlagPayloads) || void 0 === o22 ? void 0 : o22[e2]) || null, $used_bootstrap_value: !this._flagsLoadedFromRemote });
      }
      return a22;
    }
    He$1.warn('getFeatureFlag for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  getFeatureFlagPayload(e2) {
    return this.getFlagPayloads()[e2];
  }
  isFeatureEnabled(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (this._hasLoadedFlags || this.getFlags() && this.getFlags().length > 0) return !!this.getFeatureFlag(e2, t2);
    He$1.warn('isFeatureEnabled for key "' + e2 + `" failed. Feature flags didn't load in time.`);
  }
  addFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers.push(e2);
  }
  removeFeatureFlagsHandler(e2) {
    this.featureFlagEventHandlers = this.featureFlagEventHandlers.filter((t2) => t2 !== e2);
  }
  receivedFeatureFlags(e2, t2) {
    if (this.instance.persistence) {
      this._hasLoadedFlags = true;
      var i2 = this.getFlagVariants(), n2 = this.getFlagPayloads();
      !function(e3, t3) {
        var i3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, n3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, r2 = e3.featureFlags, s2 = e3.featureFlagPayloads;
        if (r2) if (x$3(r2)) {
          var o22 = {};
          if (r2) for (var a22 = 0; a22 < r2.length; a22++) o22[r2[a22]] = true;
          t3 && t3.register({ [Ue]: r2, [ke]: o22 });
        } else {
          var l22 = r2, u22 = s2;
          e3.errorsWhileComputingFlags && (l22 = j$5(j$5({}, i3), l22), u22 = j$5(j$5({}, n3), u22)), t3 && t3.register({ [Ue]: Object.keys(We(l22)), [ke]: l22 || {}, [je]: u22 || {} });
        }
      }(e2, this.instance.persistence, i2, n2), this._fireFeatureFlagsCallbacks(t2);
    }
  }
  override(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (!this.instance.__loaded || !this.instance.persistence) return He$1.uninitializedWarning("posthog.feature_flags.override");
    if (this._override_warning = t2, false === e2) this.instance.persistence.unregister(ze$1);
    else if (x$3(e2)) {
      for (var i2 = {}, n2 = 0; n2 < e2.length; n2++) i2[e2[n2]] = true;
      this.instance.persistence.register({ [ze$1]: i2 });
    } else this.instance.persistence.register({ [ze$1]: e2 });
  }
  onFeatureFlags(e2) {
    if (this.addFeatureFlagsHandler(e2), this._hasLoadedFlags) {
      var { flags: t2, flagVariants: i2 } = this._prepareFeatureFlagsForCallbacks();
      e2(t2, i2);
    }
    return () => this.removeFeatureFlagsHandler(e2);
  }
  updateEarlyAccessFeatureEnrollment(e2, t2) {
    var i2, n2 = (this.instance.get_property(xe$2) || []).find((t3) => t3.flagKey === e2), r2 = { ["$feature_enrollment/".concat(e2)]: t2 }, s2 = { $feature_flag: e2, $feature_enrollment: t2, $set: r2 };
    n2 && (s2.$early_access_feature_name = n2.name), this.instance.capture("$feature_enrollment_update", s2), this.setPersonPropertiesForFlags(r2, false);
    var o22 = j$5(j$5({}, this.getFlagVariants()), {}, { [e2]: t2 });
    null === (i2 = this.instance.persistence) || void 0 === i2 || i2.register({ [Ue]: Object.keys(We(o22)), [ke]: o22 }), this._fireFeatureFlagsCallbacks();
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], i2 = this.instance.get_property(xe$2);
    if (i2 && !t2) return e2(i2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/early_access_features/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      var i3;
      if (t3.json) {
        var n2 = t3.json.earlyAccessFeatures;
        return null === (i3 = this.instance.persistence) || void 0 === i3 || i3.register({ [xe$2]: n2 }), e2(n2);
      }
    } });
  }
  _prepareFeatureFlagsForCallbacks() {
    var e2 = this.getFlags(), t2 = this.getFlagVariants();
    return { flags: e2.filter((e3) => t2[e3]), flagVariants: Object.keys(t2).filter((e3) => t2[e3]).reduce((e3, i2) => (e3[i2] = t2[i2], e3), {}) };
  }
  _fireFeatureFlagsCallbacks(e2) {
    var { flags: t2, flagVariants: i2 } = this._prepareFeatureFlagsForCallbacks();
    this.featureFlagEventHandlers.forEach((n2) => n2(t2, i2, { errorsLoading: e2 }));
  }
  setPersonPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.instance.get_property(Ie$2) || {};
    this.instance.register({ [Ie$2]: j$5(j$5({}, i2), e2) }), t2 && this.instance.reloadFeatureFlags();
  }
  resetPersonPropertiesForFlags() {
    this.instance.unregister(Ie$2);
  }
  setGroupPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i2 = this.instance.get_property(Ce) || {};
    0 !== Object.keys(i2).length && Object.keys(i2).forEach((t3) => {
      i2[t3] = j$5(j$5({}, i2[t3]), e2[t3]), delete e2[t3];
    }), this.instance.register({ [Ce]: j$5(j$5({}, i2), e2) }), t2 && this.instance.reloadFeatureFlags();
  }
  resetGroupPropertiesForFlags(e2) {
    if (e2) {
      var t2 = this.instance.get_property(Ce) || {};
      this.instance.register({ [Ce]: j$5(j$5({}, t2), {}, { [e2]: {} }) });
    } else this.instance.unregister(Ce);
  }
}
Math.trunc || (Math.trunc = function(e2) {
  return e2 < 0 ? Math.ceil(e2) : Math.floor(e2);
}), Number.isInteger || (Number.isInteger = function(e2) {
  return M$5(e2) && isFinite(e2) && Math.floor(e2) === e2;
});
var Ge = "0123456789abcdef";
class Je {
  constructor(e2) {
    if (this.bytes = e2, 16 !== e2.length) throw new TypeError("not 128-bit length");
  }
  static fromFieldsV7(e2, t2, i2, n2) {
    if (!Number.isInteger(e2) || !Number.isInteger(t2) || !Number.isInteger(i2) || !Number.isInteger(n2) || e2 < 0 || t2 < 0 || i2 < 0 || n2 < 0 || e2 > 281474976710655 || t2 > 4095 || i2 > 1073741823 || n2 > 4294967295) throw new RangeError("invalid field value");
    var r2 = new Uint8Array(16);
    return r2[0] = e2 / Math.pow(2, 40), r2[1] = e2 / Math.pow(2, 32), r2[2] = e2 / Math.pow(2, 24), r2[3] = e2 / Math.pow(2, 16), r2[4] = e2 / Math.pow(2, 8), r2[5] = e2, r2[6] = 112 | t2 >>> 8, r2[7] = t2, r2[8] = 128 | i2 >>> 24, r2[9] = i2 >>> 16, r2[10] = i2 >>> 8, r2[11] = i2, r2[12] = n2 >>> 24, r2[13] = n2 >>> 16, r2[14] = n2 >>> 8, r2[15] = n2, new Je(r2);
  }
  toString() {
    for (var e2 = "", t2 = 0; t2 < this.bytes.length; t2++) e2 = e2 + Ge.charAt(this.bytes[t2] >>> 4) + Ge.charAt(15 & this.bytes[t2]), 3 !== t2 && 5 !== t2 && 7 !== t2 && 9 !== t2 || (e2 += "-");
    if (36 !== e2.length) throw new Error("Invalid UUIDv7 was generated");
    return e2;
  }
  clone() {
    return new Je(this.bytes.slice(0));
  }
  equals(e2) {
    return 0 === this.compareTo(e2);
  }
  compareTo(e2) {
    for (var t2 = 0; t2 < 16; t2++) {
      var i2 = this.bytes[t2] - e2.bytes[t2];
      if (0 !== i2) return Math.sign(i2);
    }
    return 0;
  }
}
class Ye {
  constructor() {
    W$3(this, "timestamp", 0), W$3(this, "counter", 0), W$3(this, "random", new Qe());
  }
  generate() {
    var e2 = this.generateOrAbort();
    if (F$4(e2)) {
      this.timestamp = 0;
      var t2 = this.generateOrAbort();
      if (F$4(t2)) throw new Error("Could not generate UUID after timestamp reset");
      return t2;
    }
    return e2;
  }
  generateOrAbort() {
    var e2 = Date.now();
    if (e2 > this.timestamp) this.timestamp = e2, this.resetCounter();
    else {
      if (!(e2 + 1e4 > this.timestamp)) return;
      this.counter++, this.counter > 4398046511103 && (this.timestamp++, this.resetCounter());
    }
    return Je.fromFieldsV7(this.timestamp, Math.trunc(this.counter / Math.pow(2, 30)), this.counter & Math.pow(2, 30) - 1, this.random.nextUint32());
  }
  resetCounter() {
    this.counter = 1024 * this.random.nextUint32() + (1023 & this.random.nextUint32());
  }
}
var Ke, Xe = (e2) => {
  if ("undefined" != typeof UUIDV7_DENY_WEAK_RNG && UUIDV7_DENY_WEAK_RNG) throw new Error("no cryptographically strong RNG available");
  for (var t2 = 0; t2 < e2.length; t2++) e2[t2] = 65536 * Math.trunc(65536 * Math.random()) + Math.trunc(65536 * Math.random());
  return e2;
};
t$5 && !F$4(t$5.crypto) && crypto.getRandomValues && (Xe = (e2) => crypto.getRandomValues(e2));
class Qe {
  constructor() {
    W$3(this, "buffer", new Uint32Array(8)), W$3(this, "cursor", 1 / 0);
  }
  nextUint32() {
    return this.cursor >= this.buffer.length && (Xe(this.buffer), this.cursor = 0), this.buffer[this.cursor++];
  }
}
var Ze = () => et().toString(), et = () => (Ke || (Ke = new Ye())).generate(), tt = "Thu, 01 Jan 1970 00:00:00 GMT", it$1 = "";
var nt = /[a-z0-9][a-z0-9-]+\.[a-z]{2,}$/i;
function rt(e2, t2) {
  if (t2) {
    var i2 = function(e3) {
      var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a$a;
      if (it$1) return it$1;
      if (!t3) return "";
      if (["localhost", "127.0.0.1"].includes(e3)) return "";
      for (var i3 = e3.split("."), n3 = Math.min(i3.length, 8), r2 = "dmn_chk_" + Ze(), s2 = new RegExp("(^|;)\\s*" + r2 + "=1"); !it$1 && n3--; ) {
        var o22 = i3.slice(n3).join("."), l22 = r2 + "=1;domain=." + o22;
        t3.cookie = l22, s2.test(t3.cookie) && (t3.cookie = l22 + ";expires=" + tt, it$1 = o22);
      }
      return it$1;
    }(e2);
    if (!i2) {
      var n2 = ((e3) => {
        var t3 = e3.match(nt);
        return t3 ? t3[0] : "";
      })(e2);
      n2 !== i2 && q$2.info("Warning: cookie subdomain discovery mismatch", n2, i2), i2 = n2;
    }
    return i2 ? "; domain=." + i2 : "";
  }
  return "";
}
var st$1 = { is_supported: () => !!a$a, error: function(e2) {
  q$2.error("cookieStore error: " + e2);
}, get: function(e2) {
  if (a$a) {
    try {
      for (var t2 = e2 + "=", i2 = a$a.cookie.split(";").filter((e3) => e3.length), n2 = 0; n2 < i2.length; n2++) {
        for (var r2 = i2[n2]; " " == r2.charAt(0); ) r2 = r2.substring(1, r2.length);
        if (0 === r2.indexOf(t2)) return decodeURIComponent(r2.substring(t2.length, r2.length));
      }
    } catch (e3) {
    }
    return null;
  }
}, parse: function(e2) {
  var t2;
  try {
    t2 = JSON.parse(st$1.get(e2)) || {};
  } catch (e3) {
  }
  return t2;
}, set: function(e2, t2, i2, n2, r2) {
  if (a$a) try {
    var s2 = "", o22 = "", l22 = rt(a$a.location.hostname, n2);
    if (i2) {
      var u22 = /* @__PURE__ */ new Date();
      u22.setTime(u22.getTime() + 24 * i2 * 60 * 60 * 1e3), s2 = "; expires=" + u22.toUTCString();
    }
    r2 && (o22 = "; secure");
    var c2 = e2 + "=" + encodeURIComponent(JSON.stringify(t2)) + s2 + "; SameSite=Lax; path=/" + l22 + o22;
    return c2.length > 3686.4 && q$2.warn("cookieStore warning: large cookie, len=" + c2.length), a$a.cookie = c2, c2;
  } catch (e3) {
    return;
  }
}, remove: function(e2, t2) {
  try {
    st$1.set(e2, "", -1, t2);
  } catch (e3) {
    return;
  }
} }, ot = null, at$1 = { is_supported: function() {
  if (!$$3(ot)) return ot;
  var e2 = true;
  if (F$4(t$5)) e2 = false;
  else try {
    var i2 = "__mplssupport__";
    at$1.set(i2, "xyz"), '"xyz"' !== at$1.get(i2) && (e2 = false), at$1.remove(i2);
  } catch (t2) {
    e2 = false;
  }
  return e2 || q$2.error("localStorage unsupported; falling back to cookie store"), ot = e2, e2;
}, error: function(e2) {
  q$2.error("localStorage error: " + e2);
}, get: function(e2) {
  try {
    return null == t$5 ? void 0 : t$5.localStorage.getItem(e2);
  } catch (e3) {
    at$1.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(at$1.get(e2)) || {};
  } catch (e3) {
  }
  return null;
}, set: function(e2, i2) {
  try {
    null == t$5 || t$5.localStorage.setItem(e2, JSON.stringify(i2));
  } catch (e3) {
    at$1.error(e3);
  }
}, remove: function(e2) {
  try {
    null == t$5 || t$5.localStorage.removeItem(e2);
  } catch (e3) {
    at$1.error(e3);
  }
} }, lt$1 = ["distinct_id", ye$2, we, De$1, Ae$2], ut$1 = j$5(j$5({}, at$1), {}, { parse: function(e2) {
  try {
    var t2 = {};
    try {
      t2 = st$1.parse(e2) || {};
    } catch (e3) {
    }
    var i2 = K$2(t2, JSON.parse(at$1.get(e2) || "{}"));
    return at$1.set(e2, i2), i2;
  } catch (e3) {
  }
  return null;
}, set: function(e2, t2, i2, n2, r2, s2) {
  try {
    at$1.set(e2, t2, void 0, void 0, s2);
    var o22 = {};
    lt$1.forEach((e3) => {
      t2[e3] && (o22[e3] = t2[e3]);
    }), Object.keys(o22).length && st$1.set(e2, o22, i2, n2, r2, s2);
  } catch (e3) {
    at$1.error(e3);
  }
}, remove: function(e2, i2) {
  try {
    null == t$5 || t$5.localStorage.removeItem(e2), st$1.remove(e2, i2);
  } catch (e3) {
    at$1.error(e3);
  }
} }), ct$1 = {}, dt$1 = { is_supported: function() {
  return true;
}, error: function(e2) {
  q$2.error("memoryStorage error: " + e2);
}, get: function(e2) {
  return ct$1[e2] || null;
}, parse: function(e2) {
  return ct$1[e2] || null;
}, set: function(e2, t2) {
  ct$1[e2] = t2;
}, remove: function(e2) {
  delete ct$1[e2];
} }, ht = null, _t$1 = { is_supported: function() {
  if (!$$3(ht)) return ht;
  if (ht = true, F$4(t$5)) ht = false;
  else try {
    var e2 = "__support__";
    _t$1.set(e2, "xyz"), '"xyz"' !== _t$1.get(e2) && (ht = false), _t$1.remove(e2);
  } catch (e3) {
    ht = false;
  }
  return ht;
}, error: function(e2) {
  q$2.error("sessionStorage error: ", e2);
}, get: function(e2) {
  try {
    return null == t$5 ? void 0 : t$5.sessionStorage.getItem(e2);
  } catch (e3) {
    _t$1.error(e3);
  }
  return null;
}, parse: function(e2) {
  try {
    return JSON.parse(_t$1.get(e2)) || null;
  } catch (e3) {
  }
  return null;
}, set: function(e2, i2) {
  try {
    null == t$5 || t$5.sessionStorage.setItem(e2, JSON.stringify(i2));
  } catch (e3) {
    _t$1.error(e3);
  }
}, remove: function(e2) {
  try {
    null == t$5 || t$5.sessionStorage.removeItem(e2);
  } catch (e3) {
    _t$1.error(e3);
  }
} }, pt$1 = ["localhost", "127.0.0.1"], vt$1 = (e2) => {
  var t2 = null == a$a ? void 0 : a$a.createElement("a");
  return F$4(t2) ? null : (t2.href = e2, t2);
}, gt$1 = function(e2, t2) {
  return !!function(e3) {
    try {
      new RegExp(e3);
    } catch (e4) {
      return false;
    }
    return true;
  }(t2) && new RegExp(t2).test(e2);
}, ft$1 = function(e2) {
  var t2, i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "&", r2 = [];
  return Y$2(e2, function(e3, n3) {
    F$4(e3) || F$4(n3) || "undefined" === n3 || (t2 = encodeURIComponent(((e4) => e4 instanceof File)(e3) ? e3.name : e3.toString()), i2 = encodeURIComponent(n3), r2[r2.length] = i2 + "=" + t2);
  }), r2.join(n2);
}, mt$1 = function(e2, t2) {
  for (var i2, n2 = ((e2.split("#")[0] || "").split("?")[1] || "").split("&"), r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2].split("=");
    if (s2[0] === t2) {
      i2 = s2;
      break;
    }
  }
  if (!x$3(i2) || i2.length < 2) return "";
  var o22 = i2[1];
  try {
    o22 = decodeURIComponent(o22);
  } catch (e3) {
    q$2.error("Skipping decoding for malformed query param: " + o22);
  }
  return o22.replace(/\+/g, " ");
}, bt$1 = function(e2, t2) {
  var i2 = e2.match(new RegExp(t2 + "=([^&]*)"));
  return i2 ? i2[1] : null;
}, yt$1 = "Mobile", wt = "iOS", St$1 = "Android", Et$1 = "Tablet", kt = St$1 + " " + Et$1, xt = "iPad", It = "Apple", Ct$1 = It + " Watch", Pt$1 = "Safari", Ft = "BlackBerry", Rt$1 = "Samsung", Tt$1 = Rt$1 + "Browser", $t = Rt$1 + " Internet", Ot = "Chrome", Mt = Ot + " OS", Lt = Ot + " " + wt, At$1 = "Internet Explorer", Dt = At$1 + " " + yt$1, Nt = "Opera", qt = Nt + " Mini", Bt$1 = "Edge", Ht = "Microsoft " + Bt$1, Ut = "Firefox", zt = Ut + " " + wt, jt = "Nintendo", Wt = "PlayStation", Vt = "Xbox", Gt = St$1 + " " + yt$1, Jt = yt$1 + " " + Pt$1, Yt = "Windows", Kt = Yt + " Phone", Xt = "Nokia", Qt = "Ouya", Zt = "Generic", ei = Zt + " " + yt$1.toLowerCase(), ti = Zt + " " + Et$1.toLowerCase(), ii = "Konqueror", ni = "(\\d+(\\.\\d+)?)", ri = new RegExp("Version/" + ni), si = new RegExp(Vt, "i"), oi = new RegExp(Wt + " \\w+", "i"), ai = new RegExp(jt + " \\w+", "i"), li = new RegExp(Ft + "|PlayBook|BB10", "i"), ui = { "NT3.51": "NT 3.11", "NT4.0": "NT 4.0", "5.0": "2000", 5.1: "XP", 5.2: "XP", "6.0": "Vista", 6.1: "7", 6.2: "8", 6.3: "8.1", 6.4: "10", "10.0": "10" };
var ci = (e2, t2) => t2 && m$5(t2, It) || function(e3) {
  return m$5(e3, Pt$1) && !m$5(e3, Ot) && !m$5(e3, St$1);
}(e2), di = function(e2, t2) {
  return t2 = t2 || "", m$5(e2, " OPR/") && m$5(e2, "Mini") ? qt : m$5(e2, " OPR/") ? Nt : li.test(e2) ? Ft : m$5(e2, "IE" + yt$1) || m$5(e2, "WPDesktop") ? Dt : m$5(e2, Tt$1) ? $t : m$5(e2, Bt$1) || m$5(e2, "Edg/") ? Ht : m$5(e2, "FBIOS") ? "Facebook " + yt$1 : m$5(e2, "UCWEB") || m$5(e2, "UCBrowser") ? "UC Browser" : m$5(e2, "CriOS") ? Lt : m$5(e2, "CrMo") || m$5(e2, Ot) ? Ot : m$5(e2, St$1) && m$5(e2, Pt$1) ? Gt : m$5(e2, "FxiOS") ? zt : m$5(e2.toLowerCase(), ii.toLowerCase()) ? ii : ci(e2, t2) ? m$5(e2, yt$1) ? Jt : Pt$1 : m$5(e2, Ut) ? Ut : m$5(e2, "MSIE") || m$5(e2, "Trident/") ? At$1 : m$5(e2, "Gecko") ? Ut : "";
}, hi = { [Dt]: [new RegExp("rv:" + ni)], [Ht]: [new RegExp(Bt$1 + "?\\/" + ni)], [Ot]: [new RegExp("(" + Ot + "|CrMo)\\/" + ni)], [Lt]: [new RegExp("CriOS\\/" + ni)], "UC Browser": [new RegExp("(UCBrowser|UCWEB)\\/" + ni)], [Pt$1]: [ri], [Jt]: [ri], [Nt]: [new RegExp("(Opera|OPR)\\/" + ni)], [Ut]: [new RegExp(Ut + "\\/" + ni)], [zt]: [new RegExp("FxiOS\\/" + ni)], [ii]: [new RegExp("Konqueror[:/]?" + ni, "i")], [Ft]: [new RegExp(Ft + " " + ni), ri], [Gt]: [new RegExp("android\\s" + ni, "i")], [$t]: [new RegExp(Tt$1 + "\\/" + ni)], [At$1]: [new RegExp("(rv:|MSIE )" + ni)], Mozilla: [new RegExp("rv:" + ni)] }, _i = [[new RegExp(Vt + "; " + Vt + " (.*?)[);]", "i"), (e2) => [Vt, e2 && e2[1] || ""]], [new RegExp(jt, "i"), [jt, ""]], [new RegExp(Wt, "i"), [Wt, ""]], [li, [Ft, ""]], [new RegExp(Yt, "i"), (e2, t2) => {
  if (/Phone/.test(t2) || /WPDesktop/.test(t2)) return [Kt, ""];
  if (new RegExp(yt$1).test(t2) && !/IEMobile\b/.test(t2)) return [Yt + " " + yt$1, ""];
  var i2 = /Windows NT ([0-9.]+)/i.exec(t2);
  if (i2 && i2[1]) {
    var n2 = i2[1], r2 = ui[n2] || "";
    return /arm/i.test(t2) && (r2 = "RT"), [Yt, r2];
  }
  return [Yt, ""];
}], [/((iPhone|iPad|iPod).*?OS (\d+)_(\d+)_?(\d+)?|iPhone)/, (e2) => {
  if (e2 && e2[3]) {
    var t2 = [e2[3], e2[4], e2[5] || "0"];
    return [wt, t2.join(".")];
  }
  return [wt, ""];
}], [/(watch.*\/(\d+\.\d+\.\d+)|watch os,(\d+\.\d+),)/i, (e2) => {
  var t2 = "";
  return e2 && e2.length >= 3 && (t2 = F$4(e2[2]) ? e2[3] : e2[2]), ["watchOS", t2];
}], [new RegExp("(" + St$1 + " (\\d+)\\.(\\d+)\\.?(\\d+)?|" + St$1 + ")", "i"), (e2) => {
  if (e2 && e2[2]) {
    var t2 = [e2[2], e2[3], e2[4] || "0"];
    return [St$1, t2.join(".")];
  }
  return [St$1, ""];
}], [/Mac OS X (\d+)[_.](\d+)[_.]?(\d+)?/i, (e2) => {
  var t2 = ["Mac OS X", ""];
  if (e2 && e2[1]) {
    var i2 = [e2[1], e2[2], e2[3] || "0"];
    t2[1] = i2.join(".");
  }
  return t2;
}], [/Mac/i, ["Mac OS X", ""]], [/CrOS/, [Mt, ""]], [/Linux|debian/i, ["Linux", ""]]], pi = function(e2) {
  return ai.test(e2) ? jt : oi.test(e2) ? Wt : si.test(e2) ? Vt : new RegExp(Qt, "i").test(e2) ? Qt : new RegExp("(" + Kt + "|WPDesktop)", "i").test(e2) ? Kt : /iPad/.test(e2) ? xt : /iPod/.test(e2) ? "iPod Touch" : /iPhone/.test(e2) ? "iPhone" : /(watch)(?: ?os[,/]|\d,\d\/)[\d.]+/i.test(e2) ? Ct$1 : li.test(e2) ? Ft : /(kobo)\s(ereader|touch)/i.test(e2) ? "Kobo" : new RegExp(Xt, "i").test(e2) ? Xt : /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i.test(e2) || /(kf[a-z]+)( bui|\)).+silk\//i.test(e2) ? "Kindle Fire" : /(Android|ZTE)/i.test(e2) ? !new RegExp(yt$1).test(e2) || /(9138B|TB782B|Nexus [97]|pixel c|HUAWEISHT|BTV|noble nook|smart ultra 6)/i.test(e2) ? /pixel[\daxl ]{1,6}/i.test(e2) && !/pixel c/i.test(e2) || /(huaweimed-al00|tah-|APA|SM-G92|i980|zte|U304AA)/i.test(e2) || /lmy47v/i.test(e2) && !/QTAQZ3/i.test(e2) ? St$1 : kt : St$1 : new RegExp("(pda|" + yt$1 + ")", "i").test(e2) ? ei : new RegExp(Et$1, "i").test(e2) && !new RegExp(Et$1 + " pc", "i").test(e2) ? ti : "";
}, vi = "https?://(.*)", gi = ["utm_source", "utm_medium", "utm_campaign", "utm_content", "utm_term", "gclid", "gad_source", "gclsrc", "dclid", "gbraid", "wbraid", "fbclid", "msclkid", "twclid", "li_fat_id", "mc_cid", "igshid", "ttclid", "rdt_cid"], fi = { campaignParams: function(e2) {
  return a$a ? this._campaignParamsFromUrl(a$a.URL, e2) : {};
}, _campaignParamsFromUrl: function(e2, t2) {
  var i2 = gi.concat(t2 || []), n2 = {};
  return Y$2(i2, function(t3) {
    var i3 = mt$1(e2, t3);
    n2[t3] = i3 || null;
  }), n2;
}, _searchEngine: function(e2) {
  return e2 ? 0 === e2.search(vi + "google.([^/?]*)") ? "google" : 0 === e2.search(vi + "bing.com") ? "bing" : 0 === e2.search(vi + "yahoo.com") ? "yahoo" : 0 === e2.search(vi + "duckduckgo.com") ? "duckduckgo" : null : null;
}, _searchInfoFromReferrer: function(e2) {
  var t2 = fi._searchEngine(e2), i2 = "yahoo" != t2 ? "q" : "p", n2 = {};
  if (!$$3(t2)) {
    n2.$search_engine = t2;
    var r2 = a$a ? mt$1(a$a.referrer, i2) : "";
    r2.length && (n2.ph_keyword = r2);
  }
  return n2;
}, searchInfo: function() {
  var e2 = null == a$a ? void 0 : a$a.referrer;
  return e2 ? this._searchInfoFromReferrer(e2) : {};
}, browser: di, browserVersion: function(e2, t2) {
  var i2 = di(e2, t2), n2 = hi[i2];
  if (F$4(n2)) return null;
  for (var r2 = 0; r2 < n2.length; r2++) {
    var s2 = n2[r2], o22 = e2.match(s2);
    if (o22) return parseFloat(o22[o22.length - 2]);
  }
  return null;
}, browserLanguage: function() {
  return navigator.language || navigator.userLanguage;
}, browserLanguagePrefix: function() {
  var e2 = this.browserLanguage();
  return "string" == typeof e2 ? e2.split("-")[0] : void 0;
}, os: function(e2) {
  for (var t2 = 0; t2 < _i.length; t2++) {
    var [i2, n2] = _i[t2], r2 = i2.exec(e2), s2 = r2 && (I$4(n2) ? n2(r2, e2) : n2);
    if (s2) return s2;
  }
  return ["", ""];
}, device: pi, deviceType: function(e2) {
  var t2 = pi(e2);
  return t2 === xt || t2 === kt || "Kobo" === t2 || "Kindle Fire" === t2 || t2 === ti ? Et$1 : t2 === jt || t2 === Vt || t2 === Wt || t2 === Qt ? "Console" : t2 === Ct$1 ? "Wearable" : t2 ? yt$1 : "Desktop";
}, referrer: function() {
  return (null == a$a ? void 0 : a$a.referrer) || "$direct";
}, referringDomain: function() {
  var e2;
  return null != a$a && a$a.referrer && (null === (e2 = vt$1(a$a.referrer)) || void 0 === e2 ? void 0 : e2.host) || "$direct";
}, referrerInfo: function() {
  return { $referrer: this.referrer(), $referring_domain: this.referringDomain() };
}, initialPersonInfo: function() {
  return { r: this.referrer().substring(0, 1e3), u: null == l$5 ? void 0 : l$5.href.substring(0, 1e3) };
}, initialPersonPropsFromInfo: function(e2) {
  var t2, { r: i2, u: n2 } = e2, r2 = { $initial_referrer: i2, $initial_referring_domain: null == i2 ? void 0 : "$direct" == i2 ? "$direct" : null === (t2 = vt$1(i2)) || void 0 === t2 ? void 0 : t2.host };
  if (n2) {
    r2.$initial_current_url = n2;
    var s2 = vt$1(n2);
    r2.$initial_host = null == s2 ? void 0 : s2.host, r2.$initial_pathname = null == s2 ? void 0 : s2.pathname, Y$2(this._campaignParamsFromUrl(n2), function(e3, t3) {
      r2["$initial_" + y$5(t3)] = e3;
    });
  }
  i2 && Y$2(this._searchInfoFromReferrer(i2), function(e3, t3) {
    r2["$initial_" + y$5(t3)] = e3;
  });
  return r2;
}, timezone: function() {
  try {
    return Intl.DateTimeFormat().resolvedOptions().timeZone;
  } catch (e2) {
    return;
  }
}, timezoneOffset: function() {
  try {
    return (/* @__PURE__ */ new Date()).getTimezoneOffset();
  } catch (e2) {
    return;
  }
}, properties: function() {
  if (!h$5) return {};
  var [e2, i2] = fi.os(h$5);
  return K$2(ee$2({ $os: e2, $os_version: i2, $browser: fi.browser(h$5, navigator.vendor), $device: fi.device(h$5), $device_type: fi.deviceType(h$5), $timezone: fi.timezone(), $timezone_offset: fi.timezoneOffset() }), { $current_url: null == l$5 ? void 0 : l$5.href, $host: null == l$5 ? void 0 : l$5.host, $pathname: null == l$5 ? void 0 : l$5.pathname, $raw_user_agent: h$5.length > 1e3 ? h$5.substring(0, 997) + "..." : h$5, $browser_version: fi.browserVersion(h$5, navigator.vendor), $browser_language: fi.browserLanguage(), $browser_language_prefix: fi.browserLanguagePrefix(), $screen_height: null == t$5 ? void 0 : t$5.screen.height, $screen_width: null == t$5 ? void 0 : t$5.screen.width, $viewport_height: null == t$5 ? void 0 : t$5.innerHeight, $viewport_width: null == t$5 ? void 0 : t$5.innerWidth, $lib: "web", $lib_version: p$5.LIB_VERSION, $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10), $time: Date.now() / 1e3 });
}, people_properties: function() {
  if (!h$5) return {};
  var [e2, t2] = fi.os(h$5);
  return K$2(ee$2({ $os: e2, $os_version: t2, $browser: fi.browser(h$5, navigator.vendor) }), { $browser_version: fi.browserVersion(h$5, navigator.vendor) });
} }, mi = ["cookie", "localstorage", "localstorage+cookie", "sessionstorage", "memory"];
class bi {
  constructor(e2) {
    this.config = e2, this.props = {}, this.campaign_params_saved = false, this.name = ((e3) => {
      var t2 = "";
      return e3.token && (t2 = e3.token.replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ")), e3.persistence_name ? "ph_" + e3.persistence_name : "ph_" + t2 + "_posthog";
    })(e2), this.storage = this.buildStorage(e2), this.load(), e2.debug && q$2.info("Persistence loaded", e2.persistence, j$5({}, this.props)), this.update_config(e2, e2), this.save();
  }
  buildStorage(e2) {
    -1 === mi.indexOf(e2.persistence.toLowerCase()) && (q$2.critical("Unknown persistence type " + e2.persistence + "; falling back to localStorage+cookie"), e2.persistence = "localStorage+cookie");
    var t2 = e2.persistence.toLowerCase();
    return "localstorage" === t2 && at$1.is_supported() ? at$1 : "localstorage+cookie" === t2 && ut$1.is_supported() ? ut$1 : "sessionstorage" === t2 && _t$1.is_supported() ? _t$1 : "memory" === t2 ? dt$1 : "cookie" === t2 ? st$1 : ut$1.is_supported() ? ut$1 : st$1;
  }
  properties() {
    var e2 = {};
    return Y$2(this.props, function(t2, i2) {
      if (i2 === ke && C$4(t2)) for (var n2 = Object.keys(t2), r2 = 0; r2 < n2.length; r2++) e2["$feature/".concat(n2[r2])] = t2[n2[r2]];
      else a22 = i2, l22 = false, ($$3(o22 = Be) ? l22 : s$8 && o22.indexOf === s$8 ? -1 != o22.indexOf(a22) : (Y$2(o22, function(e3) {
        if (l22 || (l22 = e3 === a22)) return G$2;
      }), l22)) || (e2[i2] = t2);
      var o22, a22, l22;
    }), e2;
  }
  load() {
    if (!this.disabled) {
      var e2 = this.storage.parse(this.name);
      e2 && (this.props = K$2({}, e2));
    }
  }
  save() {
    this.disabled || this.storage.set(this.name, this.props, this.expire_days, this.cross_subdomain, this.secure, this.config.debug);
  }
  remove() {
    this.storage.remove(this.name, false), this.storage.remove(this.name, true);
  }
  clear() {
    this.remove(), this.props = {};
  }
  register_once(e2, t2, i2) {
    if (C$4(e2)) {
      F$4(t2) && (t2 = "None"), this.expire_days = F$4(i2) ? this.default_expiry : i2;
      var n2 = false;
      if (Y$2(e2, (e3, i3) => {
        this.props.hasOwnProperty(i3) && this.props[i3] !== t2 || (this.props[i3] = e3, n2 = true);
      }), n2) return this.save(), true;
    }
    return false;
  }
  register(e2, t2) {
    if (C$4(e2)) {
      this.expire_days = F$4(t2) ? this.default_expiry : t2;
      var i2 = false;
      if (Y$2(e2, (t3, n2) => {
        e2.hasOwnProperty(n2) && this.props[n2] !== t3 && (this.props[n2] = t3, i2 = true);
      }), i2) return this.save(), true;
    }
    return false;
  }
  unregister(e2) {
    e2 in this.props && (delete this.props[e2], this.save());
  }
  update_campaign_params() {
    if (!this.campaign_params_saved) {
      var e2 = fi.campaignParams(this.config.custom_campaign_params);
      P$5(ee$2(e2)) || this.register(e2), this.campaign_params_saved = true;
    }
  }
  update_search_keyword() {
    this.register(fi.searchInfo());
  }
  update_referrer_info() {
    this.register_once(fi.referrerInfo(), void 0);
  }
  set_initial_person_info() {
    this.props[Me$2] || this.props[Le$1] || this.register_once({ [Ae$2]: fi.initialPersonInfo() }, void 0);
  }
  get_referrer_info() {
    return ee$2({ $referrer: this.props.$referrer, $referring_domain: this.props.$referring_domain });
  }
  get_initial_props() {
    var e2 = {};
    Y$2([Le$1, Me$2], (t3) => {
      var i3 = this.props[t3];
      i3 && Y$2(i3, function(t4, i4) {
        e2["$initial_" + y$5(i4)] = t4;
      });
    });
    var t2 = this.props[Ae$2];
    if (t2) {
      var i2 = fi.initialPersonPropsFromInfo(t2);
      K$2(e2, i2);
    }
    return e2;
  }
  safe_merge(e2) {
    return Y$2(this.props, function(t2, i2) {
      i2 in e2 || (e2[i2] = t2);
    }), e2;
  }
  update_config(e2, t2) {
    if (this.default_expiry = this.expire_days = e2.cookie_expiration, this.set_disabled(e2.disable_persistence), this.set_cross_subdomain(e2.cross_subdomain_cookie), this.set_secure(e2.secure_cookie), e2.persistence !== t2.persistence) {
      var i2 = this.buildStorage(e2), n2 = this.props;
      this.clear(), this.storage = i2, this.props = n2, this.save();
    }
  }
  set_disabled(e2) {
    this.disabled = e2, this.disabled ? this.remove() : this.save();
  }
  set_cross_subdomain(e2) {
    e2 !== this.cross_subdomain && (this.cross_subdomain = e2, this.remove(), this.save());
  }
  get_cross_subdomain() {
    return !!this.cross_subdomain;
  }
  set_secure(e2) {
    e2 !== this.secure && (this.secure = e2, this.remove(), this.save());
  }
  set_event_timer(e2, t2) {
    var i2 = this.props[oe$1] || {};
    i2[e2] = t2, this.props[oe$1] = i2, this.save();
  }
  remove_event_timer(e2) {
    var t2 = (this.props[oe$1] || {})[e2];
    return F$4(t2) || (delete this.props[oe$1][e2], this.save()), t2;
  }
  get_property(e2) {
    return this.props[e2];
  }
  set_property(e2, t2) {
    this.props[e2] = t2, this.save();
  }
}
function yi(e2) {
  var t2, i2;
  return (null === (t2 = JSON.stringify(e2, (i2 = [], function(e3, t3) {
    if (C$4(t3)) {
      for (; i2.length > 0 && i2[i2.length - 1] !== this; ) i2.pop();
      return i2.includes(t3) ? "[Circular]" : (i2.push(t3), t3);
    }
    return t3;
  }))) || void 0 === t2 ? void 0 : t2.length) || 0;
}
function wi(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 66060288e-1;
  if (e2.size >= t2 && e2.data.length > 1) {
    var i2 = Math.floor(e2.data.length / 2), n2 = e2.data.slice(0, i2), r2 = e2.data.slice(i2);
    return [wi({ size: yi(n2), data: n2, sessionId: e2.sessionId, windowId: e2.windowId }), wi({ size: yi(r2), data: r2, sessionId: e2.sessionId, windowId: e2.windowId })].flatMap((e3) => e3);
  }
  return [e2];
}
var Si = ((e2) => (e2[e2.DomContentLoaded = 0] = "DomContentLoaded", e2[e2.Load = 1] = "Load", e2[e2.FullSnapshot = 2] = "FullSnapshot", e2[e2.IncrementalSnapshot = 3] = "IncrementalSnapshot", e2[e2.Meta = 4] = "Meta", e2[e2.Custom = 5] = "Custom", e2[e2.Plugin = 6] = "Plugin", e2))(Si || {}), Ei = ((e2) => (e2[e2.Mutation = 0] = "Mutation", e2[e2.MouseMove = 1] = "MouseMove", e2[e2.MouseInteraction = 2] = "MouseInteraction", e2[e2.Scroll = 3] = "Scroll", e2[e2.ViewportResize = 4] = "ViewportResize", e2[e2.Input = 5] = "Input", e2[e2.TouchMove = 6] = "TouchMove", e2[e2.MediaInteraction = 7] = "MediaInteraction", e2[e2.StyleSheetRule = 8] = "StyleSheetRule", e2[e2.CanvasMutation = 9] = "CanvasMutation", e2[e2.Font = 10] = "Font", e2[e2.Log = 11] = "Log", e2[e2.Drag = 12] = "Drag", e2[e2.StyleDeclaration = 13] = "StyleDeclaration", e2[e2.Selection = 14] = "Selection", e2[e2.AdoptedStyleSheet = 15] = "AdoptedStyleSheet", e2[e2.CustomElement = 16] = "CustomElement", e2))(Ei || {});
function ki(e2) {
  var t2;
  return e2 instanceof Element && (e2.id === Ne || !(null === (t2 = e2.closest) || void 0 === t2 || !t2.call(e2, ".toolbar-global-fade-container")));
}
function xi(e2) {
  return !!e2 && 1 === e2.nodeType;
}
function Ii(e2, t2) {
  return !!e2 && !!e2.tagName && e2.tagName.toLowerCase() === t2.toLowerCase();
}
function Ci(e2) {
  return !!e2 && 3 === e2.nodeType;
}
function Pi(e2) {
  return !!e2 && 11 === e2.nodeType;
}
function Fi(e2) {
  return e2 ? b$5(e2).split(/\s+/) : [];
}
function Ri(e2) {
  var i2 = null == t$5 ? void 0 : t$5.location.href;
  return !!(i2 && e2 && e2.some((e3) => i2.match(e3)));
}
function Ti(e2) {
  var t2 = "";
  switch (typeof e2.className) {
    case "string":
      t2 = e2.className;
      break;
    case "object":
      t2 = (e2.className && "baseVal" in e2.className ? e2.className.baseVal : null) || e2.getAttribute("class") || "";
      break;
    default:
      t2 = "";
  }
  return Fi(t2);
}
function $i(e2) {
  return O$5(e2) ? null : b$5(e2).split(/(\s+)/).filter((e3) => Vi(e3)).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
}
function Oi(e2) {
  var t2 = "";
  return Ni(e2) && !qi(e2) && e2.childNodes && e2.childNodes.length && Y$2(e2.childNodes, function(e3) {
    var i2;
    Ci(e3) && e3.textContent && (t2 += null !== (i2 = $i(e3.textContent)) && void 0 !== i2 ? i2 : "");
  }), b$5(t2);
}
function Mi(e2) {
  return F$4(e2.target) ? e2.srcElement || null : null !== (t2 = e2.target) && void 0 !== t2 && t2.shadowRoot ? e2.composedPath()[0] || null : e2.target || null;
  var t2;
}
var Li = ["a", "button", "form", "input", "select", "textarea", "label"];
function Ai(e2) {
  var t2 = e2.parentNode;
  return !(!t2 || !xi(t2)) && t2;
}
function Di(e2, i2) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, r2 = arguments.length > 3 ? arguments[3] : void 0, s2 = arguments.length > 4 ? arguments[4] : void 0;
  if (!t$5 || !e2 || Ii(e2, "html") || !xi(e2)) return false;
  if (null != n2 && n2.url_allowlist && !Ri(n2.url_allowlist)) return false;
  if (null != n2 && n2.url_ignorelist && Ri(n2.url_ignorelist)) return false;
  if (null != n2 && n2.dom_event_allowlist) {
    var o22 = n2.dom_event_allowlist;
    if (o22 && !o22.some((e3) => i2.type === e3)) return false;
  }
  for (var a22 = false, l22 = [e2], u22 = true, c2 = e2; c2.parentNode && !Ii(c2, "body"); ) if (Pi(c2.parentNode)) l22.push(c2.parentNode.host), c2 = c2.parentNode.host;
  else {
    if (!(u22 = Ai(c2))) break;
    if (r2 || Li.indexOf(u22.tagName.toLowerCase()) > -1) a22 = true;
    else {
      var d22 = t$5.getComputedStyle(u22);
      d22 && "pointer" === d22.getPropertyValue("cursor") && (a22 = true);
    }
    l22.push(u22), c2 = u22;
  }
  if (!function(e3, t2) {
    var i3 = null == t2 ? void 0 : t2.element_allowlist;
    if (F$4(i3)) return true;
    var n3 = function(e4) {
      if (i3.some((t3) => e4.tagName.toLowerCase() === t3)) return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3) return s3.v;
    }
    return false;
  }(l22, n2)) return false;
  if (!function(e3, t2) {
    var i3 = null == t2 ? void 0 : t2.css_selector_allowlist;
    if (F$4(i3)) return true;
    var n3 = function(e4) {
      if (i3.some((t3) => e4.matches(t3))) return { v: true };
    };
    for (var r3 of e3) {
      var s3 = n3(r3);
      if ("object" == typeof s3) return s3.v;
    }
    return false;
  }(l22, n2)) return false;
  var h22 = t$5.getComputedStyle(e2);
  if (h22 && "pointer" === h22.getPropertyValue("cursor") && "click" === i2.type) return true;
  var _2 = e2.tagName.toLowerCase();
  switch (_2) {
    case "html":
      return false;
    case "form":
      return (s2 || ["submit"]).indexOf(i2.type) >= 0;
    case "input":
    case "select":
    case "textarea":
      return (s2 || ["change", "click"]).indexOf(i2.type) >= 0;
    default:
      return a22 ? (s2 || ["click"]).indexOf(i2.type) >= 0 : (s2 || ["click"]).indexOf(i2.type) >= 0 && (Li.indexOf(_2) > -1 || "true" === e2.getAttribute("contenteditable"));
  }
}
function Ni(e2) {
  for (var t2 = e2; t2.parentNode && !Ii(t2, "body"); t2 = t2.parentNode) {
    var i2 = Ti(t2);
    if (m$5(i2, "ph-sensitive") || m$5(i2, "ph-no-capture")) return false;
  }
  if (m$5(Ti(e2), "ph-include")) return true;
  var n2 = e2.type || "";
  if (R$4(n2)) switch (n2.toLowerCase()) {
    case "hidden":
    case "password":
      return false;
  }
  var r2 = e2.name || e2.id || "";
  if (R$4(r2)) {
    if (/^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i.test(r2.replace(/[^a-zA-Z0-9]/g, ""))) return false;
  }
  return true;
}
function qi(e2) {
  return !!(Ii(e2, "input") && !["button", "checkbox", "submit", "reset"].includes(e2.type) || Ii(e2, "select") || Ii(e2, "textarea") || "true" === e2.getAttribute("contenteditable"));
}
var Bi = "(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11})", Hi = new RegExp("^(?:".concat(Bi, ")$")), Ui = new RegExp(Bi), zi = "\\d{3}-?\\d{2}-?\\d{4}", ji = new RegExp("^(".concat(zi, ")$")), Wi = new RegExp("(".concat(zi, ")"));
function Vi(e2) {
  var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
  if (O$5(e2)) return false;
  if (R$4(e2)) {
    if (e2 = b$5(e2), (t2 ? Hi : Ui).test((e2 || "").replace(/[- ]/g, ""))) return false;
    if ((t2 ? ji : Wi).test(e2)) return false;
  }
  return true;
}
function Gi(e2) {
  var t2 = Oi(e2);
  return Vi(t2 = "".concat(t2, " ").concat(Ji(e2)).trim()) ? t2 : "";
}
function Ji(e2) {
  var t2 = "";
  return e2 && e2.childNodes && e2.childNodes.length && Y$2(e2.childNodes, function(e3) {
    var i2;
    if (e3 && "span" === (null === (i2 = e3.tagName) || void 0 === i2 ? void 0 : i2.toLowerCase())) try {
      var n2 = Oi(e3);
      t2 = "".concat(t2, " ").concat(n2).trim(), e3.childNodes && e3.childNodes.length && (t2 = "".concat(t2, " ").concat(Ji(e3)).trim());
    } catch (e4) {
      q$2.error("[AutoCapture]", e4);
    }
  }), t2;
}
function Yi(e2) {
  return function(e3) {
    var t2 = e3.map((e4) => {
      var t3, i2, n2 = "";
      if (e4.tag_name && (n2 += e4.tag_name), e4.attr_class) for (var r2 of (e4.attr_class.sort(), e4.attr_class)) n2 += ".".concat(r2.replace(/"/g, ""));
      var s2 = j$5(j$5(j$5(j$5({}, e4.text ? { text: e4.text } : {}), {}, { "nth-child": null !== (t3 = e4.nth_child) && void 0 !== t3 ? t3 : 0, "nth-of-type": null !== (i2 = e4.nth_of_type) && void 0 !== i2 ? i2 : 0 }, e4.href ? { href: e4.href } : {}), e4.attr_id ? { attr_id: e4.attr_id } : {}), e4.attributes), o22 = {};
      return X$4(s2).sort((e5, t4) => {
        var [i3] = e5, [n3] = t4;
        return i3.localeCompare(n3);
      }).forEach((e5) => {
        var [t4, i3] = e5;
        return o22[Ki(t4.toString())] = Ki(i3.toString());
      }), n2 += ":", n2 += X$4(s2).map((e5) => {
        var [t4, i3] = e5;
        return "".concat(t4, '="').concat(i3, '"');
      }).join("");
    });
    return t2.join(";");
  }(function(e3) {
    return e3.map((e4) => {
      var t2, i2, n2 = { text: null === (t2 = e4.$el_text) || void 0 === t2 ? void 0 : t2.slice(0, 400), tag_name: e4.tag_name, href: null === (i2 = e4.attr__href) || void 0 === i2 ? void 0 : i2.slice(0, 2048), attr_class: Xi(e4), attr_id: e4.attr__id, nth_child: e4.nth_child, nth_of_type: e4.nth_of_type, attributes: {} };
      return X$4(e4).filter((e5) => {
        var [t3] = e5;
        return 0 === t3.indexOf("attr__");
      }).forEach((e5) => {
        var [t3, i3] = e5;
        return n2.attributes[t3] = i3;
      }), n2;
    });
  }(e2));
}
function Ki(e2) {
  return e2.replace(/"|\\"/g, '\\"');
}
function Xi(e2) {
  var t2 = e2.attr__class;
  return t2 ? x$3(t2) ? t2 : Fi(t2) : void 0;
}
var Qi = "[SessionRecording]", Zi = "redacted", en = { initiatorTypes: ["audio", "beacon", "body", "css", "early-hint", "embed", "fetch", "frame", "iframe", "icon", "image", "img", "input", "link", "navigation", "object", "ping", "script", "track", "video", "xmlhttprequest"], maskRequestFn: (e2) => e2, recordHeaders: false, recordBody: false, recordInitialRequests: false, recordPerformance: false, performanceEntryTypeToObserve: ["first-input", "navigation", "paint", "resource"], payloadSizeLimitBytes: 1e6, payloadHostDenyList: [".lr-ingest.io", ".ingest.sentry.io", ".clarity.ms", "analytics.google.com"] }, tn = ["authorization", "x-forwarded-for", "authorization", "cookie", "set-cookie", "x-api-key", "x-real-ip", "remote-addr", "forwarded", "proxy-authorization", "x-csrf-token", "x-csrftoken", "x-xsrf-token"], nn = ["password", "secret", "passwd", "api_key", "apikey", "auth", "credentials", "mysql_pwd", "privatekey", "private_key", "token"], rn = ["/s/", "/e/", "/i/"];
function sn(e2, t2, i2, n2) {
  if (O$5(e2)) return e2;
  var r2 = (null == t2 ? void 0 : t2["content-length"]) || function(e3) {
    return new Blob([e3]).size;
  }(e2);
  return R$4(r2) && (r2 = parseInt(r2)), r2 > i2 ? Qi + " ".concat(n2, " body too large to record (").concat(r2, " bytes)") : e2;
}
function on(e2, t2) {
  if (O$5(e2)) return e2;
  var i2 = e2;
  return Vi(i2, false) || (i2 = Qi + " " + t2 + " body " + Zi), Y$2(nn, (e3) => {
    var n2, r2;
    null !== (n2 = i2) && void 0 !== n2 && n2.length && -1 !== (null === (r2 = i2) || void 0 === r2 ? void 0 : r2.indexOf(e3)) && (i2 = Qi + " " + t2 + " body " + Zi + " as might contain: " + e3);
  }), i2;
}
var an = (e2, t2) => {
  var i2, n2, r2, s2 = { payloadSizeLimitBytes: en.payloadSizeLimitBytes, performanceEntryTypeToObserve: [...en.performanceEntryTypeToObserve], payloadHostDenyList: [...t2.payloadHostDenyList || [], ...en.payloadHostDenyList] }, o22 = false !== e2.session_recording.recordHeaders && t2.recordHeaders, a22 = false !== e2.session_recording.recordBody && t2.recordBody, l22 = false !== e2.capture_performance && t2.recordPerformance, u22 = (i2 = s2, r2 = Math.min(1e6, null !== (n2 = i2.payloadSizeLimitBytes) && void 0 !== n2 ? n2 : 1e6), (e3) => (null != e3 && e3.requestBody && (e3.requestBody = sn(e3.requestBody, e3.requestHeaders, r2, "Request")), null != e3 && e3.responseBody && (e3.responseBody = sn(e3.responseBody, e3.responseHeaders, r2, "Response")), e3)), c2 = (t3) => {
    return u22(((e3, t4) => {
      var i4, n4 = vt$1(e3.name), r3 = 0 === t4.indexOf("http") ? null === (i4 = vt$1(t4)) || void 0 === i4 ? void 0 : i4.pathname : t4;
      "/" === r3 && (r3 = "");
      var s3 = null == n4 ? void 0 : n4.pathname.replace(r3 || "", "");
      if (!(n4 && s3 && rn.some((e4) => 0 === s3.indexOf(e4)))) return e3;
    })((n3 = (i3 = t3).requestHeaders, O$5(n3) || Y$2(Object.keys(null != n3 ? n3 : {}), (e3) => {
      tn.includes(e3.toLowerCase()) && (n3[e3] = Zi);
    }), i3), e2.api_host));
    var i3, n3;
  }, d22 = I$4(e2.session_recording.maskNetworkRequestFn);
  return d22 && I$4(e2.session_recording.maskCapturedNetworkRequestFn) && q$2.warn("Both `maskNetworkRequestFn` and `maskCapturedNetworkRequestFn` are defined. `maskNetworkRequestFn` will be ignored."), d22 && (e2.session_recording.maskCapturedNetworkRequestFn = (t3) => {
    var i3 = e2.session_recording.maskNetworkRequestFn({ url: t3.name });
    return j$5(j$5({}, t3), {}, { name: null == i3 ? void 0 : i3.url });
  }), s2.maskRequestFn = I$4(e2.session_recording.maskCapturedNetworkRequestFn) ? (t3) => {
    var i3, n3, r3, s3 = c2(t3);
    return s3 && null !== (i3 = null === (n3 = (r3 = e2.session_recording).maskCapturedNetworkRequestFn) || void 0 === n3 ? void 0 : n3.call(r3, s3)) && void 0 !== i3 ? i3 : void 0;
  } : (e3) => function(e4) {
    if (!F$4(e4)) return e4.requestBody = on(e4.requestBody, "Request"), e4.responseBody = on(e4.responseBody, "Response"), e4;
  }(c2(e3)), j$5(j$5(j$5({}, en), s2), {}, { recordHeaders: o22, recordBody: a22, recordPerformance: l22, recordInitialRequests: l22 });
};
function ln(e2, t2, i2, n2, r2) {
  return t2 > i2 && (q$2.warn("min cannot be greater than max."), t2 = i2), M$5(e2) ? e2 > i2 ? (n2 && q$2.warn(n2 + " cannot be  greater than max: " + i2 + ". Using max value instead."), i2) : e2 < t2 ? (n2 && q$2.warn(n2 + " cannot be less than min: " + t2 + ". Using min value instead."), t2) : e2 : (n2 && q$2.warn(n2 + " must be a number. using max or fallback. max: " + i2 + ", fallback: " + r2), ln(r2 || i2, t2, i2, n2));
}
class un {
  constructor(e2) {
    var t2, i2, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    W$3(this, "bucketSize", 100), W$3(this, "refillRate", 10), W$3(this, "mutationBuckets", {}), W$3(this, "loggedTracker", {}), W$3(this, "refillBuckets", () => {
      Object.keys(this.mutationBuckets).forEach((e3) => {
        this.mutationBuckets[e3] = this.mutationBuckets[e3] + this.refillRate, this.mutationBuckets[e3] >= this.bucketSize && delete this.mutationBuckets[e3];
      });
    }), W$3(this, "getNodeOrRelevantParent", (e3) => {
      var t3 = this.rrweb.mirror.getNode(e3);
      if ("svg" !== (null == t3 ? void 0 : t3.nodeName) && t3 instanceof Element) {
        var i3 = t3.closest("svg");
        if (i3) return [this.rrweb.mirror.getId(i3), i3];
      }
      return [e3, t3];
    }), W$3(this, "numberOfChanges", (e3) => {
      var t3, i3, n3, r2, s2, o22, a22, l22;
      return (null !== (t3 = null === (i3 = e3.removes) || void 0 === i3 ? void 0 : i3.length) && void 0 !== t3 ? t3 : 0) + (null !== (n3 = null === (r2 = e3.attributes) || void 0 === r2 ? void 0 : r2.length) && void 0 !== n3 ? n3 : 0) + (null !== (s2 = null === (o22 = e3.texts) || void 0 === o22 ? void 0 : o22.length) && void 0 !== s2 ? s2 : 0) + (null !== (a22 = null === (l22 = e3.adds) || void 0 === l22 ? void 0 : l22.length) && void 0 !== a22 ? a22 : 0);
    }), W$3(this, "throttleMutations", (e3) => {
      if (3 !== e3.type || 0 !== e3.data.source) return e3;
      var t3 = e3.data, i3 = this.numberOfChanges(t3);
      t3.attributes && (t3.attributes = t3.attributes.filter((e4) => {
        var t4, i4, n4, [r2, s2] = this.getNodeOrRelevantParent(e4.id);
        if (0 === this.mutationBuckets[r2]) return false;
        (this.mutationBuckets[r2] = null !== (t4 = this.mutationBuckets[r2]) && void 0 !== t4 ? t4 : this.bucketSize, this.mutationBuckets[r2] = Math.max(this.mutationBuckets[r2] - 1, 0), 0 === this.mutationBuckets[r2]) && (this.loggedTracker[r2] || (this.loggedTracker[r2] = true, null === (i4 = (n4 = this.options).onBlockedNode) || void 0 === i4 || i4.call(n4, r2, s2)));
        return e4;
      }));
      var n3 = this.numberOfChanges(t3);
      return 0 !== n3 || i3 === n3 ? e3 : void 0;
    }), this.rrweb = e2, this.options = n2, this.refillRate = ln(null !== (t2 = this.options.refillRate) && void 0 !== t2 ? t2 : this.refillRate, 0, 100, "mutation throttling refill rate"), this.bucketSize = ln(null !== (i2 = this.options.bucketSize) && void 0 !== i2 ? i2 : this.bucketSize, 0, 100, "mutation throttling bucket size"), setInterval(() => {
      this.refillBuckets();
    }, 1e3);
  }
}
var cn = Uint8Array, dn = Uint16Array, hn = Uint32Array, _n = new cn([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), pn = new cn([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), vn = new cn([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), gn = function(e2, t2) {
  for (var i2 = new dn(31), n2 = 0; n2 < 31; ++n2) i2[n2] = t2 += 1 << e2[n2 - 1];
  var r2 = new hn(i2[30]);
  for (n2 = 1; n2 < 30; ++n2) for (var s2 = i2[n2]; s2 < i2[n2 + 1]; ++s2) r2[s2] = s2 - i2[n2] << 5 | n2;
  return [i2, r2];
}, fn = gn(_n, 2), mn = fn[0], bn = fn[1];
mn[28] = 258, bn[258] = 28;
for (var yn = gn(pn, 0)[1], wn = new dn(32768), Sn = 0; Sn < 32768; ++Sn) {
  var En = (43690 & Sn) >>> 1 | (21845 & Sn) << 1;
  En = (61680 & (En = (52428 & En) >>> 2 | (13107 & En) << 2)) >>> 4 | (3855 & En) << 4, wn[Sn] = ((65280 & En) >>> 8 | (255 & En) << 8) >>> 1;
}
var kn = function(e2, t2, i2) {
  for (var n2 = e2.length, r2 = 0, s2 = new dn(t2); r2 < n2; ++r2) ++s2[e2[r2] - 1];
  var o22, a22 = new dn(t2);
  for (r2 = 0; r2 < t2; ++r2) a22[r2] = a22[r2 - 1] + s2[r2 - 1] << 1;
  for (o22 = new dn(n2), r2 = 0; r2 < n2; ++r2) o22[r2] = wn[a22[e2[r2] - 1]++] >>> 15 - e2[r2];
  return o22;
}, xn = new cn(288);
for (Sn = 0; Sn < 144; ++Sn) xn[Sn] = 8;
for (Sn = 144; Sn < 256; ++Sn) xn[Sn] = 9;
for (Sn = 256; Sn < 280; ++Sn) xn[Sn] = 7;
for (Sn = 280; Sn < 288; ++Sn) xn[Sn] = 8;
var In = new cn(32);
for (Sn = 0; Sn < 32; ++Sn) In[Sn] = 5;
var Cn = kn(xn, 9), Pn = kn(In, 5), Fn = function(e2) {
  return (e2 / 8 >> 0) + (7 & e2 && 1);
}, Rn = function(e2, t2, i2) {
  (null == i2 || i2 > e2.length) && (i2 = e2.length);
  var n2 = new (e2 instanceof dn ? dn : e2 instanceof hn ? hn : cn)(i2 - t2);
  return n2.set(e2.subarray(t2, i2)), n2;
}, Tn = function(e2, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i2, e2[n2 + 1] |= i2 >>> 8;
}, $n = function(e2, t2, i2) {
  i2 <<= 7 & t2;
  var n2 = t2 / 8 >> 0;
  e2[n2] |= i2, e2[n2 + 1] |= i2 >>> 8, e2[n2 + 2] |= i2 >>> 16;
}, On = function(e2, t2) {
  for (var i2 = [], n2 = 0; n2 < e2.length; ++n2) e2[n2] && i2.push({ s: n2, f: e2[n2] });
  var r2 = i2.length, s2 = i2.slice();
  if (!r2) return [new cn(0), 0];
  if (1 == r2) {
    var o22 = new cn(i2[0].s + 1);
    return o22[i2[0].s] = 1, [o22, 1];
  }
  i2.sort(function(e3, t3) {
    return e3.f - t3.f;
  }), i2.push({ s: -1, f: 25001 });
  var a22 = i2[0], l22 = i2[1], u22 = 0, c2 = 1, d22 = 2;
  for (i2[0] = { s: -1, f: a22.f + l22.f, l: a22, r: l22 }; c2 != r2 - 1; ) a22 = i2[i2[u22].f < i2[d22].f ? u22++ : d22++], l22 = i2[u22 != c2 && i2[u22].f < i2[d22].f ? u22++ : d22++], i2[c2++] = { s: -1, f: a22.f + l22.f, l: a22, r: l22 };
  var h22 = s2[0].s;
  for (n2 = 1; n2 < r2; ++n2) s2[n2].s > h22 && (h22 = s2[n2].s);
  var _2 = new dn(h22 + 1), p22 = Mn(i2[c2 - 1], _2, 0);
  if (p22 > t2) {
    n2 = 0;
    var v2 = 0, g2 = p22 - t2, f22 = 1 << g2;
    for (s2.sort(function(e3, t3) {
      return _2[t3.s] - _2[e3.s] || e3.f - t3.f;
    }); n2 < r2; ++n2) {
      var m22 = s2[n2].s;
      if (!(_2[m22] > t2)) break;
      v2 += f22 - (1 << p22 - _2[m22]), _2[m22] = t2;
    }
    for (v2 >>>= g2; v2 > 0; ) {
      var b2 = s2[n2].s;
      _2[b2] < t2 ? v2 -= 1 << t2 - _2[b2]++ - 1 : ++n2;
    }
    for (; n2 >= 0 && v2; --n2) {
      var y2 = s2[n2].s;
      _2[y2] == t2 && (--_2[y2], ++v2);
    }
    p22 = t2;
  }
  return [new cn(_2), p22];
}, Mn = function(e2, t2, i2) {
  return -1 == e2.s ? Math.max(Mn(e2.l, t2, i2 + 1), Mn(e2.r, t2, i2 + 1)) : t2[e2.s] = i2;
}, Ln = function(e2) {
  for (var t2 = e2.length; t2 && !e2[--t2]; ) ;
  for (var i2 = new dn(++t2), n2 = 0, r2 = e2[0], s2 = 1, o22 = function(e3) {
    i2[n2++] = e3;
  }, a22 = 1; a22 <= t2; ++a22) if (e2[a22] == r2 && a22 != t2) ++s2;
  else {
    if (!r2 && s2 > 2) {
      for (; s2 > 138; s2 -= 138) o22(32754);
      s2 > 2 && (o22(s2 > 10 ? s2 - 11 << 5 | 28690 : s2 - 3 << 5 | 12305), s2 = 0);
    } else if (s2 > 3) {
      for (o22(r2), --s2; s2 > 6; s2 -= 6) o22(8304);
      s2 > 2 && (o22(s2 - 3 << 5 | 8208), s2 = 0);
    }
    for (; s2--; ) o22(r2);
    s2 = 1, r2 = e2[a22];
  }
  return [i2.subarray(0, n2), t2];
}, An = function(e2, t2) {
  for (var i2 = 0, n2 = 0; n2 < t2.length; ++n2) i2 += e2[n2] * t2[n2];
  return i2;
}, Dn = function(e2, t2, i2) {
  var n2 = i2.length, r2 = Fn(t2 + 2);
  e2[r2] = 255 & n2, e2[r2 + 1] = n2 >>> 8, e2[r2 + 2] = 255 ^ e2[r2], e2[r2 + 3] = 255 ^ e2[r2 + 1];
  for (var s2 = 0; s2 < n2; ++s2) e2[r2 + s2 + 4] = i2[s2];
  return 8 * (r2 + 4 + n2);
}, Nn = function(e2, t2, i2, n2, r2, s2, o22, a22, l22, u22, c2) {
  Tn(t2, c2++, i2), ++r2[256];
  for (var d22 = On(r2, 15), h22 = d22[0], _2 = d22[1], p22 = On(s2, 15), v2 = p22[0], g2 = p22[1], f22 = Ln(h22), m22 = f22[0], b2 = f22[1], y2 = Ln(v2), w2 = y2[0], S2 = y2[1], E2 = new dn(19), k2 = 0; k2 < m22.length; ++k2) E2[31 & m22[k2]]++;
  for (k2 = 0; k2 < w2.length; ++k2) E2[31 & w2[k2]]++;
  for (var x2 = On(E2, 7), I2 = x2[0], C2 = x2[1], P22 = 19; P22 > 4 && !I2[vn[P22 - 1]]; --P22) ;
  var F2, R2, T2, $2, O2 = u22 + 5 << 3, M2 = An(r2, xn) + An(s2, In) + o22, L2 = An(r2, h22) + An(s2, v2) + o22 + 14 + 3 * P22 + An(E2, I2) + (2 * E2[16] + 3 * E2[17] + 7 * E2[18]);
  if (O2 <= M2 && O2 <= L2) return Dn(t2, c2, e2.subarray(l22, l22 + u22));
  if (Tn(t2, c2, 1 + (L2 < M2)), c2 += 2, L2 < M2) {
    F2 = kn(h22, _2), R2 = h22, T2 = kn(v2, g2), $2 = v2;
    var A2 = kn(I2, C2);
    Tn(t2, c2, b2 - 257), Tn(t2, c2 + 5, S2 - 1), Tn(t2, c2 + 10, P22 - 4), c2 += 14;
    for (k2 = 0; k2 < P22; ++k2) Tn(t2, c2 + 3 * k2, I2[vn[k2]]);
    c2 += 3 * P22;
    for (var D2 = [m22, w2], N2 = 0; N2 < 2; ++N2) {
      var q2 = D2[N2];
      for (k2 = 0; k2 < q2.length; ++k2) {
        var B2 = 31 & q2[k2];
        Tn(t2, c2, A2[B2]), c2 += I2[B2], B2 > 15 && (Tn(t2, c2, q2[k2] >>> 5 & 127), c2 += q2[k2] >>> 12);
      }
    }
  } else F2 = Cn, R2 = xn, T2 = Pn, $2 = In;
  for (k2 = 0; k2 < a22; ++k2) if (n2[k2] > 255) {
    B2 = n2[k2] >>> 18 & 31;
    $n(t2, c2, F2[B2 + 257]), c2 += R2[B2 + 257], B2 > 7 && (Tn(t2, c2, n2[k2] >>> 23 & 31), c2 += _n[B2]);
    var H2 = 31 & n2[k2];
    $n(t2, c2, T2[H2]), c2 += $2[H2], H2 > 3 && ($n(t2, c2, n2[k2] >>> 5 & 8191), c2 += pn[H2]);
  } else $n(t2, c2, F2[n2[k2]]), c2 += R2[n2[k2]];
  return $n(t2, c2, F2[256]), c2 + R2[256];
}, qn = new hn([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), Bn = function() {
  for (var e2 = new hn(256), t2 = 0; t2 < 256; ++t2) {
    for (var i2 = t2, n2 = 9; --n2; ) i2 = (1 & i2 && 3988292384) ^ i2 >>> 1;
    e2[t2] = i2;
  }
  return e2;
}(), Hn = function() {
  var e2 = 4294967295;
  return { p: function(t2) {
    for (var i2 = e2, n2 = 0; n2 < t2.length; ++n2) i2 = Bn[255 & i2 ^ t2[n2]] ^ i2 >>> 8;
    e2 = i2;
  }, d: function() {
    return 4294967295 ^ e2;
  } };
}, Un = function(e2, t2, i2, n2, r2) {
  return function(e3, t3, i3, n3, r3, s2) {
    var o22 = e3.length, a22 = new cn(n3 + o22 + 5 * (1 + Math.floor(o22 / 7e3)) + r3), l22 = a22.subarray(n3, a22.length - r3), u22 = 0;
    if (!t3 || o22 < 8) for (var c2 = 0; c2 <= o22; c2 += 65535) {
      var d22 = c2 + 65535;
      d22 < o22 ? u22 = Dn(l22, u22, e3.subarray(c2, d22)) : (l22[c2] = s2, u22 = Dn(l22, u22, e3.subarray(c2, o22)));
    }
    else {
      for (var h22 = qn[t3 - 1], _2 = h22 >>> 13, p22 = 8191 & h22, v2 = (1 << i3) - 1, g2 = new dn(32768), f22 = new dn(v2 + 1), m22 = Math.ceil(i3 / 3), b2 = 2 * m22, y2 = function(t4) {
        return (e3[t4] ^ e3[t4 + 1] << m22 ^ e3[t4 + 2] << b2) & v2;
      }, w2 = new hn(25e3), S2 = new dn(288), E2 = new dn(32), k2 = 0, x2 = 0, I2 = (c2 = 0, 0), C2 = 0, P22 = 0; c2 < o22; ++c2) {
        var F2 = y2(c2), R2 = 32767 & c2, T2 = f22[F2];
        if (g2[R2] = T2, f22[F2] = R2, C2 <= c2) {
          var $2 = o22 - c2;
          if ((k2 > 7e3 || I2 > 24576) && $2 > 423) {
            u22 = Nn(e3, l22, 0, w2, S2, E2, x2, I2, P22, c2 - P22, u22), I2 = k2 = x2 = 0, P22 = c2;
            for (var O2 = 0; O2 < 286; ++O2) S2[O2] = 0;
            for (O2 = 0; O2 < 30; ++O2) E2[O2] = 0;
          }
          var M2 = 2, L2 = 0, A2 = p22, D2 = R2 - T2 & 32767;
          if ($2 > 2 && F2 == y2(c2 - D2)) for (var N2 = Math.min(_2, $2) - 1, q2 = Math.min(32767, c2), B2 = Math.min(258, $2); D2 <= q2 && --A2 && R2 != T2; ) {
            if (e3[c2 + M2] == e3[c2 + M2 - D2]) {
              for (var H2 = 0; H2 < B2 && e3[c2 + H2] == e3[c2 + H2 - D2]; ++H2) ;
              if (H2 > M2) {
                if (M2 = H2, L2 = D2, H2 > N2) break;
                var U2 = Math.min(D2, H2 - 2), z2 = 0;
                for (O2 = 0; O2 < U2; ++O2) {
                  var j2 = c2 - D2 + O2 + 32768 & 32767, W2 = j2 - g2[j2] + 32768 & 32767;
                  W2 > z2 && (z2 = W2, T2 = j2);
                }
              }
            }
            D2 += (R2 = T2) - (T2 = g2[R2]) + 32768 & 32767;
          }
          if (L2) {
            w2[I2++] = 268435456 | bn[M2] << 18 | yn[L2];
            var V2 = 31 & bn[M2], G2 = 31 & yn[L2];
            x2 += _n[V2] + pn[G2], ++S2[257 + V2], ++E2[G2], C2 = c2 + M2, ++k2;
          } else w2[I2++] = e3[c2], ++S2[e3[c2]];
        }
      }
      u22 = Nn(e3, l22, s2, w2, S2, E2, x2, I2, P22, c2 - P22, u22);
    }
    return Rn(a22, 0, n3 + Fn(u22) + r3);
  }(e2, null == t2.level ? 6 : t2.level, null == t2.mem ? Math.ceil(1.5 * Math.max(8, Math.min(13, Math.log(e2.length)))) : 12 + t2.mem, i2, n2, true);
}, zn = function(e2, t2, i2) {
  for (; i2; ++t2) e2[t2] = i2, i2 >>>= 8;
}, jn = function(e2, t2) {
  var i2 = t2.filename;
  if (e2[0] = 31, e2[1] = 139, e2[2] = 8, e2[8] = t2.level < 2 ? 4 : 9 == t2.level ? 2 : 0, e2[9] = 3, 0 != t2.mtime && zn(e2, 4, Math.floor(new Date(t2.mtime || Date.now()) / 1e3)), i2) {
    e2[3] = 8;
    for (var n2 = 0; n2 <= i2.length; ++n2) e2[n2 + 10] = i2.charCodeAt(n2);
  }
}, Wn = function(e2) {
  return 10 + (e2.filename && e2.filename.length + 1 || 0);
};
function Vn(e2, t2) {
  void 0 === t2 && (t2 = {});
  var i2 = Hn(), n2 = e2.length;
  i2.p(e2);
  var r2 = Un(e2, t2, Wn(t2), 8), s2 = r2.length;
  return jn(r2, t2), zn(r2, s2 - 8, i2.d()), zn(r2, s2 - 4, n2), r2;
}
function Gn(e2, t2) {
  var i2 = e2.length;
  if ("undefined" != typeof TextEncoder) return new TextEncoder().encode(e2);
  for (var n2 = new cn(e2.length + (e2.length >>> 1)), r2 = 0, s2 = function(e3) {
    n2[r2++] = e3;
  }, o22 = 0; o22 < i2; ++o22) {
    if (r2 + 5 > n2.length) {
      var a22 = new cn(r2 + 8 + (i2 - o22 << 1));
      a22.set(n2), n2 = a22;
    }
    var l22 = e2.charCodeAt(o22);
    l22 < 128 || t2 ? s2(l22) : l22 < 2048 ? (s2(192 | l22 >>> 6), s2(128 | 63 & l22)) : l22 > 55295 && l22 < 57344 ? (s2(240 | (l22 = 65536 + (1047552 & l22) | 1023 & e2.charCodeAt(++o22)) >>> 18), s2(128 | l22 >>> 12 & 63), s2(128 | l22 >>> 6 & 63), s2(128 | 63 & l22)) : (s2(224 | l22 >>> 12), s2(128 | l22 >>> 6 & 63), s2(128 | 63 & l22));
  }
  return Rn(n2, 0, r2);
}
var Jn = "[SessionRecording]", Yn = B$1(Jn), Kn = 3e5, Xn = [Ei.MouseMove, Ei.MouseInteraction, Ei.Scroll, Ei.ViewportResize, Ei.Input, Ei.TouchMove, Ei.MediaInteraction, Ei.Drag], Qn = (e2) => ({ rrwebMethod: e2, enqueuedAt: Date.now(), attempt: 1 });
function Zn(e2) {
  return function(e3, t2) {
    for (var i2 = "", n2 = 0; n2 < e3.length; ) {
      var r2 = e3[n2++];
      i2 += String.fromCharCode(r2);
    }
    return i2;
  }(Vn(Gn(JSON.stringify(e2))));
}
function er(e2) {
  return e2.type === Si.Custom && "sessionIdle" === e2.data.tag;
}
function tr(e2, t2) {
  return t2.some((t3) => "regex" === t3.matching && new RegExp(t3.url).test(e2));
}
class ir {
  get sessionIdleThresholdMilliseconds() {
    return this.instance.config.session_recording.session_idle_threshold_ms || 3e5;
  }
  get rrwebRecord() {
    var e2, t2;
    return null == _$4 || null === (e2 = _$4.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrweb) || void 0 === t2 ? void 0 : t2.record;
  }
  get started() {
    return this._captureStarted;
  }
  get sessionManager() {
    if (!this.instance.sessionManager) throw new Error(Jn + " must be started with a valid sessionManager.");
    return this.instance.sessionManager;
  }
  get fullSnapshotIntervalMillis() {
    var e2, t2;
    return "trigger_pending" === this.triggerStatus ? 6e4 : null !== (e2 = null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.full_snapshot_interval_millis) && void 0 !== e2 ? e2 : Kn;
  }
  get isSampled() {
    var e2 = this.instance.get_property(we);
    return L$3(e2) ? e2 : null;
  }
  get sessionDuration() {
    var e2, t2, i2 = null === (e2 = this.buffer) || void 0 === e2 ? void 0 : e2.data[(null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) - 1], { sessionStartTimestamp: n2 } = this.sessionManager.checkAndGetSessionAndWindowId(true);
    return i2 ? i2.timestamp - n2 : null;
  }
  get isRecordingEnabled() {
    var e2 = !!this.instance.get_property(_e$1), i2 = !this.instance.config.disable_session_recording;
    return t$5 && e2 && i2;
  }
  get isConsoleLogCaptureEnabled() {
    var e2 = !!this.instance.get_property(pe$2), t2 = this.instance.config.enable_recording_console_log;
    return null != t2 ? t2 : e2;
  }
  get canvasRecording() {
    var e2, t2, i2, n2, r2, s2, o22 = this.instance.config.session_recording.captureCanvas, a22 = this.instance.get_property(ge$2), l22 = null !== (e2 = null !== (t2 = null == o22 ? void 0 : o22.recordCanvas) && void 0 !== t2 ? t2 : null == a22 ? void 0 : a22.enabled) && void 0 !== e2 && e2, u22 = null !== (i2 = null !== (n2 = null == o22 ? void 0 : o22.canvasFps) && void 0 !== n2 ? n2 : null == a22 ? void 0 : a22.fps) && void 0 !== i2 ? i2 : 0, c2 = null !== (r2 = null !== (s2 = null == o22 ? void 0 : o22.canvasQuality) && void 0 !== s2 ? s2 : null == a22 ? void 0 : a22.quality) && void 0 !== r2 ? r2 : 0;
    return { enabled: l22, fps: ln(u22, 0, 12, "canvas recording fps"), quality: ln(c2, 0, 1, "canvas recording quality") };
  }
  get networkPayloadCapture() {
    var e2, t2, i2 = this.instance.get_property(ve$1), n2 = { recordHeaders: null === (e2 = this.instance.config.session_recording) || void 0 === e2 ? void 0 : e2.recordHeaders, recordBody: null === (t2 = this.instance.config.session_recording) || void 0 === t2 ? void 0 : t2.recordBody }, r2 = (null == n2 ? void 0 : n2.recordHeaders) || (null == i2 ? void 0 : i2.recordHeaders), s2 = (null == n2 ? void 0 : n2.recordBody) || (null == i2 ? void 0 : i2.recordBody), o22 = C$4(this.instance.config.capture_performance) ? this.instance.config.capture_performance.network_timing : this.instance.config.capture_performance, a22 = !!(L$3(o22) ? o22 : null == i2 ? void 0 : i2.capturePerformance);
    return r2 || s2 || a22 ? { recordHeaders: r2, recordBody: s2, recordPerformance: a22 } : void 0;
  }
  get sampleRate() {
    var e2 = this.instance.get_property(fe$2);
    return M$5(e2) ? e2 : null;
  }
  get minimumDuration() {
    var e2 = this.instance.get_property(me$1);
    return M$5(e2) ? e2 : null;
  }
  get status() {
    return this.receivedDecide ? this.isRecordingEnabled ? this._urlBlocked ? "paused" : O$5(this._linkedFlag) || this._linkedFlagSeen ? "trigger_pending" === this.triggerStatus ? "buffering" : L$3(this.isSampled) ? this.isSampled ? "sampled" : "disabled" : "active" : "buffering" : "disabled" : "buffering";
  }
  get urlTriggerStatus() {
    var e2;
    return 0 === this._urlTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(Se$1)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get eventTriggerStatus() {
    var e2;
    return 0 === this._eventTriggers.length ? "trigger_disabled" : (null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2.get_property(Ee$2)) === this.sessionId ? "trigger_activated" : "trigger_pending";
  }
  get triggerStatus() {
    var e2 = "trigger_activated" === this.eventTriggerStatus || "trigger_activated" === this.urlTriggerStatus, t2 = "trigger_pending" === this.eventTriggerStatus || "trigger_pending" === this.urlTriggerStatus;
    return e2 ? "trigger_activated" : t2 ? "trigger_pending" : "trigger_disabled";
  }
  constructor(e2) {
    if (W$3(this, "queuedRRWebEvents", []), W$3(this, "isIdle", false), W$3(this, "_linkedFlagSeen", false), W$3(this, "_lastActivityTimestamp", Date.now()), W$3(this, "_linkedFlag", null), W$3(this, "_removePageViewCaptureHook", void 0), W$3(this, "_onSessionIdListener", void 0), W$3(this, "_persistDecideOnSessionListener", void 0), W$3(this, "_samplingSessionListener", void 0), W$3(this, "_urlTriggers", []), W$3(this, "_urlBlocklist", []), W$3(this, "_urlBlocked", false), W$3(this, "_eventTriggers", []), W$3(this, "_removeEventTriggerCaptureHook", void 0), W$3(this, "_forceAllowLocalhostNetworkCapture", false), W$3(this, "_onBeforeUnload", () => {
      this._flushBuffer();
    }), W$3(this, "_onOffline", () => {
      this._tryAddCustomEvent("browser offline", {});
    }), W$3(this, "_onOnline", () => {
      this._tryAddCustomEvent("browser online", {});
    }), W$3(this, "_onVisibilityChange", () => {
      if (null != a$a && a$a.visibilityState) {
        var e3 = "window " + a$a.visibilityState;
        this._tryAddCustomEvent(e3, {});
      }
    }), this.instance = e2, this._captureStarted = false, this._endpoint = "/s/", this.stopRrweb = void 0, this.receivedDecide = false, !this.instance.sessionManager) throw Yn.error("started without valid sessionManager"), new Error(Jn + " started without valid sessionManager. This is a bug.");
    if (this.instance.config.__preview_experimental_cookieless_mode) throw new Error(Jn + " cannot be used with __preview_experimental_cookieless_mode.");
    var { sessionId: t2, windowId: i2 } = this.sessionManager.checkAndGetSessionAndWindowId();
    this.sessionId = t2, this.windowId = i2, this.buffer = this.clearBuffer(), this.sessionIdleThresholdMilliseconds >= this.sessionManager.sessionTimeoutMs && Yn.warn("session_idle_threshold_ms (".concat(this.sessionIdleThresholdMilliseconds, ") is greater than the session timeout (").concat(this.sessionManager.sessionTimeoutMs, "). Session will never be detected as idle"));
  }
  startIfEnabledOrStop(e2) {
    this.isRecordingEnabled ? (this._startCapture(e2), null == t$5 || t$5.addEventListener("beforeunload", this._onBeforeUnload), null == t$5 || t$5.addEventListener("offline", this._onOffline), null == t$5 || t$5.addEventListener("online", this._onOnline), null == t$5 || t$5.addEventListener("visibilitychange", this._onVisibilityChange), this._setupSampling(), this._addEventTriggerListener(), O$5(this._removePageViewCaptureHook) && (this._removePageViewCaptureHook = this.instance.on("eventCaptured", (e3) => {
      try {
        if ("$pageview" === e3.event) {
          var t2 = null != e3 && e3.properties.$current_url ? this._maskUrl(null == e3 ? void 0 : e3.properties.$current_url) : "";
          if (!t2) return;
          this._tryAddCustomEvent("$pageview", { href: t2 });
        }
      } catch (e4) {
        Yn.error("Could not add $pageview to rrweb session", e4);
      }
    })), this._onSessionIdListener || (this._onSessionIdListener = this.sessionManager.onSessionId((e3, t2, i2) => {
      var n2, r2, s2, o22;
      i2 && (this._tryAddCustomEvent("$session_id_change", { sessionId: e3, windowId: t2, changeReason: i2 }), null === (n2 = this.instance) || void 0 === n2 || null === (r2 = n2.persistence) || void 0 === r2 || r2.unregister(Ee$2), null === (s2 = this.instance) || void 0 === s2 || null === (o22 = s2.persistence) || void 0 === o22 || o22.unregister(Se$1));
    }))) : this.stopRecording();
  }
  stopRecording() {
    var e2, i2, n2, r2;
    this._captureStarted && this.stopRrweb && (this.stopRrweb(), this.stopRrweb = void 0, this._captureStarted = false, null == t$5 || t$5.removeEventListener("beforeunload", this._onBeforeUnload), null == t$5 || t$5.removeEventListener("offline", this._onOffline), null == t$5 || t$5.removeEventListener("online", this._onOnline), null == t$5 || t$5.removeEventListener("visibilitychange", this._onVisibilityChange), this.clearBuffer(), clearInterval(this._fullSnapshotTimer), null === (e2 = this._removePageViewCaptureHook) || void 0 === e2 || e2.call(this), this._removePageViewCaptureHook = void 0, null === (i2 = this._removeEventTriggerCaptureHook) || void 0 === i2 || i2.call(this), this._removeEventTriggerCaptureHook = void 0, null === (n2 = this._onSessionIdListener) || void 0 === n2 || n2.call(this), this._onSessionIdListener = void 0, null === (r2 = this._samplingSessionListener) || void 0 === r2 || r2.call(this), this._samplingSessionListener = void 0, Yn.info("stopped"));
  }
  makeSamplingDecision(e2) {
    var t2, i2 = this.sessionId !== e2, n2 = this.sampleRate;
    if (M$5(n2)) {
      var r2, s2 = this.isSampled, o22 = i2 || !L$3(s2);
      if (o22) r2 = Math.random() < n2;
      else r2 = s2;
      o22 && (r2 ? this._reportStarted("sampled") : Yn.warn("Sample rate (".concat(n2, ") has determined that this sessionId (").concat(e2, ") will not be sent to the server.")), this._tryAddCustomEvent("samplingDecisionMade", { sampleRate: n2, isSampled: r2 })), null === (t2 = this.instance.persistence) || void 0 === t2 || t2.register({ [we]: r2 });
    } else {
      var a22;
      null === (a22 = this.instance.persistence) || void 0 === a22 || a22.register({ [we]: null });
    }
  }
  onRemoteConfig(e2) {
    var t2, i2, n2, r2, s2, o22;
    (this._tryAddCustomEvent("$remote_config_received", e2), this._persistRemoteConfig(e2), this._linkedFlag = (null === (t2 = e2.sessionRecording) || void 0 === t2 ? void 0 : t2.linkedFlag) || null, null !== (i2 = e2.sessionRecording) && void 0 !== i2 && i2.endpoint) && (this._endpoint = null === (o22 = e2.sessionRecording) || void 0 === o22 ? void 0 : o22.endpoint);
    if (this._setupSampling(), !O$5(this._linkedFlag) && !this._linkedFlagSeen) {
      var a22 = R$4(this._linkedFlag) ? this._linkedFlag : this._linkedFlag.flag, l22 = R$4(this._linkedFlag) ? null : this._linkedFlag.variant;
      this.instance.onFeatureFlags((e3, t3) => {
        var i3 = C$4(t3) && a22 in t3, n3 = l22 ? t3[a22] === l22 : i3;
        n3 && this._reportStarted("linked_flag_matched", { linkedFlag: a22, linkedVariant: l22 }), this._linkedFlagSeen = n3;
      });
    }
    null !== (n2 = e2.sessionRecording) && void 0 !== n2 && n2.urlTriggers && (this._urlTriggers = e2.sessionRecording.urlTriggers), null !== (r2 = e2.sessionRecording) && void 0 !== r2 && r2.urlBlocklist && (this._urlBlocklist = e2.sessionRecording.urlBlocklist), null !== (s2 = e2.sessionRecording) && void 0 !== s2 && s2.eventTriggers && (this._eventTriggers = e2.sessionRecording.eventTriggers), this.receivedDecide = true, this.startIfEnabledOrStop();
  }
  _setupSampling() {
    M$5(this.sampleRate) && O$5(this._samplingSessionListener) && (this._samplingSessionListener = this.sessionManager.onSessionId((e2) => {
      this.makeSamplingDecision(e2);
    }));
  }
  _persistRemoteConfig(e2) {
    if (this.instance.persistence) {
      var t2, i2 = this.instance.persistence, n2 = () => {
        var t3, n3, r2, s2, o22, a22, l22, u22, c2 = null === (t3 = e2.sessionRecording) || void 0 === t3 ? void 0 : t3.sampleRate, d22 = O$5(c2) ? null : parseFloat(c2), h22 = null === (n3 = e2.sessionRecording) || void 0 === n3 ? void 0 : n3.minimumDurationMilliseconds;
        i2.register({ [_e$1]: !!e2.sessionRecording, [pe$2]: null === (r2 = e2.sessionRecording) || void 0 === r2 ? void 0 : r2.consoleLogRecordingEnabled, [ve$1]: j$5({ capturePerformance: e2.capturePerformance }, null === (s2 = e2.sessionRecording) || void 0 === s2 ? void 0 : s2.networkPayloadCapture), [ge$2]: { enabled: null === (o22 = e2.sessionRecording) || void 0 === o22 ? void 0 : o22.recordCanvas, fps: null === (a22 = e2.sessionRecording) || void 0 === a22 ? void 0 : a22.canvasFps, quality: null === (l22 = e2.sessionRecording) || void 0 === l22 ? void 0 : l22.canvasQuality }, [fe$2]: d22, [me$1]: F$4(h22) ? null : h22, [be$3]: null === (u22 = e2.sessionRecording) || void 0 === u22 ? void 0 : u22.scriptConfig });
      };
      n2(), null === (t2 = this._persistDecideOnSessionListener) || void 0 === t2 || t2.call(this), this._persistDecideOnSessionListener = this.sessionManager.onSessionId(n2);
    }
  }
  log(e2) {
    var t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "log";
    null === (t2 = this.instance.sessionRecording) || void 0 === t2 || t2.onRRwebEmit({ type: 6, data: { plugin: "rrweb/console@1", payload: { level: i2, trace: [], payload: [JSON.stringify(e2)] } }, timestamp: Date.now() });
  }
  _startCapture(e2) {
    if (!F$4(Object.assign) && !F$4(Array.from) && !(this._captureStarted || this.instance.config.disable_session_recording || this.instance.consent.isOptedOut())) {
      var t2, i2;
      if (this._captureStarted = true, this.sessionManager.checkAndGetSessionAndWindowId(), this.rrwebRecord) this._onScriptLoaded();
      else null === (t2 = _$4.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, this.scriptName, (e3) => {
        if (e3) return Yn.error("could not load recorder", e3);
        this._onScriptLoaded();
      });
      Yn.info("starting"), "active" === this.status && this._reportStarted(e2 || "recording_initialized");
    }
  }
  get scriptName() {
    var e2, t2, i2;
    return (null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 || null === (i2 = t2.get_property(be$3)) || void 0 === i2 ? void 0 : i2.script) || "recorder";
  }
  isInteractiveEvent(e2) {
    var t2;
    return 3 === e2.type && -1 !== Xn.indexOf(null === (t2 = e2.data) || void 0 === t2 ? void 0 : t2.source);
  }
  _updateWindowAndSessionIds(e2) {
    var t2 = this.isInteractiveEvent(e2);
    t2 || this.isIdle || e2.timestamp - this._lastActivityTimestamp > this.sessionIdleThresholdMilliseconds && (this.isIdle = true, clearInterval(this._fullSnapshotTimer), this._tryAddCustomEvent("sessionIdle", { eventTimestamp: e2.timestamp, lastActivityTimestamp: this._lastActivityTimestamp, threshold: this.sessionIdleThresholdMilliseconds, bufferLength: this.buffer.data.length, bufferSize: this.buffer.size }), this._flushBuffer());
    var i2 = false;
    if (t2 && (this._lastActivityTimestamp = e2.timestamp, this.isIdle && (this.isIdle = false, this._tryAddCustomEvent("sessionNoLongerIdle", { reason: "user activity", type: e2.type }), i2 = true)), !this.isIdle) {
      var { windowId: n2, sessionId: r2 } = this.sessionManager.checkAndGetSessionAndWindowId(!t2, e2.timestamp), s2 = this.sessionId !== r2, o22 = this.windowId !== n2;
      this.windowId = n2, this.sessionId = r2, s2 || o22 ? (this.stopRecording(), this.startIfEnabledOrStop("session_id_changed")) : i2 && this._scheduleFullSnapshot();
    }
  }
  _tryRRWebMethod(e2) {
    try {
      return e2.rrwebMethod(), true;
    } catch (t2) {
      return this.queuedRRWebEvents.length < 10 ? this.queuedRRWebEvents.push({ enqueuedAt: e2.enqueuedAt || Date.now(), attempt: e2.attempt++, rrwebMethod: e2.rrwebMethod }) : Yn.warn("could not emit queued rrweb event.", t2, e2), false;
    }
  }
  _tryAddCustomEvent(e2, t2) {
    return this._tryRRWebMethod(Qn(() => this.rrwebRecord.addCustomEvent(e2, t2)));
  }
  _tryTakeFullSnapshot() {
    return this._tryRRWebMethod(Qn(() => this.rrwebRecord.takeFullSnapshot()));
  }
  _onScriptLoaded() {
    var e2, t2 = { blockClass: "ph-no-capture", blockSelector: void 0, ignoreClass: "ph-ignore-input", maskTextClass: "ph-mask", maskTextSelector: void 0, maskTextFn: void 0, maskAllInputs: true, maskInputOptions: { password: true }, maskInputFn: void 0, slimDOMOptions: {}, collectFonts: false, inlineStylesheet: true, recordCrossOriginIframes: false }, i2 = this.instance.config.session_recording;
    for (var [n2, r2] of Object.entries(i2 || {})) n2 in t2 && ("maskInputOptions" === n2 ? t2.maskInputOptions = j$5({ password: true }, r2) : t2[n2] = r2);
    if (this.canvasRecording && this.canvasRecording.enabled && (t2.recordCanvas = true, t2.sampling = { canvas: this.canvasRecording.fps }, t2.dataURLOptions = { type: "image/webp", quality: this.canvasRecording.quality }), this.rrwebRecord) {
      this.mutationRateLimiter = null !== (e2 = this.mutationRateLimiter) && void 0 !== e2 ? e2 : new un(this.rrwebRecord, { refillRate: this.instance.config.session_recording.__mutationRateLimiterRefillRate, bucketSize: this.instance.config.session_recording.__mutationRateLimiterBucketSize, onBlockedNode: (e3, t3) => {
        var i3 = "Too many mutations on node '".concat(e3, "'. Rate limiting. This could be due to SVG animations or something similar");
        Yn.info(i3, { node: t3 }), this.log(Jn + " " + i3, "warn");
      } });
      var s2 = this._gatherRRWebPlugins();
      this.stopRrweb = this.rrwebRecord(j$5({ emit: (e3) => {
        this.onRRwebEmit(e3);
      }, plugins: s2 }, t2)), this._lastActivityTimestamp = Date.now(), this.isIdle = false, this._tryAddCustomEvent("$session_options", { sessionRecordingOptions: t2, activePlugins: s2.map((e3) => null == e3 ? void 0 : e3.name) }), this._tryAddCustomEvent("$posthog_config", { config: this.instance.config });
    } else Yn.error("onScriptLoaded was called but rrwebRecord is not available. This indicates something has gone wrong.");
  }
  _scheduleFullSnapshot() {
    if (this._fullSnapshotTimer && clearInterval(this._fullSnapshotTimer), !this.isIdle) {
      var e2 = this.fullSnapshotIntervalMillis;
      e2 && (this._fullSnapshotTimer = setInterval(() => {
        this._tryTakeFullSnapshot();
      }, e2));
    }
  }
  _gatherRRWebPlugins() {
    var e2, t2, i2, n2, r2 = [], s2 = null === (e2 = _$4.__PosthogExtensions__) || void 0 === e2 || null === (t2 = e2.rrwebPlugins) || void 0 === t2 ? void 0 : t2.getRecordConsolePlugin;
    s2 && this.isConsoleLogCaptureEnabled && r2.push(s2());
    var o22 = null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.rrwebPlugins) || void 0 === n2 ? void 0 : n2.getRecordNetworkPlugin;
    this.networkPayloadCapture && I$4(o22) && (!pt$1.includes(location.hostname) || this._forceAllowLocalhostNetworkCapture ? r2.push(o22(an(this.instance.config, this.networkPayloadCapture))) : Yn.info("NetworkCapture not started because we are on localhost."));
    return r2;
  }
  onRRwebEmit(e2) {
    var t2;
    if (this._processQueuedEvents(), e2 && C$4(e2)) {
      if (e2.type === Si.Meta) {
        var i2 = this._maskUrl(e2.data.href);
        if (this._lastHref = i2, !i2) return;
        e2.data.href = i2;
      } else this._pageViewFallBack();
      if (this._checkUrlTriggerConditions(), "paused" !== this.status || function(e3) {
        return e3.type === Si.Custom && "recording paused" === e3.data.tag;
      }(e2)) {
        e2.type === Si.FullSnapshot && this._scheduleFullSnapshot(), e2.type === Si.FullSnapshot && "trigger_pending" === this.triggerStatus && this.clearBuffer();
        var n2 = this.mutationRateLimiter ? this.mutationRateLimiter.throttleMutations(e2) : e2;
        if (n2) {
          var r2 = function(e3) {
            var t3 = e3;
            if (t3 && C$4(t3) && 6 === t3.type && C$4(t3.data) && "rrweb/console@1" === t3.data.plugin) {
              t3.data.payload.payload.length > 10 && (t3.data.payload.payload = t3.data.payload.payload.slice(0, 10), t3.data.payload.payload.push("...[truncated]"));
              for (var i3 = [], n3 = 0; n3 < t3.data.payload.payload.length; n3++) t3.data.payload.payload[n3] && t3.data.payload.payload[n3].length > 2e3 ? i3.push(t3.data.payload.payload[n3].slice(0, 2e3) + "...[truncated]") : i3.push(t3.data.payload.payload[n3]);
              return t3.data.payload.payload = i3, e3;
            }
            return e3;
          }(n2);
          if (this._updateWindowAndSessionIds(r2), !this.isIdle || er(r2)) {
            if (er(r2)) {
              var s2 = r2.data.payload;
              if (s2) {
                var o22 = s2.lastActivityTimestamp, a22 = s2.threshold;
                r2.timestamp = o22 + a22;
              }
            }
            var l22 = null === (t2 = this.instance.config.session_recording.compress_events) || void 0 === t2 || t2 ? function(e3) {
              if (yi(e3) < 1024) return e3;
              try {
                if (e3.type === Si.FullSnapshot) return j$5(j$5({}, e3), {}, { data: Zn(e3.data), cv: "2024-10" });
                if (e3.type === Si.IncrementalSnapshot && e3.data.source === Ei.Mutation) return j$5(j$5({}, e3), {}, { cv: "2024-10", data: j$5(j$5({}, e3.data), {}, { texts: Zn(e3.data.texts), attributes: Zn(e3.data.attributes), removes: Zn(e3.data.removes), adds: Zn(e3.data.adds) }) });
                if (e3.type === Si.IncrementalSnapshot && e3.data.source === Ei.StyleSheetRule) return j$5(j$5({}, e3), {}, { cv: "2024-10", data: j$5(j$5({}, e3.data), {}, { adds: Zn(e3.data.adds), removes: Zn(e3.data.removes) }) });
              } catch (e4) {
                Yn.error("could not compress event - will use uncompressed event", e4);
              }
              return e3;
            }(r2) : r2, u22 = { $snapshot_bytes: yi(l22), $snapshot_data: l22, $session_id: this.sessionId, $window_id: this.windowId };
            "disabled" !== this.status ? this._captureSnapshotBuffered(u22) : this.clearBuffer();
          }
        }
      }
    }
  }
  _pageViewFallBack() {
    if (!this.instance.config.capture_pageview && t$5) {
      var e2 = this._maskUrl(t$5.location.href);
      this._lastHref !== e2 && (this._tryAddCustomEvent("$url_changed", { href: e2 }), this._lastHref = e2);
    }
  }
  _processQueuedEvents() {
    if (this.queuedRRWebEvents.length) {
      var e2 = [...this.queuedRRWebEvents];
      this.queuedRRWebEvents = [], e2.forEach((e3) => {
        Date.now() - e3.enqueuedAt <= 2e3 && this._tryRRWebMethod(e3);
      });
    }
  }
  _maskUrl(e2) {
    var t2 = this.instance.config.session_recording;
    if (t2.maskNetworkRequestFn) {
      var i2, n2 = { url: e2 };
      return null === (i2 = n2 = t2.maskNetworkRequestFn(n2)) || void 0 === i2 ? void 0 : i2.url;
    }
    return e2;
  }
  clearBuffer() {
    return this.buffer = { size: 0, data: [], sessionId: this.sessionId, windowId: this.windowId }, this.buffer;
  }
  _flushBuffer() {
    this.flushBufferTimer && (clearTimeout(this.flushBufferTimer), this.flushBufferTimer = void 0);
    var e2 = this.minimumDuration, t2 = this.sessionDuration, i2 = M$5(t2) && t2 >= 0, n2 = M$5(e2) && i2 && t2 < e2;
    if ("buffering" === this.status || "paused" === this.status || n2) return this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3), this.buffer;
    this.buffer.data.length > 0 && wi(this.buffer).forEach((e3) => {
      this._captureSnapshot({ $snapshot_bytes: e3.size, $snapshot_data: e3.data, $session_id: e3.sessionId, $window_id: e3.windowId, $lib: "web", $lib_version: p$5.LIB_VERSION });
    });
    return this.clearBuffer();
  }
  _captureSnapshotBuffered(e2) {
    var t2, i2 = 2 + ((null === (t2 = this.buffer) || void 0 === t2 ? void 0 : t2.data.length) || 0);
    !this.isIdle && (this.buffer.size + e2.$snapshot_bytes + i2 > 943718.4 || this.buffer.sessionId !== this.sessionId) && (this.buffer = this._flushBuffer()), this.buffer.size += e2.$snapshot_bytes, this.buffer.data.push(e2.$snapshot_data), this.flushBufferTimer || this.isIdle || (this.flushBufferTimer = setTimeout(() => {
      this._flushBuffer();
    }, 2e3));
  }
  _captureSnapshot(e2) {
    this.instance.capture("$snapshot", e2, { _url: this.instance.requestRouter.endpointFor("api", this._endpoint), _noTruncate: true, _batchKey: "recordings", skip_client_rate_limiting: true });
  }
  _checkUrlTriggerConditions() {
    if (void 0 !== t$5 && t$5.location.href) {
      var e2 = t$5.location.href, i2 = "paused" === this.status, n2 = tr(e2, this._urlBlocklist);
      n2 && !i2 ? this._pauseRecording() : !n2 && i2 && this._resumeRecording(), tr(e2, this._urlTriggers) && this._activateTrigger("url");
    }
  }
  _activateTrigger(e2) {
    var t2, i2;
    "trigger_pending" === this.triggerStatus && (null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 || i2.register({ ["url" === e2 ? Se$1 : Ee$2]: this.sessionId }), this._flushBuffer(), this._reportStarted(e2 + "_trigger_matched"));
  }
  _pauseRecording() {
    "paused" !== this.status && (this._urlBlocked = true, clearInterval(this._fullSnapshotTimer), Yn.info("recording paused due to URL blocker"), this._tryAddCustomEvent("recording paused", { reason: "url blocker" }));
  }
  _resumeRecording() {
    "paused" === this.status && (this._urlBlocked = false, this._tryTakeFullSnapshot(), this._scheduleFullSnapshot(), this._tryAddCustomEvent("recording resumed", { reason: "left blocked url" }), Yn.info("recording resumed"));
  }
  _addEventTriggerListener() {
    0 !== this._eventTriggers.length && O$5(this._removeEventTriggerCaptureHook) && (this._removeEventTriggerCaptureHook = this.instance.on("eventCaptured", (e2) => {
      try {
        this._eventTriggers.includes(e2.event) && this._activateTrigger("event");
      } catch (e3) {
        Yn.error("Could not activate event trigger", e3);
      }
    }));
  }
  overrideLinkedFlag() {
    this._linkedFlagSeen = true, this._tryTakeFullSnapshot(), this._reportStarted("linked_flag_overridden");
  }
  overrideSampling() {
    var e2;
    null === (e2 = this.instance.persistence) || void 0 === e2 || e2.register({ [we]: true }), this._tryTakeFullSnapshot(), this._reportStarted("sampling_overridden");
  }
  overrideTrigger(e2) {
    this._activateTrigger(e2);
  }
  _reportStarted(e2, t2) {
    this.instance.register_for_session({ $session_recording_start_reason: e2 }), Yn.info(e2.replace("_", " "), t2), m$5(["recording_initialized", "session_id_changed"], e2) || this._tryAddCustomEvent(e2, t2);
  }
}
var nr = B$1("[RemoteConfig]");
class rr {
  constructor(e2) {
    this.instance = e2;
  }
  get remoteConfig() {
    var e2, t2;
    return null === (e2 = _$4._POSTHOG_REMOTE_CONFIG) || void 0 === e2 || null === (t2 = e2[this.instance.config.token]) || void 0 === t2 ? void 0 : t2.config;
  }
  _loadRemoteConfigJs(e2) {
    var t2, i2, n2;
    null !== (t2 = _$4.__PosthogExtensions__) && void 0 !== t2 && t2.loadExternalDependency ? null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "remote-config", () => e2(this.remoteConfig)) : (nr.error("PostHog Extensions not found. Cannot load remote config."), e2());
  }
  _loadRemoteConfigJSON(e2) {
    this.instance._send_request({ method: "GET", url: this.instance.requestRouter.endpointFor("assets", "/array/".concat(this.instance.config.token, "/config")), callback: (t2) => {
      e2(t2.json);
    } });
  }
  load() {
    try {
      if (this.remoteConfig) return nr.info("Using preloaded remote config", this.remoteConfig), void this.onRemoteConfig(this.remoteConfig);
      if (this.instance.config.advanced_disable_decide) return void nr.warn("Remote config is disabled. Falling back to local config.");
      this._loadRemoteConfigJs((e2) => {
        if (!e2) return nr.info("No config found after loading remote JS config. Falling back to JSON."), void this._loadRemoteConfigJSON((e3) => {
          this.onRemoteConfig(e3);
        });
        this.onRemoteConfig(e2);
      });
    } catch (e2) {
      nr.error("Error loading remote config", e2);
    }
  }
  onRemoteConfig(e2) {
    e2 ? this.instance.config.__preview_remote_config ? (this.instance._onRemoteConfig(e2), false !== e2.hasFeatureFlags && this.instance.featureFlags.ensureFlagsLoaded()) : nr.info("__preview_remote_config is disabled. Logging config instead", e2) : nr.error("Failed to fetch remote config from PostHog.");
  }
}
var sr, or = null != t$5 && t$5.location ? bt$1(t$5.location.hash, "__posthog") || bt$1(location.hash, "state") : null, ar = "_postHogToolbarParams", lr = B$1("[Toolbar]");
!function(e2) {
  e2[e2.UNINITIALIZED = 0] = "UNINITIALIZED", e2[e2.LOADING = 1] = "LOADING", e2[e2.LOADED = 2] = "LOADED";
}(sr || (sr = {}));
class ur {
  constructor(e2) {
    this.instance = e2;
  }
  setToolbarState(e2) {
    _$4.ph_toolbar_state = e2;
  }
  getToolbarState() {
    var e2;
    return null !== (e2 = _$4.ph_toolbar_state) && void 0 !== e2 ? e2 : sr.UNINITIALIZED;
  }
  maybeLoadToolbar() {
    var e2, i2, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, s2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    if (!t$5 || !a$a) return false;
    n2 = null !== (e2 = n2) && void 0 !== e2 ? e2 : t$5.location, s2 = null !== (i2 = s2) && void 0 !== i2 ? i2 : t$5.history;
    try {
      if (!r2) {
        try {
          t$5.localStorage.setItem("test", "test"), t$5.localStorage.removeItem("test");
        } catch (e3) {
          return false;
        }
        r2 = null == t$5 ? void 0 : t$5.localStorage;
      }
      var o22, l22 = or || bt$1(n2.hash, "__posthog") || bt$1(n2.hash, "state"), u22 = l22 ? Q$2(() => JSON.parse(atob(decodeURIComponent(l22)))) || Q$2(() => JSON.parse(decodeURIComponent(l22))) : null;
      return u22 && "ph_authorize" === u22.action ? ((o22 = u22).source = "url", o22 && Object.keys(o22).length > 0 && (u22.desiredHash ? n2.hash = u22.desiredHash : s2 ? s2.replaceState(s2.state, "", n2.pathname + n2.search) : n2.hash = "")) : ((o22 = JSON.parse(r2.getItem(ar) || "{}")).source = "localstorage", delete o22.userIntent), !(!o22.token || this.instance.config.token !== o22.token) && (this.loadToolbar(o22), true);
    } catch (e3) {
      return false;
    }
  }
  _callLoadToolbar(e2) {
    var t2 = _$4.ph_load_toolbar || _$4.ph_load_editor;
    !O$5(t2) && I$4(t2) ? t2(e2, this.instance) : lr.warn("No toolbar load function found");
  }
  loadToolbar(e2) {
    var i2 = !(null == a$a || !a$a.getElementById(Ne));
    if (!t$5 || i2) return false;
    var n2 = "custom" === this.instance.requestRouter.region && this.instance.config.advanced_disable_toolbar_metrics, r2 = j$5(j$5({ token: this.instance.config.token }, e2), {}, { apiURL: this.instance.requestRouter.endpointFor("ui") }, n2 ? { instrument: false } : {});
    if (t$5.localStorage.setItem(ar, JSON.stringify(j$5(j$5({}, r2), {}, { source: void 0 }))), this.getToolbarState() === sr.LOADED) this._callLoadToolbar(r2);
    else if (this.getToolbarState() === sr.UNINITIALIZED) {
      var s2, o22;
      this.setToolbarState(sr.LOADING), null === (s2 = _$4.__PosthogExtensions__) || void 0 === s2 || null === (o22 = s2.loadExternalDependency) || void 0 === o22 || o22.call(s2, this.instance, "toolbar", (e3) => {
        if (e3) return lr.error("[Toolbar] Failed to load", e3), void this.setToolbarState(sr.UNINITIALIZED);
        this.setToolbarState(sr.LOADED), this._callLoadToolbar(r2);
      }), ie$1(t$5, "turbolinks:load", () => {
        this.setToolbarState(sr.UNINITIALIZED), this.loadToolbar(r2);
      });
    }
    return true;
  }
  _loadEditor(e2) {
    return this.loadToolbar(e2);
  }
  maybeLoadEditor() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0;
    return this.maybeLoadToolbar(e2, t2, i2);
  }
}
class cr {
  constructor(e2) {
    W$3(this, "isPaused", true), W$3(this, "queue", []), W$3(this, "flushTimeoutMs", 3e3), this.sendRequest = e2;
  }
  enqueue(e2) {
    this.queue.push(e2), this.flushTimeout || this.setFlushTimeout();
  }
  unload() {
    this.clearFlushTimeout();
    var e2 = this.queue.length > 0 ? this.formatQueue() : {}, t2 = Object.values(e2), i2 = [...t2.filter((e3) => 0 === e3.url.indexOf("/e")), ...t2.filter((e3) => 0 !== e3.url.indexOf("/e"))];
    i2.map((e3) => {
      this.sendRequest(j$5(j$5({}, e3), {}, { transport: "sendBeacon" }));
    });
  }
  enable() {
    this.isPaused = false, this.setFlushTimeout();
  }
  setFlushTimeout() {
    var e2 = this;
    this.isPaused || (this.flushTimeout = setTimeout(() => {
      if (this.clearFlushTimeout(), this.queue.length > 0) {
        var t2 = this.formatQueue(), i2 = function(i3) {
          var n3 = t2[i3], r2 = (/* @__PURE__ */ new Date()).getTime();
          n3.data && x$3(n3.data) && Y$2(n3.data, (e3) => {
            e3.offset = Math.abs(e3.timestamp - r2), delete e3.timestamp;
          }), e2.sendRequest(n3);
        };
        for (var n2 in t2) i2(n2);
      }
    }, this.flushTimeoutMs));
  }
  clearFlushTimeout() {
    clearTimeout(this.flushTimeout), this.flushTimeout = void 0;
  }
  formatQueue() {
    var e2 = {};
    return Y$2(this.queue, (t2) => {
      var i2, n2 = t2, r2 = (n2 ? n2.batchKey : null) || n2.url;
      F$4(e2[r2]) && (e2[r2] = j$5(j$5({}, n2), {}, { data: [] })), null === (i2 = e2[r2].data) || void 0 === i2 || i2.push(n2.data);
    }), this.queue = [], e2;
  }
}
var dr = function(e2) {
  var t2, i2, n2, r2, s2 = "";
  for (t2 = i2 = 0, n2 = (e2 = (e2 + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n")).length, r2 = 0; r2 < n2; r2++) {
    var o22 = e2.charCodeAt(r2), a22 = null;
    o22 < 128 ? i2++ : a22 = o22 > 127 && o22 < 2048 ? String.fromCharCode(o22 >> 6 | 192, 63 & o22 | 128) : String.fromCharCode(o22 >> 12 | 224, o22 >> 6 & 63 | 128, 63 & o22 | 128), $$3(a22) || (i2 > t2 && (s2 += e2.substring(t2, i2)), s2 += a22, t2 = i2 = r2 + 1);
  }
  return i2 > t2 && (s2 += e2.substring(t2, e2.length)), s2;
}, hr = !!c$5 || !!u$8, _r = "text/plain", pr = (e2, t2) => {
  var [i2, n2] = e2.split("?"), r2 = j$5({}, t2);
  null == n2 || n2.split("&").forEach((e3) => {
    var [t3] = e3.split("=");
    delete r2[t3];
  });
  var s2 = ft$1(r2);
  return s2 = s2 ? (n2 ? n2 + "&" : "") + s2 : n2, "".concat(i2, "?").concat(s2);
}, vr = (e2, t2) => JSON.stringify(e2, (e3, t3) => "bigint" == typeof t3 ? t3.toString() : t3, t2), gr = (t2) => {
  var { data: i2, compression: n2 } = t2;
  if (i2) {
    if (n2 === e$5.GZipJS) {
      var r2 = Vn(Gn(vr(i2)), { mtime: 0 }), s2 = new Blob([r2], { type: _r });
      return { contentType: _r, body: s2, estimatedSize: s2.size };
    }
    if (n2 === e$5.Base64) {
      var o22 = function(e2) {
        var t3, i3, n3, r3, s3, o3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", a3 = 0, l3 = 0, u22 = "", c2 = [];
        if (!e2) return e2;
        e2 = dr(e2);
        do {
          t3 = (s3 = e2.charCodeAt(a3++) << 16 | e2.charCodeAt(a3++) << 8 | e2.charCodeAt(a3++)) >> 18 & 63, i3 = s3 >> 12 & 63, n3 = s3 >> 6 & 63, r3 = 63 & s3, c2[l3++] = o3.charAt(t3) + o3.charAt(i3) + o3.charAt(n3) + o3.charAt(r3);
        } while (a3 < e2.length);
        switch (u22 = c2.join(""), e2.length % 3) {
          case 1:
            u22 = u22.slice(0, -2) + "==";
            break;
          case 2:
            u22 = u22.slice(0, -1) + "=";
        }
        return u22;
      }(vr(i2)), a22 = ((e2) => "data=" + encodeURIComponent("string" == typeof e2 ? e2 : vr(e2)))(o22);
      return { contentType: "application/x-www-form-urlencoded", body: a22, estimatedSize: new Blob([a22]).size };
    }
    var l22 = vr(i2);
    return { contentType: "application/json", body: l22, estimatedSize: new Blob([l22]).size };
  }
}, fr = [];
u$8 && fr.push({ transport: "fetch", method: (e2) => {
  var t2, i2, { contentType: n2, body: r2, estimatedSize: s2 } = null !== (t2 = gr(e2)) && void 0 !== t2 ? t2 : {}, o22 = new Headers();
  Y$2(e2.headers, function(e3, t3) {
    o22.append(t3, e3);
  }), n2 && o22.append("Content-Type", n2);
  var a22 = e2.url, l22 = null;
  if (d$6) {
    var c2 = new d$6();
    l22 = { signal: c2.signal, timeout: setTimeout(() => c2.abort(), e2.timeout) };
  }
  u$8(a22, j$5({ method: (null == e2 ? void 0 : e2.method) || "GET", headers: o22, keepalive: "POST" === e2.method && (s2 || 0) < 52428.8, body: r2, signal: null === (i2 = l22) || void 0 === i2 ? void 0 : i2.signal }, e2.fetchOptions)).then((t3) => t3.text().then((i3) => {
    var n3, r3 = { statusCode: t3.status, text: i3 };
    if (200 === t3.status) try {
      r3.json = JSON.parse(i3);
    } catch (e3) {
      q$2.error(e3);
    }
    null === (n3 = e2.callback) || void 0 === n3 || n3.call(e2, r3);
  })).catch((t3) => {
    var i3;
    q$2.error(t3), null === (i3 = e2.callback) || void 0 === i3 || i3.call(e2, { statusCode: 0, text: t3 });
  }).finally(() => l22 ? clearTimeout(l22.timeout) : null);
} }), c$5 && fr.push({ transport: "XHR", method: (e2) => {
  var t2, i2 = new c$5();
  i2.open(e2.method || "GET", e2.url, true);
  var { contentType: n2, body: r2 } = null !== (t2 = gr(e2)) && void 0 !== t2 ? t2 : {};
  Y$2(e2.headers, function(e3, t3) {
    i2.setRequestHeader(t3, e3);
  }), n2 && i2.setRequestHeader("Content-Type", n2), e2.timeout && (i2.timeout = e2.timeout), i2.withCredentials = true, i2.onreadystatechange = () => {
    if (4 === i2.readyState) {
      var t3, n3 = { statusCode: i2.status, text: i2.responseText };
      if (200 === i2.status) try {
        n3.json = JSON.parse(i2.responseText);
      } catch (e3) {
      }
      null === (t3 = e2.callback) || void 0 === t3 || t3.call(e2, n3);
    }
  }, i2.send(r2);
} }), null != o$7 && o$7.sendBeacon && fr.push({ transport: "sendBeacon", method: (e2) => {
  var t2 = pr(e2.url, { beacon: "1" });
  try {
    var i2, { contentType: n2, body: r2 } = null !== (i2 = gr(e2)) && void 0 !== i2 ? i2 : {}, s2 = "string" == typeof r2 ? new Blob([r2], { type: n2 }) : r2;
    o$7.sendBeacon(t2, s2);
  } catch (e3) {
  }
} });
var mr = ["retriesPerformedSoFar"];
class br {
  constructor(e2) {
    W$3(this, "isPolling", false), W$3(this, "pollIntervalMs", 3e3), W$3(this, "queue", []), this.instance = e2, this.queue = [], this.areWeOnline = true, !F$4(t$5) && "onLine" in t$5.navigator && (this.areWeOnline = t$5.navigator.onLine, t$5.addEventListener("online", () => {
      this.areWeOnline = true, this.flush();
    }), t$5.addEventListener("offline", () => {
      this.areWeOnline = false;
    }));
  }
  retriableRequest(e2) {
    var { retriesPerformedSoFar: t2 } = e2, i2 = V$3(e2, mr);
    M$5(t2) && t2 > 0 && (i2.url = pr(i2.url, { retry_count: t2 })), this.instance._send_request(j$5(j$5({}, i2), {}, { callback: (e3) => {
      var n2;
      200 !== e3.statusCode && (e3.statusCode < 400 || e3.statusCode >= 500) && (null != t2 ? t2 : 0) < 10 ? this.enqueue(j$5({ retriesPerformedSoFar: t2 }, i2)) : null === (n2 = i2.callback) || void 0 === n2 || n2.call(i2, e3);
    } }));
  }
  enqueue(e2) {
    var t2 = e2.retriesPerformedSoFar || 0;
    e2.retriesPerformedSoFar = t2 + 1;
    var i2 = function(e3) {
      var t3 = 3e3 * Math.pow(2, e3), i3 = t3 / 2, n3 = Math.min(18e5, t3), r3 = (Math.random() - 0.5) * (n3 - i3);
      return Math.ceil(n3 + r3);
    }(t2), n2 = Date.now() + i2;
    this.queue.push({ retryAt: n2, requestOptions: e2 });
    var r2 = "Enqueued failed request for retry in ".concat(i2);
    navigator.onLine || (r2 += " (Browser is offline)"), q$2.warn(r2), this.isPolling || (this.isPolling = true, this.poll());
  }
  poll() {
    this.poller && clearTimeout(this.poller), this.poller = setTimeout(() => {
      this.areWeOnline && this.queue.length > 0 && this.flush(), this.poll();
    }, this.pollIntervalMs);
  }
  flush() {
    var e2 = Date.now(), t2 = [], i2 = this.queue.filter((i3) => i3.retryAt < e2 || (t2.push(i3), false));
    if (this.queue = t2, i2.length > 0) for (var { requestOptions: n2 } of i2) this.retriableRequest(n2);
  }
  unload() {
    for (var { requestOptions: e2 } of (this.poller && (clearTimeout(this.poller), this.poller = void 0), this.queue)) try {
      this.instance._send_request(j$5(j$5({}, e2), {}, { transport: "sendBeacon" }));
    } catch (e3) {
      q$2.error(e3);
    }
    this.queue = [];
  }
}
var yr, wr = B$1("[SessionId]");
class Sr {
  constructor(e2, t2, i2) {
    var n2;
    if (W$3(this, "_sessionIdChangedHandlers", []), !e2.persistence) throw new Error("SessionIdManager requires a PostHogPersistence instance");
    if (e2.config.__preview_experimental_cookieless_mode) throw new Error("SessionIdManager cannot be used with __preview_experimental_cookieless_mode");
    this.config = e2.config, this.persistence = e2.persistence, this._windowId = void 0, this._sessionId = void 0, this._sessionStartTimestamp = null, this._sessionActivityTimestamp = null, this._sessionIdGenerator = t2 || Ze, this._windowIdGenerator = i2 || Ze;
    var r2 = this.config.persistence_name || this.config.token, s2 = this.config.session_idle_timeout_seconds || 1800;
    if (this._sessionTimeoutMs = 1e3 * ln(s2, 60, 36e3, "session_idle_timeout_seconds", 1800), e2.register({ $configured_session_timeout_ms: this._sessionTimeoutMs }), this.resetIdleTimer(), this._window_id_storage_key = "ph_" + r2 + "_window_id", this._primary_window_exists_storage_key = "ph_" + r2 + "_primary_window_exists", this._canUseSessionStorage()) {
      var o22 = _t$1.parse(this._window_id_storage_key), a22 = _t$1.parse(this._primary_window_exists_storage_key);
      o22 && !a22 ? this._windowId = o22 : _t$1.remove(this._window_id_storage_key), _t$1.set(this._primary_window_exists_storage_key, true);
    }
    if (null !== (n2 = this.config.bootstrap) && void 0 !== n2 && n2.sessionID) try {
      var l22 = ((e3) => {
        var t3 = e3.replace(/-/g, "");
        if (32 !== t3.length) throw new Error("Not a valid UUID");
        if ("7" !== t3[12]) throw new Error("Not a UUIDv7");
        return parseInt(t3.substring(0, 12), 16);
      })(this.config.bootstrap.sessionID);
      this._setSessionId(this.config.bootstrap.sessionID, (/* @__PURE__ */ new Date()).getTime(), l22);
    } catch (e3) {
      wr.error("Invalid sessionID in bootstrap", e3);
    }
    this._listenToReloadWindow();
  }
  get sessionTimeoutMs() {
    return this._sessionTimeoutMs;
  }
  onSessionId(e2) {
    return F$4(this._sessionIdChangedHandlers) && (this._sessionIdChangedHandlers = []), this._sessionIdChangedHandlers.push(e2), this._sessionId && e2(this._sessionId, this._windowId), () => {
      this._sessionIdChangedHandlers = this._sessionIdChangedHandlers.filter((t2) => t2 !== e2);
    };
  }
  _canUseSessionStorage() {
    return "memory" !== this.config.persistence && !this.persistence.disabled && _t$1.is_supported();
  }
  _setWindowId(e2) {
    e2 !== this._windowId && (this._windowId = e2, this._canUseSessionStorage() && _t$1.set(this._window_id_storage_key, e2));
  }
  _getWindowId() {
    return this._windowId ? this._windowId : this._canUseSessionStorage() ? _t$1.parse(this._window_id_storage_key) : null;
  }
  _setSessionId(e2, t2, i2) {
    e2 === this._sessionId && t2 === this._sessionActivityTimestamp && i2 === this._sessionStartTimestamp || (this._sessionStartTimestamp = i2, this._sessionActivityTimestamp = t2, this._sessionId = e2, this.persistence.register({ [ye$2]: [t2, e2, i2] }));
  }
  _getSessionId() {
    if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
    var e2 = this.persistence.props[ye$2];
    return x$3(e2) && 2 === e2.length && e2.push(e2[0]), e2 || [0, null, 0];
  }
  resetSessionId() {
    this._setSessionId(null, null, null);
  }
  _listenToReloadWindow() {
    null == t$5 || t$5.addEventListener("beforeunload", () => {
      this._canUseSessionStorage() && _t$1.remove(this._primary_window_exists_storage_key);
    });
  }
  checkAndGetSessionAndWindowId() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    if (this.config.__preview_experimental_cookieless_mode) throw new Error("checkAndGetSessionAndWindowId should not be called in __preview_experimental_cookieless_mode");
    var i2 = t2 || (/* @__PURE__ */ new Date()).getTime(), [n2, r2, s2] = this._getSessionId(), o22 = this._getWindowId(), a22 = M$5(s2) && s2 > 0 && Math.abs(i2 - s2) > 864e5, l22 = false, u22 = !r2, c2 = !e2 && Math.abs(i2 - n2) > this.sessionTimeoutMs;
    u22 || c2 || a22 ? (r2 = this._sessionIdGenerator(), o22 = this._windowIdGenerator(), wr.info("new session ID generated", { sessionId: r2, windowId: o22, changeReason: { noSessionId: u22, activityTimeout: c2, sessionPastMaximumLength: a22 } }), s2 = i2, l22 = true) : o22 || (o22 = this._windowIdGenerator(), l22 = true);
    var d22 = 0 === n2 || !e2 || a22 ? i2 : n2, h22 = 0 === s2 ? (/* @__PURE__ */ new Date()).getTime() : s2;
    return this._setWindowId(o22), this._setSessionId(r2, d22, h22), e2 || this.resetIdleTimer(), l22 && this._sessionIdChangedHandlers.forEach((e3) => e3(r2, o22, l22 ? { noSessionId: u22, activityTimeout: c2, sessionPastMaximumLength: a22 } : void 0)), { sessionId: r2, windowId: o22, sessionStartTimestamp: h22, changeReason: l22 ? { noSessionId: u22, activityTimeout: c2, sessionPastMaximumLength: a22 } : void 0, lastActivityTimestamp: n2 };
  }
  resetIdleTimer() {
    clearTimeout(this._enforceIdleTimeout), this._enforceIdleTimeout = setTimeout(() => {
      this.resetSessionId();
    }, 1.1 * this.sessionTimeoutMs);
  }
}
!function(e2) {
  e2.US = "us", e2.EU = "eu", e2.CUSTOM = "custom";
}(yr || (yr = {}));
var Er = "i.posthog.com";
class kr {
  constructor(e2) {
    W$3(this, "_regionCache", {}), this.instance = e2;
  }
  get apiHost() {
    var e2 = this.instance.config.api_host.trim().replace(/\/$/, "");
    return "https://app.posthog.com" === e2 ? "https://us.i.posthog.com" : e2;
  }
  get uiHost() {
    var e2, t2 = null === (e2 = this.instance.config.ui_host) || void 0 === e2 ? void 0 : e2.replace(/\/$/, "");
    return t2 || (t2 = this.apiHost.replace(".".concat(Er), ".posthog.com")), "https://app.posthog.com" === t2 ? "https://us.posthog.com" : t2;
  }
  get region() {
    return this._regionCache[this.apiHost] || (/https:\/\/(app|us|us-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = yr.US : /https:\/\/(eu|eu-assets)(\.i)?\.posthog\.com/i.test(this.apiHost) ? this._regionCache[this.apiHost] = yr.EU : this._regionCache[this.apiHost] = yr.CUSTOM), this._regionCache[this.apiHost];
  }
  endpointFor(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    if (t2 && (t2 = "/" === t2[0] ? t2 : "/".concat(t2)), "ui" === e2) return this.uiHost + t2;
    if (this.region === yr.CUSTOM) return this.apiHost + t2;
    var i2 = Er + t2;
    switch (e2) {
      case "assets":
        return "https://".concat(this.region, "-assets.").concat(i2);
      case "api":
        return "https://".concat(this.region, ".").concat(i2);
    }
  }
}
var xr = "posthog-js";
function Ir(e2) {
  var { organization: t2, projectId: i2, prefix: n2, severityAllowList: r2 = ["error"] } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return (s2) => {
    var o22, a22, l22, u22, c2;
    if (!("*" === r2 || r2.includes(s2.level)) || !e2.__loaded) return s2;
    s2.tags || (s2.tags = {});
    var d22 = e2.requestRouter.endpointFor("ui", "/project/".concat(e2.config.token, "/person/").concat(e2.get_distinct_id()));
    s2.tags["PostHog Person URL"] = d22, e2.sessionRecordingStarted() && (s2.tags["PostHog Recording URL"] = e2.get_session_replay_url({ withTimestamp: true }));
    var h22 = (null === (o22 = s2.exception) || void 0 === o22 ? void 0 : o22.values) || [];
    h22.map((e3) => {
      e3.stacktrace && (e3.stacktrace.type = "raw");
    });
    var _2 = { $exception_message: (null === (a22 = h22[0]) || void 0 === a22 ? void 0 : a22.value) || s2.message, $exception_type: null === (l22 = h22[0]) || void 0 === l22 ? void 0 : l22.type, $exception_personURL: d22, $exception_level: s2.level, $exception_list: h22, $sentry_event_id: s2.event_id, $sentry_exception: s2.exception, $sentry_exception_message: (null === (u22 = h22[0]) || void 0 === u22 ? void 0 : u22.value) || s2.message, $sentry_exception_type: null === (c2 = h22[0]) || void 0 === c2 ? void 0 : c2.type, $sentry_tags: s2.tags };
    return t2 && i2 && (_2.$sentry_url = (n2 || "https://sentry.io/organizations/") + t2 + "/issues/?project=" + i2 + "&query=" + s2.event_id), e2.exceptions.sendExceptionEvent(_2), s2;
  };
}
class Cr {
  constructor(e2, t2, i2, n2, r2) {
    this.name = xr, this.setupOnce = function(s2) {
      s2(Ir(e2, { organization: t2, projectId: i2, prefix: n2, severityAllowList: r2 }));
    };
  }
}
var Pr, Fr, Rr, Tr = B$1("[SegmentIntegration]");
function $r(e2, t2) {
  var i2 = e2.config.segment;
  if (!i2) return t2();
  !function(e3, t3) {
    var i3 = e3.config.segment;
    if (!i3) return t3();
    var n2 = (i4) => {
      var n3 = () => i4.anonymousId() || Ze();
      e3.config.get_device_id = n3, i4.id() && (e3.register({ distinct_id: i4.id(), $device_id: n3() }), e3.persistence.set_property(Te$2, "identified")), t3();
    }, r2 = i3.user();
    "then" in r2 && I$4(r2.then) ? r2.then((e4) => n2(e4)) : n2(r2);
  }(e2, () => {
    i2.register(((e3) => {
      Promise && Promise.resolve || Tr.warn("This browser does not have Promise support, and can not use the segment integration");
      var t3 = (t4, i3) => {
        var n2;
        if (!i3) return t4;
        t4.event.userId || t4.event.anonymousId === e3.get_distinct_id() || (Tr.info("No userId set, resetting PostHog"), e3.reset()), t4.event.userId && t4.event.userId !== e3.get_distinct_id() && (Tr.info("UserId set, identifying with PostHog"), e3.identify(t4.event.userId));
        var r2 = e3._calculate_event_properties(i3, null !== (n2 = t4.event.properties) && void 0 !== n2 ? n2 : {}, /* @__PURE__ */ new Date());
        return t4.event.properties = Object.assign({}, r2, t4.event.properties), t4;
      };
      return { name: "PostHog JS", type: "enrichment", version: "1.0.0", isLoaded: () => true, load: () => Promise.resolve(), track: (e4) => t3(e4, e4.event.event), page: (e4) => t3(e4, "$pageview"), identify: (e4) => t3(e4, "$identify"), screen: (e4) => t3(e4, "$screen") };
    })(e2)).then(() => {
      t2();
    });
  });
}
class Or {
  constructor(e2) {
    this._instance = e2;
  }
  doPageView(e2, i2) {
    var n2, r2 = this._previousPageViewProperties(e2, i2);
    return this._currentPageview = { pathname: null !== (n2 = null == t$5 ? void 0 : t$5.location.pathname) && void 0 !== n2 ? n2 : "", pageViewId: i2, timestamp: e2 }, this._instance.scrollManager.resetContext(), r2;
  }
  doPageLeave(e2) {
    var t2;
    return this._previousPageViewProperties(e2, null === (t2 = this._currentPageview) || void 0 === t2 ? void 0 : t2.pageViewId);
  }
  doEvent() {
    var e2;
    return { $pageview_id: null === (e2 = this._currentPageview) || void 0 === e2 ? void 0 : e2.pageViewId };
  }
  _previousPageViewProperties(e2, t2) {
    var i2 = this._currentPageview;
    if (!i2) return { $pageview_id: t2 };
    var n2 = { $pageview_id: t2, $prev_pageview_id: i2.pageViewId }, r2 = this._instance.scrollManager.getContext();
    if (r2 && !this._instance.config.disable_scroll_properties) {
      var { maxScrollHeight: s2, lastScrollY: o22, maxScrollY: a22, maxContentHeight: l22, lastContentY: u22, maxContentY: c2 } = r2;
      if (!(F$4(s2) || F$4(o22) || F$4(a22) || F$4(l22) || F$4(u22) || F$4(c2))) {
        s2 = Math.ceil(s2), o22 = Math.ceil(o22), a22 = Math.ceil(a22), l22 = Math.ceil(l22), u22 = Math.ceil(u22), c2 = Math.ceil(c2);
        var d22 = s2 <= 1 ? 1 : ln(o22 / s2, 0, 1), h22 = s2 <= 1 ? 1 : ln(a22 / s2, 0, 1), _2 = l22 <= 1 ? 1 : ln(u22 / l22, 0, 1), p22 = l22 <= 1 ? 1 : ln(c2 / l22, 0, 1);
        n2 = K$2(n2, { $prev_pageview_last_scroll: o22, $prev_pageview_last_scroll_percentage: d22, $prev_pageview_max_scroll: a22, $prev_pageview_max_scroll_percentage: h22, $prev_pageview_last_content: u22, $prev_pageview_last_content_percentage: _2, $prev_pageview_max_content: c2, $prev_pageview_max_content_percentage: p22 });
      }
    }
    return i2.pathname && (n2.$prev_pageview_pathname = i2.pathname), i2.timestamp && (n2.$prev_pageview_duration = (e2.getTime() - i2.timestamp.getTime()) / 1e3), n2;
  }
}
!function(e2) {
  e2.Popover = "popover", e2.API = "api", e2.Widget = "widget";
}(Pr || (Pr = {})), function(e2) {
  e2.Open = "open", e2.MultipleChoice = "multiple_choice", e2.SingleChoice = "single_choice", e2.Rating = "rating", e2.Link = "link";
}(Fr || (Fr = {})), function(e2) {
  e2.NextQuestion = "next_question", e2.End = "end", e2.ResponseBased = "response_based", e2.SpecificQuestion = "specific_question";
}(Rr || (Rr = {}));
class Mr {
  constructor() {
    W$3(this, "events", {}), this.events = {};
  }
  on(e2, t2) {
    return this.events[e2] || (this.events[e2] = []), this.events[e2].push(t2), () => {
      this.events[e2] = this.events[e2].filter((e3) => e3 !== t2);
    };
  }
  emit(e2, t2) {
    for (var i2 of this.events[e2] || []) i2(t2);
    for (var n2 of this.events["*"] || []) n2(e2, t2);
  }
}
class Lr {
  constructor(e2) {
    W$3(this, "_debugEventEmitter", new Mr()), W$3(this, "checkStep", (e3, t2) => this.checkStepEvent(e3, t2) && this.checkStepUrl(e3, t2) && this.checkStepElement(e3, t2)), W$3(this, "checkStepEvent", (e3, t2) => null == t2 || !t2.event || (null == e3 ? void 0 : e3.event) === (null == t2 ? void 0 : t2.event)), this.instance = e2, this.actionEvents = /* @__PURE__ */ new Set(), this.actionRegistry = /* @__PURE__ */ new Set();
  }
  init() {
    var e2;
    if (!F$4(null === (e2 = this.instance) || void 0 === e2 ? void 0 : e2._addCaptureHook)) {
      var t2;
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.on(e3, t3);
      });
    }
  }
  register(e2) {
    var t2, i2;
    if (!F$4(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) && (e2.forEach((e3) => {
      var t3, i3;
      null === (t3 = this.actionRegistry) || void 0 === t3 || t3.add(e3), null === (i3 = e3.steps) || void 0 === i3 || i3.forEach((e4) => {
        var t4;
        null === (t4 = this.actionEvents) || void 0 === t4 || t4.add((null == e4 ? void 0 : e4.event) || "");
      });
    }), null !== (i2 = this.instance) && void 0 !== i2 && i2.autocapture)) {
      var n2, r2 = /* @__PURE__ */ new Set();
      e2.forEach((e3) => {
        var t3;
        null === (t3 = e3.steps) || void 0 === t3 || t3.forEach((e4) => {
          null != e4 && e4.selector && r2.add(null == e4 ? void 0 : e4.selector);
        });
      }), null === (n2 = this.instance) || void 0 === n2 || n2.autocapture.setElementSelectors(r2);
    }
  }
  on(e2, t2) {
    var i2;
    null != t2 && 0 != e2.length && (this.actionEvents.has(e2) || this.actionEvents.has(null == t2 ? void 0 : t2.event)) && this.actionRegistry && (null === (i2 = this.actionRegistry) || void 0 === i2 ? void 0 : i2.size) > 0 && this.actionRegistry.forEach((e3) => {
      this.checkAction(t2, e3) && this._debugEventEmitter.emit("actionCaptured", e3.name);
    });
  }
  _addActionHook(e2) {
    this.onAction("actionCaptured", (t2) => e2(t2));
  }
  checkAction(e2, t2) {
    if (null == (null == t2 ? void 0 : t2.steps)) return false;
    for (var i2 of t2.steps) if (this.checkStep(e2, i2)) return true;
    return false;
  }
  onAction(e2, t2) {
    return this._debugEventEmitter.on(e2, t2);
  }
  checkStepUrl(e2, t2) {
    if (null != t2 && t2.url) {
      var i2, n2 = null == e2 || null === (i2 = e2.properties) || void 0 === i2 ? void 0 : i2.$current_url;
      if (!n2 || "string" != typeof n2) return false;
      if (!Lr.matchString(n2, null == t2 ? void 0 : t2.url, (null == t2 ? void 0 : t2.url_matching) || "contains")) return false;
    }
    return true;
  }
  static matchString(e2, i2, n2) {
    switch (n2) {
      case "regex":
        return !!t$5 && gt$1(e2, i2);
      case "exact":
        return i2 === e2;
      case "contains":
        var r2 = Lr.escapeStringRegexp(i2).replace(/_/g, ".").replace(/%/g, ".*");
        return gt$1(e2, r2);
      default:
        return false;
    }
  }
  static escapeStringRegexp(e2) {
    return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  checkStepElement(e2, t2) {
    if ((null != t2 && t2.href || null != t2 && t2.tag_name || null != t2 && t2.text) && !this.getElementsList(e2).some((e3) => !(null != t2 && t2.href && !Lr.matchString(e3.href || "", null == t2 ? void 0 : t2.href, (null == t2 ? void 0 : t2.href_matching) || "exact")) && ((null == t2 || !t2.tag_name || e3.tag_name === (null == t2 ? void 0 : t2.tag_name)) && !(null != t2 && t2.text && !Lr.matchString(e3.text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact") && !Lr.matchString(e3.$el_text || "", null == t2 ? void 0 : t2.text, (null == t2 ? void 0 : t2.text_matching) || "exact"))))) return false;
    if (null != t2 && t2.selector) {
      var i2, n2 = null == e2 || null === (i2 = e2.properties) || void 0 === i2 ? void 0 : i2.$element_selectors;
      if (!n2) return false;
      if (!n2.includes(null == t2 ? void 0 : t2.selector)) return false;
    }
    return true;
  }
  getElementsList(e2) {
    return null == (null == e2 ? void 0 : e2.properties.$elements) ? [] : null == e2 ? void 0 : e2.properties.$elements;
  }
}
class Ar {
  constructor(e2) {
    this.instance = e2, this.eventToSurveys = /* @__PURE__ */ new Map(), this.actionToSurveys = /* @__PURE__ */ new Map();
  }
  register(e2) {
    var t2;
    F$4(null === (t2 = this.instance) || void 0 === t2 ? void 0 : t2._addCaptureHook) || (this.setupEventBasedSurveys(e2), this.setupActionBasedSurveys(e2));
  }
  setupActionBasedSurveys(e2) {
    var t2 = e2.filter((e3) => {
      var t3, i2, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.actions) && (null === (i2 = e3.conditions) || void 0 === i2 || null === (n2 = i2.actions) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    });
    if (0 !== t2.length) {
      if (null == this.actionMatcher) {
        this.actionMatcher = new Lr(this.instance), this.actionMatcher.init();
        this.actionMatcher._addActionHook((e3) => {
          this.onAction(e3);
        });
      }
      t2.forEach((e3) => {
        var t3, i2, n2, r2, s2, o22, a22, l22, u22, c2;
        e3.conditions && null !== (t3 = e3.conditions) && void 0 !== t3 && t3.actions && null !== (i2 = e3.conditions) && void 0 !== i2 && null !== (n2 = i2.actions) && void 0 !== n2 && n2.values && (null === (r2 = e3.conditions) || void 0 === r2 || null === (s2 = r2.actions) || void 0 === s2 || null === (o22 = s2.values) || void 0 === o22 ? void 0 : o22.length) > 0 && (null === (a22 = this.actionMatcher) || void 0 === a22 || a22.register(e3.conditions.actions.values), null === (l22 = e3.conditions) || void 0 === l22 || null === (u22 = l22.actions) || void 0 === u22 || null === (c2 = u22.values) || void 0 === c2 || c2.forEach((t4) => {
          if (t4 && t4.name) {
            var i3 = this.actionToSurveys.get(t4.name);
            i3 && i3.push(e3.id), this.actionToSurveys.set(t4.name, i3 || [e3.id]);
          }
        }));
      });
    }
  }
  setupEventBasedSurveys(e2) {
    var t2;
    if (0 !== e2.filter((e3) => {
      var t3, i2, n2, r2;
      return (null === (t3 = e3.conditions) || void 0 === t3 ? void 0 : t3.events) && (null === (i2 = e3.conditions) || void 0 === i2 || null === (n2 = i2.events) || void 0 === n2 || null === (r2 = n2.values) || void 0 === r2 ? void 0 : r2.length) > 0;
    }).length) {
      null === (t2 = this.instance) || void 0 === t2 || t2._addCaptureHook((e3, t3) => {
        this.onEvent(e3, t3);
      }), e2.forEach((e3) => {
        var t3, i2, n2;
        null === (t3 = e3.conditions) || void 0 === t3 || null === (i2 = t3.events) || void 0 === i2 || null === (n2 = i2.values) || void 0 === n2 || n2.forEach((t4) => {
          if (t4 && t4.name) {
            var i3 = this.eventToSurveys.get(t4.name);
            i3 && i3.push(e3.id), this.eventToSurveys.set(t4.name, i3 || [e3.id]);
          }
        });
      });
    }
  }
  onEvent(e2, t2) {
    var i2, n2, r2 = (null === (i2 = this.instance) || void 0 === i2 || null === (n2 = i2.persistence) || void 0 === n2 ? void 0 : n2.props[Fe$2]) || [];
    if (Ar.SURVEY_SHOWN_EVENT_NAME == e2 && t2 && r2.length > 0) {
      var s2, o22 = null == t2 || null === (s2 = t2.properties) || void 0 === s2 ? void 0 : s2.$survey_id;
      if (o22) {
        var a22 = r2.indexOf(o22);
        a22 >= 0 && (r2.splice(a22, 1), this._updateActivatedSurveys(r2));
      }
    } else this.eventToSurveys.has(e2) && this._updateActivatedSurveys(r2.concat(this.eventToSurveys.get(e2) || []));
  }
  onAction(e2) {
    var t2, i2, n2 = (null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 ? void 0 : i2.props[Fe$2]) || [];
    this.actionToSurveys.has(e2) && this._updateActivatedSurveys(n2.concat(this.actionToSurveys.get(e2) || []));
  }
  _updateActivatedSurveys(e2) {
    var t2, i2;
    null === (t2 = this.instance) || void 0 === t2 || null === (i2 = t2.persistence) || void 0 === i2 || i2.register({ [Fe$2]: [...new Set(e2)] });
  }
  getSurveys() {
    var e2, t2, i2 = null === (e2 = this.instance) || void 0 === e2 || null === (t2 = e2.persistence) || void 0 === t2 ? void 0 : t2.props[Fe$2];
    return i2 || [];
  }
  getEventToSurveys() {
    return this.eventToSurveys;
  }
  _getActionMatcher() {
    return this.actionMatcher;
  }
}
W$3(Ar, "SURVEY_SHOWN_EVENT_NAME", "survey shown");
var Dr, Nr, qr, Br, Hr, Ur, zr, jr, Wr = {}, Vr = [], Gr = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Jr = Array.isArray;
function Yr(e2, t2) {
  for (var i2 in t2) e2[i2] = t2[i2];
  return e2;
}
function Kr(e2) {
  var t2 = e2.parentNode;
  t2 && t2.removeChild(e2);
}
function Xr(e2, t2, i2, n2, r2) {
  var s2 = { type: e2, props: t2, key: i2, ref: n2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++qr : r2, __i: -1, __u: 0 };
  return null == r2 && null != Nr.vnode && Nr.vnode(s2), s2;
}
function Qr(e2) {
  return e2.children;
}
function Zr(e2, t2) {
  this.props = e2, this.context = t2;
}
function es(e2, t2) {
  if (null == t2) return e2.__ ? es(e2.__, e2.__i + 1) : null;
  for (var i2; t2 < e2.__k.length; t2++) if (null != (i2 = e2.__k[t2]) && null != i2.__e) return i2.__e;
  return "function" == typeof e2.type ? es(e2) : null;
}
function ts(e2) {
  var t2, i2;
  if (null != (e2 = e2.__) && null != e2.__c) {
    for (e2.__e = e2.__c.base = null, t2 = 0; t2 < e2.__k.length; t2++) if (null != (i2 = e2.__k[t2]) && null != i2.__e) {
      e2.__e = e2.__c.base = i2.__e;
      break;
    }
    return ts(e2);
  }
}
function is(e2) {
  (!e2.__d && (e2.__d = true) && Br.push(e2) && !ns.__r++ || Hr !== Nr.debounceRendering) && ((Hr = Nr.debounceRendering) || Ur)(ns);
}
function ns() {
  var e2, t2, i2, n2, r2, s2, o22, a22, l22;
  for (Br.sort(zr); e2 = Br.shift(); ) e2.__d && (t2 = Br.length, n2 = void 0, s2 = (r2 = (i2 = e2).__v).__e, a22 = [], l22 = [], (o22 = i2.__P) && ((n2 = Yr({}, r2)).__v = r2.__v + 1, Nr.vnode && Nr.vnode(n2), hs(o22, n2, r2, i2.__n, void 0 !== o22.ownerSVGElement, 32 & r2.__u ? [s2] : null, a22, null == s2 ? es(r2) : s2, !!(32 & r2.__u), l22), n2.__.__k[n2.__i] = n2, _s(a22, n2, l22), n2.__e != s2 && ts(n2)), Br.length > t2 && Br.sort(zr));
  ns.__r = 0;
}
function rs(e2, t2, i2, n2, r2, s2, o22, a22, l22, u22, c2) {
  var d22, h22, _2, p22, v2, g2 = n2 && n2.__k || Vr, f22 = t2.length;
  for (i2.__d = l22, ss(i2, t2, g2), l22 = i2.__d, d22 = 0; d22 < f22; d22++) null != (_2 = i2.__k[d22]) && "boolean" != typeof _2 && "function" != typeof _2 && (h22 = -1 === _2.__i ? Wr : g2[_2.__i] || Wr, _2.__i = d22, hs(e2, _2, h22, r2, s2, o22, a22, l22, u22, c2), p22 = _2.__e, _2.ref && h22.ref != _2.ref && (h22.ref && vs(h22.ref, null, _2), c2.push(_2.ref, _2.__c || p22, _2)), null == v2 && null != p22 && (v2 = p22), 65536 & _2.__u || h22.__k === _2.__k ? l22 = os(_2, l22, e2) : "function" == typeof _2.type && void 0 !== _2.__d ? l22 = _2.__d : p22 && (l22 = p22.nextSibling), _2.__d = void 0, _2.__u &= -196609);
  i2.__d = l22, i2.__e = v2;
}
function ss(e2, t2, i2) {
  var n2, r2, s2, o22, a22, l22 = t2.length, u22 = i2.length, c2 = u22, d22 = 0;
  for (e2.__k = [], n2 = 0; n2 < l22; n2++) null != (r2 = e2.__k[n2] = null == (r2 = t2[n2]) || "boolean" == typeof r2 || "function" == typeof r2 ? null : "string" == typeof r2 || "number" == typeof r2 || "bigint" == typeof r2 || r2.constructor == String ? Xr(null, r2, null, null, r2) : Jr(r2) ? Xr(Qr, { children: r2 }, null, null, null) : void 0 === r2.constructor && r2.__b > 0 ? Xr(r2.type, r2.props, r2.key, r2.ref ? r2.ref : null, r2.__v) : r2) ? (r2.__ = e2, r2.__b = e2.__b + 1, a22 = as(r2, i2, o22 = n2 + d22, c2), r2.__i = a22, s2 = null, -1 !== a22 && (c2--, (s2 = i2[a22]) && (s2.__u |= 131072)), null == s2 || null === s2.__v ? (-1 == a22 && d22--, "function" != typeof r2.type && (r2.__u |= 65536)) : a22 !== o22 && (a22 === o22 + 1 ? d22++ : a22 > o22 ? c2 > l22 - o22 ? d22 += a22 - o22 : d22-- : d22 = a22 < o22 && a22 == o22 - 1 ? a22 - o22 : 0, a22 !== n2 + d22 && (r2.__u |= 65536))) : (s2 = i2[n2]) && null == s2.key && s2.__e && (s2.__e == e2.__d && (e2.__d = es(s2)), gs(s2, s2, false), i2[n2] = null, c2--);
  if (c2) for (n2 = 0; n2 < u22; n2++) null != (s2 = i2[n2]) && 0 == (131072 & s2.__u) && (s2.__e == e2.__d && (e2.__d = es(s2)), gs(s2, s2));
}
function os(e2, t2, i2) {
  var n2, r2;
  if ("function" == typeof e2.type) {
    for (n2 = e2.__k, r2 = 0; n2 && r2 < n2.length; r2++) n2[r2] && (n2[r2].__ = e2, t2 = os(n2[r2], t2, i2));
    return t2;
  }
  return e2.__e != t2 && (i2.insertBefore(e2.__e, t2 || null), t2 = e2.__e), t2 && t2.nextSibling;
}
function as(e2, t2, i2, n2) {
  var r2 = e2.key, s2 = e2.type, o22 = i2 - 1, a22 = i2 + 1, l22 = t2[i2];
  if (null === l22 || l22 && r2 == l22.key && s2 === l22.type) return i2;
  if (n2 > (null != l22 && 0 == (131072 & l22.__u) ? 1 : 0)) for (; o22 >= 0 || a22 < t2.length; ) {
    if (o22 >= 0) {
      if ((l22 = t2[o22]) && 0 == (131072 & l22.__u) && r2 == l22.key && s2 === l22.type) return o22;
      o22--;
    }
    if (a22 < t2.length) {
      if ((l22 = t2[a22]) && 0 == (131072 & l22.__u) && r2 == l22.key && s2 === l22.type) return a22;
      a22++;
    }
  }
  return -1;
}
function ls(e2, t2, i2) {
  "-" === t2[0] ? e2.setProperty(t2, null == i2 ? "" : i2) : e2[t2] = null == i2 ? "" : "number" != typeof i2 || Gr.test(t2) ? i2 : i2 + "px";
}
function us(e2, t2, i2, n2, r2) {
  var s2;
  e: if ("style" === t2) if ("string" == typeof i2) e2.style.cssText = i2;
  else {
    if ("string" == typeof n2 && (e2.style.cssText = n2 = ""), n2) for (t2 in n2) i2 && t2 in i2 || ls(e2.style, t2, "");
    if (i2) for (t2 in i2) n2 && i2[t2] === n2[t2] || ls(e2.style, t2, i2[t2]);
  }
  else if ("o" === t2[0] && "n" === t2[1]) s2 = t2 !== (t2 = t2.replace(/(PointerCapture)$|Capture$/, "$1")), t2 = t2.toLowerCase() in e2 ? t2.toLowerCase().slice(2) : t2.slice(2), e2.l || (e2.l = {}), e2.l[t2 + s2] = i2, i2 ? n2 ? i2.u = n2.u : (i2.u = Date.now(), e2.addEventListener(t2, s2 ? ds : cs, s2)) : e2.removeEventListener(t2, s2 ? ds : cs, s2);
  else {
    if (r2) t2 = t2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== t2 && "height" !== t2 && "href" !== t2 && "list" !== t2 && "form" !== t2 && "tabIndex" !== t2 && "download" !== t2 && "rowSpan" !== t2 && "colSpan" !== t2 && "role" !== t2 && t2 in e2) try {
      e2[t2] = null == i2 ? "" : i2;
      break e;
    } catch (e3) {
    }
    "function" == typeof i2 || (null == i2 || false === i2 && "-" !== t2[4] ? e2.removeAttribute(t2) : e2.setAttribute(t2, i2));
  }
}
function cs(e2) {
  var t2 = this.l[e2.type + false];
  if (e2.t) {
    if (e2.t <= t2.u) return;
  } else e2.t = Date.now();
  return t2(Nr.event ? Nr.event(e2) : e2);
}
function ds(e2) {
  return this.l[e2.type + true](Nr.event ? Nr.event(e2) : e2);
}
function hs(e2, t2, i2, n2, r2, s2, o22, a22, l22, u22) {
  var c2, d22, h22, _2, p22, v2, g2, f22, m22, b2, y2, w2, S2, E2, k2, x2 = t2.type;
  if (void 0 !== t2.constructor) return null;
  128 & i2.__u && (l22 = !!(32 & i2.__u), s2 = [a22 = t2.__e = i2.__e]), (c2 = Nr.__b) && c2(t2);
  e: if ("function" == typeof x2) try {
    if (f22 = t2.props, m22 = (c2 = x2.contextType) && n2[c2.__c], b2 = c2 ? m22 ? m22.props.value : c2.__ : n2, i2.__c ? g2 = (d22 = t2.__c = i2.__c).__ = d22.__E : ("prototype" in x2 && x2.prototype.render ? t2.__c = d22 = new x2(f22, b2) : (t2.__c = d22 = new Zr(f22, b2), d22.constructor = x2, d22.render = fs), m22 && m22.sub(d22), d22.props = f22, d22.state || (d22.state = {}), d22.context = b2, d22.__n = n2, h22 = d22.__d = true, d22.__h = [], d22._sb = []), null == d22.__s && (d22.__s = d22.state), null != x2.getDerivedStateFromProps && (d22.__s == d22.state && (d22.__s = Yr({}, d22.__s)), Yr(d22.__s, x2.getDerivedStateFromProps(f22, d22.__s))), _2 = d22.props, p22 = d22.state, d22.__v = t2, h22) null == x2.getDerivedStateFromProps && null != d22.componentWillMount && d22.componentWillMount(), null != d22.componentDidMount && d22.__h.push(d22.componentDidMount);
    else {
      if (null == x2.getDerivedStateFromProps && f22 !== _2 && null != d22.componentWillReceiveProps && d22.componentWillReceiveProps(f22, b2), !d22.__e && (null != d22.shouldComponentUpdate && false === d22.shouldComponentUpdate(f22, d22.__s, b2) || t2.__v === i2.__v)) {
        for (t2.__v !== i2.__v && (d22.props = f22, d22.state = d22.__s, d22.__d = false), t2.__e = i2.__e, t2.__k = i2.__k, t2.__k.forEach(function(e3) {
          e3 && (e3.__ = t2);
        }), y2 = 0; y2 < d22._sb.length; y2++) d22.__h.push(d22._sb[y2]);
        d22._sb = [], d22.__h.length && o22.push(d22);
        break e;
      }
      null != d22.componentWillUpdate && d22.componentWillUpdate(f22, d22.__s, b2), null != d22.componentDidUpdate && d22.__h.push(function() {
        d22.componentDidUpdate(_2, p22, v2);
      });
    }
    if (d22.context = b2, d22.props = f22, d22.__P = e2, d22.__e = false, w2 = Nr.__r, S2 = 0, "prototype" in x2 && x2.prototype.render) {
      for (d22.state = d22.__s, d22.__d = false, w2 && w2(t2), c2 = d22.render(d22.props, d22.state, d22.context), E2 = 0; E2 < d22._sb.length; E2++) d22.__h.push(d22._sb[E2]);
      d22._sb = [];
    } else do {
      d22.__d = false, w2 && w2(t2), c2 = d22.render(d22.props, d22.state, d22.context), d22.state = d22.__s;
    } while (d22.__d && ++S2 < 25);
    d22.state = d22.__s, null != d22.getChildContext && (n2 = Yr(Yr({}, n2), d22.getChildContext())), h22 || null == d22.getSnapshotBeforeUpdate || (v2 = d22.getSnapshotBeforeUpdate(_2, p22)), rs(e2, Jr(k2 = null != c2 && c2.type === Qr && null == c2.key ? c2.props.children : c2) ? k2 : [k2], t2, i2, n2, r2, s2, o22, a22, l22, u22), d22.base = t2.__e, t2.__u &= -161, d22.__h.length && o22.push(d22), g2 && (d22.__E = d22.__ = null);
  } catch (e3) {
    t2.__v = null, l22 || null != s2 ? (t2.__e = a22, t2.__u |= l22 ? 160 : 32, s2[s2.indexOf(a22)] = null) : (t2.__e = i2.__e, t2.__k = i2.__k), Nr.__e(e3, t2, i2);
  }
  else null == s2 && t2.__v === i2.__v ? (t2.__k = i2.__k, t2.__e = i2.__e) : t2.__e = ps(i2.__e, t2, i2, n2, r2, s2, o22, l22, u22);
  (c2 = Nr.diffed) && c2(t2);
}
function _s(e2, t2, i2) {
  t2.__d = void 0;
  for (var n2 = 0; n2 < i2.length; n2++) vs(i2[n2], i2[++n2], i2[++n2]);
  Nr.__c && Nr.__c(t2, e2), e2.some(function(t3) {
    try {
      e2 = t3.__h, t3.__h = [], e2.some(function(e3) {
        e3.call(t3);
      });
    } catch (e3) {
      Nr.__e(e3, t3.__v);
    }
  });
}
function ps(e2, t2, i2, n2, r2, s2, o22, a22, l22) {
  var u22, c2, d22, h22, _2, p22, v2, g2 = i2.props, f22 = t2.props, m22 = t2.type;
  if ("svg" === m22 && (r2 = true), null != s2) {
    for (u22 = 0; u22 < s2.length; u22++) if ((_2 = s2[u22]) && "setAttribute" in _2 == !!m22 && (m22 ? _2.localName === m22 : 3 === _2.nodeType)) {
      e2 = _2, s2[u22] = null;
      break;
    }
  }
  if (null == e2) {
    if (null === m22) return document.createTextNode(f22);
    e2 = r2 ? document.createElementNS("http://www.w3.org/2000/svg", m22) : document.createElement(m22, f22.is && f22), s2 = null, a22 = false;
  }
  if (null === m22) g2 === f22 || a22 && e2.data === f22 || (e2.data = f22);
  else {
    if (s2 = s2 && Dr.call(e2.childNodes), g2 = i2.props || Wr, !a22 && null != s2) for (g2 = {}, u22 = 0; u22 < e2.attributes.length; u22++) g2[(_2 = e2.attributes[u22]).name] = _2.value;
    for (u22 in g2) _2 = g2[u22], "children" == u22 || ("dangerouslySetInnerHTML" == u22 ? d22 = _2 : "key" === u22 || u22 in f22 || us(e2, u22, null, _2, r2));
    for (u22 in f22) _2 = f22[u22], "children" == u22 ? h22 = _2 : "dangerouslySetInnerHTML" == u22 ? c2 = _2 : "value" == u22 ? p22 = _2 : "checked" == u22 ? v2 = _2 : "key" === u22 || a22 && "function" != typeof _2 || g2[u22] === _2 || us(e2, u22, _2, g2[u22], r2);
    if (c2) a22 || d22 && (c2.__html === d22.__html || c2.__html === e2.innerHTML) || (e2.innerHTML = c2.__html), t2.__k = [];
    else if (d22 && (e2.innerHTML = ""), rs(e2, Jr(h22) ? h22 : [h22], t2, i2, n2, r2 && "foreignObject" !== m22, s2, o22, s2 ? s2[0] : i2.__k && es(i2, 0), a22, l22), null != s2) for (u22 = s2.length; u22--; ) null != s2[u22] && Kr(s2[u22]);
    a22 || (u22 = "value", void 0 !== p22 && (p22 !== e2[u22] || "progress" === m22 && !p22 || "option" === m22 && p22 !== g2[u22]) && us(e2, u22, p22, g2[u22], false), u22 = "checked", void 0 !== v2 && v2 !== e2[u22] && us(e2, u22, v2, g2[u22], false));
  }
  return e2;
}
function vs(e2, t2, i2) {
  try {
    "function" == typeof e2 ? e2(t2) : e2.current = t2;
  } catch (e3) {
    Nr.__e(e3, i2);
  }
}
function gs(e2, t2, i2) {
  var n2, r2;
  if (Nr.unmount && Nr.unmount(e2), (n2 = e2.ref) && (n2.current && n2.current !== e2.__e || vs(n2, null, t2)), null != (n2 = e2.__c)) {
    if (n2.componentWillUnmount) try {
      n2.componentWillUnmount();
    } catch (e3) {
      Nr.__e(e3, t2);
    }
    n2.base = n2.__P = null, e2.__c = void 0;
  }
  if (n2 = e2.__k) for (r2 = 0; r2 < n2.length; r2++) n2[r2] && gs(n2[r2], t2, i2 || "function" != typeof e2.type);
  i2 || null == e2.__e || Kr(e2.__e), e2.__ = e2.__e = e2.__d = void 0;
}
function fs(e2, t2, i2) {
  return this.constructor(e2, i2);
}
Dr = Vr.slice, Nr = { __e: function(e2, t2, i2, n2) {
  for (var r2, s2, o22; t2 = t2.__; ) if ((r2 = t2.__c) && !r2.__) try {
    if ((s2 = r2.constructor) && null != s2.getDerivedStateFromError && (r2.setState(s2.getDerivedStateFromError(e2)), o22 = r2.__d), null != r2.componentDidCatch && (r2.componentDidCatch(e2, n2 || {}), o22 = r2.__d), o22) return r2.__E = r2;
  } catch (t3) {
    e2 = t3;
  }
  throw e2;
} }, qr = 0, Zr.prototype.setState = function(e2, t2) {
  var i2;
  i2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = Yr({}, this.state), "function" == typeof e2 && (e2 = e2(Yr({}, i2), this.props)), e2 && Yr(i2, e2), null != e2 && this.__v && (t2 && this._sb.push(t2), is(this));
}, Zr.prototype.forceUpdate = function(e2) {
  this.__v && (this.__e = true, e2 && this.__h.push(e2), is(this));
}, Zr.prototype.render = Qr, Br = [], Ur = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, zr = function(e2, t2) {
  return e2.__v.__b - t2.__v.__b;
}, ns.__r = 0, jr = 0;
!function(e2, t2) {
  var i2 = { __c: t2 = "__cC" + jr++, __: e2, Consumer: function(e3, t3) {
    return e3.children(t3);
  }, Provider: function(e3) {
    var i3, n2;
    return this.getChildContext || (i3 = [], (n2 = {})[t2] = this, this.getChildContext = function() {
      return n2;
    }, this.shouldComponentUpdate = function(e4) {
      this.props.value !== e4.value && i3.some(function(e5) {
        e5.__e = true, is(e5);
      });
    }, this.sub = function(e4) {
      i3.push(e4);
      var t3 = e4.componentWillUnmount;
      e4.componentWillUnmount = function() {
        i3.splice(i3.indexOf(e4), 1), t3 && t3.call(e4);
      };
    }), e3.children;
  } };
  i2.Provider.__ = i2.Consumer.contextType = i2;
}({ isPreviewMode: false, previewPageIndex: 0, handleCloseSurveyPopup: () => {
}, isPopup: true, onPreviewSubmit: () => {
} });
var ms = B$1("[Surveys]"), bs = { icontains: (e2) => !!t$5 && t$5.location.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2) => !!t$5 && -1 === t$5.location.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2) => !!t$5 && gt$1(t$5.location.href, e2), not_regex: (e2) => !!t$5 && !gt$1(t$5.location.href, e2), exact: (e2) => (null == t$5 ? void 0 : t$5.location.href) === e2, is_not: (e2) => (null == t$5 ? void 0 : t$5.location.href) !== e2 };
class ys {
  constructor(e2) {
    this.instance = e2, this._surveyEventReceiver = null;
  }
  onRemoteConfig(e2) {
    this._decideServerResponse = !!e2.surveys, this.loadIfEnabled();
  }
  reset() {
    localStorage.removeItem("lastSeenSurveyDate");
    var e2 = (() => {
      for (var e3 = [], t2 = 0; t2 < localStorage.length; t2++) {
        var i2 = localStorage.key(t2);
        null != i2 && i2.startsWith("seenSurvey_") && e3.push(i2);
      }
      return e3;
    })();
    e2.forEach((e3) => localStorage.removeItem(e3));
  }
  loadIfEnabled() {
    var e2, t2, i2, n2 = null == _$4 || null === (e2 = _$4.__PosthogExtensions__) || void 0 === e2 ? void 0 : e2.generateSurveys;
    this.instance.config.disable_surveys || !this._decideServerResponse || n2 || (null == this._surveyEventReceiver && (this._surveyEventReceiver = new Ar(this.instance)), null === (t2 = _$4.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, "surveys", (e3) => {
      var t3, i3;
      if (e3) return ms.error("Could not load surveys script", e3);
      this._surveyManager = null === (t3 = _$4.__PosthogExtensions__) || void 0 === t3 || null === (i3 = t3.generateSurveys) || void 0 === i3 ? void 0 : i3.call(t3, this.instance);
    }));
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    if (this.instance.config.disable_surveys) return e2([]);
    null == this._surveyEventReceiver && (this._surveyEventReceiver = new Ar(this.instance));
    var i2 = this.instance.get_property(Pe);
    if (i2 && !t2) return e2(i2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/surveys/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      var i3;
      if (200 !== t3.statusCode || !t3.json) return e2([]);
      var n2, r2 = t3.json.surveys || [], s2 = r2.filter((e3) => {
        var t4, i4, n3, r3, s3, o22, a22, l22, u22, c2, d22, h22;
        return (null === (t4 = e3.conditions) || void 0 === t4 ? void 0 : t4.events) && (null === (i4 = e3.conditions) || void 0 === i4 || null === (n3 = i4.events) || void 0 === n3 ? void 0 : n3.values) && (null === (r3 = e3.conditions) || void 0 === r3 || null === (s3 = r3.events) || void 0 === s3 || null === (o22 = s3.values) || void 0 === o22 ? void 0 : o22.length) > 0 || (null === (a22 = e3.conditions) || void 0 === a22 ? void 0 : a22.actions) && (null === (l22 = e3.conditions) || void 0 === l22 || null === (u22 = l22.actions) || void 0 === u22 ? void 0 : u22.values) && (null === (c2 = e3.conditions) || void 0 === c2 || null === (d22 = c2.actions) || void 0 === d22 || null === (h22 = d22.values) || void 0 === h22 ? void 0 : h22.length) > 0;
      });
      s2.length > 0 && (null === (n2 = this._surveyEventReceiver) || void 0 === n2 || n2.register(s2));
      return null === (i3 = this.instance.persistence) || void 0 === i3 || i3.register({ [Pe]: r2 }), e2(r2);
    } });
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.getSurveys((t3) => {
      var i2, n2 = t3.filter((e3) => !(!e3.start_date || e3.end_date)).filter((e3) => {
        var t4, i3, n3, r3;
        if (!e3.conditions) return true;
        var s3 = null === (t4 = e3.conditions) || void 0 === t4 || !t4.url || bs[null !== (i3 = null === (n3 = e3.conditions) || void 0 === n3 ? void 0 : n3.urlMatchType) && void 0 !== i3 ? i3 : "icontains"](e3.conditions.url), o22 = null === (r3 = e3.conditions) || void 0 === r3 || !r3.selector || (null == a$a ? void 0 : a$a.querySelector(e3.conditions.selector));
        return s3 && o22;
      }), r2 = null === (i2 = this._surveyEventReceiver) || void 0 === i2 ? void 0 : i2.getSurveys(), s2 = n2.filter((e3) => {
        var t4, i3, n3, s3, o22, a22, l22, u22, c2, d22, h22;
        if (!(e3.linked_flag_key || e3.targeting_flag_key || e3.internal_targeting_flag_key || null !== (t4 = e3.feature_flag_keys) && void 0 !== t4 && t4.length)) return true;
        var _2 = !e3.linked_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.linked_flag_key), p22 = !e3.targeting_flag_key || this.instance.featureFlags.isFeatureEnabled(e3.targeting_flag_key), v2 = (null === (i3 = e3.conditions) || void 0 === i3 ? void 0 : i3.events) && (null === (n3 = e3.conditions) || void 0 === n3 || null === (s3 = n3.events) || void 0 === s3 ? void 0 : s3.values) && (null === (o22 = e3.conditions) || void 0 === o22 || null === (a22 = o22.events) || void 0 === a22 ? void 0 : a22.values.length) > 0, g2 = (null === (l22 = e3.conditions) || void 0 === l22 ? void 0 : l22.actions) && (null === (u22 = e3.conditions) || void 0 === u22 || null === (c2 = u22.actions) || void 0 === c2 ? void 0 : c2.values) && (null === (d22 = e3.conditions) || void 0 === d22 || null === (h22 = d22.actions) || void 0 === h22 ? void 0 : h22.values.length) > 0, f22 = !v2 && !g2 || (null == r2 ? void 0 : r2.includes(e3.id)), m22 = this._canActivateRepeatedly(e3), b2 = !(e3.internal_targeting_flag_key && !m22) || this.instance.featureFlags.isFeatureEnabled(e3.internal_targeting_flag_key), y2 = this.checkFlags(e3);
        return _2 && p22 && b2 && f22 && y2;
      });
      return e2(s2);
    }, t2);
  }
  checkFlags(e2) {
    var t2;
    return null === (t2 = e2.feature_flag_keys) || void 0 === t2 || !t2.length || e2.feature_flag_keys.every((e3) => {
      var { key: t3, value: i2 } = e3;
      return !t3 || !i2 || this.instance.featureFlags.isFeatureEnabled(i2);
    });
  }
  getNextSurveyStep(e2, t2, i2) {
    var n2, r2 = e2.questions[t2], s2 = t2 + 1;
    if (null === (n2 = r2.branching) || void 0 === n2 || !n2.type) return t2 === e2.questions.length - 1 ? Rr.End : s2;
    if (r2.branching.type === Rr.End) return Rr.End;
    if (r2.branching.type === Rr.SpecificQuestion) {
      if (Number.isInteger(r2.branching.index)) return r2.branching.index;
    } else if (r2.branching.type === Rr.ResponseBased) {
      if (r2.type === Fr.SingleChoice) {
        var o22, a22, l22 = r2.choices.indexOf("".concat(i2));
        if (null !== (o22 = r2.branching) && void 0 !== o22 && null !== (a22 = o22.responseValues) && void 0 !== a22 && a22.hasOwnProperty(l22)) {
          var u22 = r2.branching.responseValues[l22];
          return Number.isInteger(u22) ? u22 : u22 === Rr.End ? Rr.End : s2;
        }
      } else if (r2.type === Fr.Rating) {
        var c2, d22;
        if ("number" != typeof i2 || !Number.isInteger(i2)) throw new Error("The response type must be an integer");
        var h22 = function(e3, t3) {
          if (3 === t3) {
            if (e3 < 1 || e3 > 3) throw new Error("The response must be in range 1-3");
            return 1 === e3 ? "negative" : 2 === e3 ? "neutral" : "positive";
          }
          if (5 === t3) {
            if (e3 < 1 || e3 > 5) throw new Error("The response must be in range 1-5");
            return e3 <= 2 ? "negative" : 3 === e3 ? "neutral" : "positive";
          }
          if (7 === t3) {
            if (e3 < 1 || e3 > 7) throw new Error("The response must be in range 1-7");
            return e3 <= 3 ? "negative" : 4 === e3 ? "neutral" : "positive";
          }
          if (10 === t3) {
            if (e3 < 0 || e3 > 10) throw new Error("The response must be in range 0-10");
            return e3 <= 6 ? "detractors" : e3 <= 8 ? "passives" : "promoters";
          }
          throw new Error("The scale must be one of: 3, 5, 7, 10");
        }(i2, r2.scale);
        if (null !== (c2 = r2.branching) && void 0 !== c2 && null !== (d22 = c2.responseValues) && void 0 !== d22 && d22.hasOwnProperty(h22)) {
          var _2 = r2.branching.responseValues[h22];
          return Number.isInteger(_2) ? _2 : _2 === Rr.End ? Rr.End : s2;
        }
      }
      return s2;
    }
    return ms.warn("Falling back to next question index due to unexpected branching type"), s2;
  }
  _canActivateRepeatedly(e2) {
    var t2;
    return O$5(null === (t2 = _$4.__PosthogExtensions__) || void 0 === t2 ? void 0 : t2.canActivateRepeatedly) ? (ms.warn("init was not called"), false) : _$4.__PosthogExtensions__.canActivateRepeatedly(e2);
  }
  canRenderSurvey(e2) {
    O$5(this._surveyManager) ? ms.warn("init was not called") : this.getSurveys((t2) => {
      var i2 = t2.filter((t3) => t3.id === e2)[0];
      this._surveyManager.canRenderSurvey(i2);
    });
  }
  renderSurvey(e2, t2) {
    O$5(this._surveyManager) ? ms.warn("init was not called") : this.getSurveys((i2) => {
      var n2 = i2.filter((t3) => t3.id === e2)[0];
      this._surveyManager.renderSurvey(n2, null == a$a ? void 0 : a$a.querySelector(t2));
    });
  }
}
var ws = B$1("[RateLimiter]");
class Ss {
  constructor(e2) {
    var t2, i2;
    W$3(this, "serverLimits", {}), W$3(this, "lastEventRateLimited", false), W$3(this, "checkForLimiting", (e3) => {
      var t3 = e3.text;
      if (t3 && t3.length) try {
        (JSON.parse(t3).quota_limited || []).forEach((e4) => {
          ws.info("".concat(e4 || "events", " is quota limited.")), this.serverLimits[e4] = (/* @__PURE__ */ new Date()).getTime() + 6e4;
        });
      } catch (e4) {
        return void ws.warn('could not rate limit - continuing. Error: "'.concat(null == e4 ? void 0 : e4.message, '"'), { text: t3 });
      }
    }), this.instance = e2, this.captureEventsPerSecond = (null === (t2 = e2.config.rate_limiting) || void 0 === t2 ? void 0 : t2.events_per_second) || 10, this.captureEventsBurstLimit = Math.max((null === (i2 = e2.config.rate_limiting) || void 0 === i2 ? void 0 : i2.events_burst_limit) || 10 * this.captureEventsPerSecond, this.captureEventsPerSecond), this.lastEventRateLimited = this.clientRateLimitContext(true).isRateLimited;
  }
  clientRateLimitContext() {
    var e2, t2, i2, n2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], r2 = (/* @__PURE__ */ new Date()).getTime(), s2 = null !== (e2 = null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.get_property(Oe$1)) && void 0 !== e2 ? e2 : { tokens: this.captureEventsBurstLimit, last: r2 };
    s2.tokens += (r2 - s2.last) / 1e3 * this.captureEventsPerSecond, s2.last = r2, s2.tokens > this.captureEventsBurstLimit && (s2.tokens = this.captureEventsBurstLimit);
    var o22 = s2.tokens < 1;
    return o22 || n2 || (s2.tokens = Math.max(0, s2.tokens - 1)), !o22 || this.lastEventRateLimited || n2 || this.instance.capture("$$client_ingestion_warning", { $$client_ingestion_warning_message: "posthog-js client rate limited. Config is set to ".concat(this.captureEventsPerSecond, " events per second and ").concat(this.captureEventsBurstLimit, " events burst limit.") }, { skip_client_rate_limiting: true }), this.lastEventRateLimited = o22, null === (i2 = this.instance.persistence) || void 0 === i2 || i2.set_property(Oe$1, s2), { isRateLimited: o22, remainingTokens: s2.tokens };
  }
  isServerRateLimited(e2) {
    var t2 = this.serverLimits[e2 || "events"] || false;
    return false !== t2 && (/* @__PURE__ */ new Date()).getTime() < t2;
  }
}
var Es = () => j$5({ initialPathName: (null == l$5 ? void 0 : l$5.pathname) || "", referringDomain: fi.referringDomain() }, fi.campaignParams());
class ks {
  constructor(e2, t2, i2) {
    W$3(this, "_onSessionIdCallback", (e3) => {
      var t3 = this._getStoredProps();
      if (!t3 || t3.sessionId !== e3) {
        var i3 = { sessionId: e3, props: this._sessionSourceParamGenerator() };
        this._persistence.register({ [$e]: i3 });
      }
    }), this._sessionIdManager = e2, this._persistence = t2, this._sessionSourceParamGenerator = i2 || Es, this._sessionIdManager.onSessionId(this._onSessionIdCallback);
  }
  _getStoredProps() {
    return this._persistence.props[$e];
  }
  getSessionProps() {
    var e2, t2 = null === (e2 = this._getStoredProps()) || void 0 === e2 ? void 0 : e2.props;
    return t2 ? { $client_session_initial_referring_host: t2.referringDomain, $client_session_initial_pathname: t2.initialPathName, $client_session_initial_utm_source: t2.utm_source, $client_session_initial_utm_campaign: t2.utm_campaign, $client_session_initial_utm_medium: t2.utm_medium, $client_session_initial_utm_content: t2.utm_content, $client_session_initial_utm_term: t2.utm_term } : {};
  }
}
var xs = ["ahrefsbot", "ahrefssiteaudit", "applebot", "baiduspider", "bingbot", "bingpreview", "bot.htm", "bot.php", "crawler", "deepscan", "duckduckbot", "facebookexternal", "facebookcatalog", "gptbot", "http://yandex.com/bots", "hubspot", "ia_archiver", "linkedinbot", "mj12bot", "msnbot", "nessus", "petalbot", "pinterest", "prerender", "rogerbot", "screaming frog", "semrushbot", "sitebulb", "slurp", "turnitin", "twitterbot", "vercelbot", "yahoo! slurp", "yandexbot", "headlesschrome", "cypress", "Google-HotelAdsVerifier", "adsbot-google", "apis-google", "duplexweb-google", "feedfetcher-google", "google favicon", "google web preview", "google-read-aloud", "googlebot", "googleweblight", "mediapartners-google", "storebot-google", "Bytespider;"], Is = function(e2, t2) {
  if (!e2) return false;
  var i2 = e2.toLowerCase();
  return xs.concat(t2 || []).some((e3) => {
    var t3 = e3.toLowerCase();
    return -1 !== i2.indexOf(t3);
  });
}, Cs = function(e2, t2) {
  if (!e2) return false;
  var i2 = e2.userAgent;
  if (i2 && Is(i2, t2)) return true;
  try {
    var n2 = null == e2 ? void 0 : e2.userAgentData;
    if (null != n2 && n2.brands && n2.brands.some((e3) => Is(null == e3 ? void 0 : e3.brand, t2))) return true;
  } catch (e3) {
  }
  return !!e2.webdriver;
};
class Ps {
  constructor() {
    this.clicks = [];
  }
  isRageClick(e2, t2, i2) {
    var n2 = this.clicks[this.clicks.length - 1];
    if (n2 && Math.abs(e2 - n2.x) + Math.abs(t2 - n2.y) < 30 && i2 - n2.timestamp < 1e3) {
      if (this.clicks.push({ x: e2, y: t2, timestamp: i2 }), 3 === this.clicks.length) return true;
    } else this.clicks = [{ x: e2, y: t2, timestamp: i2 }];
    return false;
  }
}
var Fs = B$1("[Dead Clicks]"), Rs = () => true, Ts = (e2) => {
  var t2, i2 = !(null === (t2 = e2.instance.persistence) || void 0 === t2 || !t2.get_property(de$2)), n2 = e2.instance.config.capture_dead_clicks;
  return L$3(n2) ? n2 : i2;
};
class $s {
  get lazyLoadedDeadClicksAutocapture() {
    return this._lazyLoadedDeadClicksAutocapture;
  }
  constructor(e2, t2, i2) {
    this.instance = e2, this.isEnabled = t2, this.onCapture = i2, this.startIfEnabled();
  }
  onRemoteConfig(e2) {
    this.instance.persistence && this.instance.persistence.register({ [de$2]: null == e2 ? void 0 : e2.captureDeadClicks }), this.startIfEnabled();
  }
  startIfEnabled() {
    this.isEnabled(this) && this.loadScript(() => {
      this.start();
    });
  }
  loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = _$4.__PosthogExtensions__) && void 0 !== t2 && t2.initDeadClicksAutocapture && e2(), null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "dead-clicks-autocapture", (t3) => {
      t3 ? Fs.error("failed to load script", t3) : e2();
    });
  }
  start() {
    var e2;
    if (a$a) {
      if (!this._lazyLoadedDeadClicksAutocapture && null !== (e2 = _$4.__PosthogExtensions__) && void 0 !== e2 && e2.initDeadClicksAutocapture) {
        var t2 = C$4(this.instance.config.capture_dead_clicks) ? this.instance.config.capture_dead_clicks : {};
        t2.__onCapture = this.onCapture, this._lazyLoadedDeadClicksAutocapture = _$4.__PosthogExtensions__.initDeadClicksAutocapture(this.instance, t2), this._lazyLoadedDeadClicksAutocapture.start(a$a), Fs.info("starting...");
      }
    } else Fs.error("`document` not found. Cannot start.");
  }
  stop() {
    this._lazyLoadedDeadClicksAutocapture && (this._lazyLoadedDeadClicksAutocapture.stop(), this._lazyLoadedDeadClicksAutocapture = void 0, Fs.info("stopping..."));
  }
}
var Os = B$1("[Heatmaps]");
function Ms(e2) {
  return C$4(e2) && "clientX" in e2 && "clientY" in e2 && M$5(e2.clientX) && M$5(e2.clientY);
}
class Ls {
  constructor(e2) {
    var i2;
    W$3(this, "rageclicks", new Ps()), W$3(this, "_enabledServerSide", false), W$3(this, "_initialized", false), W$3(this, "_flushInterval", null), this.instance = e2, this._enabledServerSide = !(null === (i2 = this.instance.persistence) || void 0 === i2 || !i2.props[le$1]), null == t$5 || t$5.addEventListener("beforeunload", () => {
      this.flush();
    });
  }
  get flushIntervalMilliseconds() {
    var e2 = 5e3;
    return C$4(this.instance.config.capture_heatmaps) && this.instance.config.capture_heatmaps.flush_interval_milliseconds && (e2 = this.instance.config.capture_heatmaps.flush_interval_milliseconds), e2;
  }
  get isEnabled() {
    return F$4(this.instance.config.capture_heatmaps) ? F$4(this.instance.config.enable_heatmaps) ? this._enabledServerSide : this.instance.config.enable_heatmaps : false !== this.instance.config.capture_heatmaps;
  }
  startIfEnabled() {
    if (this.isEnabled) {
      if (this._initialized) return;
      Os.info("starting..."), this._setupListeners(), this._flushInterval = setInterval(this.flush.bind(this), this.flushIntervalMilliseconds);
    } else {
      var e2, t2;
      clearInterval(null !== (e2 = this._flushInterval) && void 0 !== e2 ? e2 : void 0), null === (t2 = this.deadClicksCapture) || void 0 === t2 || t2.stop(), this.getAndClearBuffer();
    }
  }
  onRemoteConfig(e2) {
    var t2 = !!e2.heatmaps;
    this.instance.persistence && this.instance.persistence.register({ [le$1]: t2 }), this._enabledServerSide = t2, this.startIfEnabled();
  }
  getAndClearBuffer() {
    var e2 = this.buffer;
    return this.buffer = void 0, e2;
  }
  _onDeadClick(e2) {
    this._onClick(e2.originalEvent, "deadclick");
  }
  _setupListeners() {
    t$5 && a$a && (ie$1(a$a, "click", (e2) => this._onClick(e2 || (null == t$5 ? void 0 : t$5.event)), false, true), ie$1(a$a, "mousemove", (e2) => this._onMouseMove(e2 || (null == t$5 ? void 0 : t$5.event)), false, true), this.deadClicksCapture = new $s(this.instance, Rs, this._onDeadClick.bind(this)), this.deadClicksCapture.startIfEnabled(), this._initialized = true);
  }
  _getProperties(e2, i2) {
    var n2 = this.instance.scrollManager.scrollY(), r2 = this.instance.scrollManager.scrollX(), s2 = this.instance.scrollManager.scrollElement(), o22 = function(e3, i3, n3) {
      for (var r3 = e3; r3 && xi(r3) && !Ii(r3, "body"); ) {
        if (r3 === n3) return false;
        if (m$5(i3, null == t$5 ? void 0 : t$5.getComputedStyle(r3).position)) return true;
        r3 = Ai(r3);
      }
      return false;
    }(Mi(e2), ["fixed", "sticky"], s2);
    return { x: e2.clientX + (o22 ? 0 : r2), y: e2.clientY + (o22 ? 0 : n2), target_fixed: o22, type: i2 };
  }
  _onClick(e2) {
    var t2, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "click";
    if (!ki(e2.target) && Ms(e2)) {
      var n2 = this._getProperties(e2, i2);
      null !== (t2 = this.rageclicks) && void 0 !== t2 && t2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._capture(j$5(j$5({}, n2), {}, { type: "rageclick" })), this._capture(n2);
    }
  }
  _onMouseMove(e2) {
    !ki(e2.target) && Ms(e2) && (clearTimeout(this._mouseMoveTimeout), this._mouseMoveTimeout = setTimeout(() => {
      this._capture(this._getProperties(e2, "mousemove"));
    }, 500));
  }
  _capture(e2) {
    if (t$5) {
      var i2 = t$5.location.href;
      this.buffer = this.buffer || {}, this.buffer[i2] || (this.buffer[i2] = []), this.buffer[i2].push(e2);
    }
  }
  flush() {
    this.buffer && !P$5(this.buffer) && this.instance.capture("$$heatmap", { $heatmap_data: this.getAndClearBuffer() });
  }
}
class As {
  constructor(e2) {
    W$3(this, "_updateScrollData", () => {
      var e3, t2, i2, n2;
      this.context || (this.context = {});
      var r2 = this.scrollElement(), s2 = this.scrollY(), o22 = r2 ? Math.max(0, r2.scrollHeight - r2.clientHeight) : 0, a22 = s2 + ((null == r2 ? void 0 : r2.clientHeight) || 0), l22 = (null == r2 ? void 0 : r2.scrollHeight) || 0;
      this.context.lastScrollY = Math.ceil(s2), this.context.maxScrollY = Math.max(s2, null !== (e3 = this.context.maxScrollY) && void 0 !== e3 ? e3 : 0), this.context.maxScrollHeight = Math.max(o22, null !== (t2 = this.context.maxScrollHeight) && void 0 !== t2 ? t2 : 0), this.context.lastContentY = a22, this.context.maxContentY = Math.max(a22, null !== (i2 = this.context.maxContentY) && void 0 !== i2 ? i2 : 0), this.context.maxContentHeight = Math.max(l22, null !== (n2 = this.context.maxContentHeight) && void 0 !== n2 ? n2 : 0);
    }), this.instance = e2;
  }
  getContext() {
    return this.context;
  }
  resetContext() {
    var e2 = this.context;
    return setTimeout(this._updateScrollData, 0), e2;
  }
  startMeasuringScrollPosition() {
    null == t$5 || t$5.addEventListener("scroll", this._updateScrollData, true), null == t$5 || t$5.addEventListener("scrollend", this._updateScrollData, true), null == t$5 || t$5.addEventListener("resize", this._updateScrollData);
  }
  scrollElement() {
    if (!this.instance.config.scroll_root_selector) return null == t$5 ? void 0 : t$5.document.documentElement;
    var e2 = x$3(this.instance.config.scroll_root_selector) ? this.instance.config.scroll_root_selector : [this.instance.config.scroll_root_selector];
    for (var i2 of e2) {
      var n2 = null == t$5 ? void 0 : t$5.document.querySelector(i2);
      if (n2) return n2;
    }
  }
  scrollY() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollTop || 0;
    }
    return t$5 && (t$5.scrollY || t$5.pageYOffset || t$5.document.documentElement.scrollTop) || 0;
  }
  scrollX() {
    if (this.instance.config.scroll_root_selector) {
      var e2 = this.scrollElement();
      return e2 && e2.scrollLeft || 0;
    }
    return t$5 && (t$5.scrollX || t$5.pageXOffset || t$5.document.documentElement.scrollLeft) || 0;
  }
}
var Ds = B$1("[AutoCapture]");
function Ns(e2, t2) {
  return t2.length > e2 ? t2.slice(0, e2) + "..." : t2;
}
function qs(e2) {
  if (e2.previousElementSibling) return e2.previousElementSibling;
  var t2 = e2;
  do {
    t2 = t2.previousSibling;
  } while (t2 && !xi(t2));
  return t2;
}
function Bs(e2, t2, i2, n2) {
  var r2 = e2.tagName.toLowerCase(), s2 = { tag_name: r2 };
  Li.indexOf(r2) > -1 && !i2 && ("a" === r2.toLowerCase() || "button" === r2.toLowerCase() ? s2.$el_text = Ns(1024, Gi(e2)) : s2.$el_text = Ns(1024, Oi(e2)));
  var o22 = Ti(e2);
  o22.length > 0 && (s2.classes = o22.filter(function(e3) {
    return "" !== e3;
  })), Y$2(e2.attributes, function(i3) {
    var r3;
    if ((!qi(e2) || -1 !== ["name", "id", "class", "aria-label"].indexOf(i3.name)) && ((null == n2 || !n2.includes(i3.name)) && !t2 && Vi(i3.value) && (r3 = i3.name, !R$4(r3) || "_ngcontent" !== r3.substring(0, 10) && "_nghost" !== r3.substring(0, 7)))) {
      var o3 = i3.value;
      "class" === i3.name && (o3 = Fi(o3).join(" ")), s2["attr__" + i3.name] = Ns(1024, o3);
    }
  });
  for (var a22 = 1, l22 = 1, u22 = e2; u22 = qs(u22); ) a22++, u22.tagName === e2.tagName && l22++;
  return s2.nth_child = a22, s2.nth_of_type = l22, s2;
}
function Hs(e2, i2) {
  for (var n2, r2, { e: s2, maskAllElementAttributes: o22, maskAllText: a22, elementAttributeIgnoreList: l22, elementsChainAsString: u22 } = i2, c2 = [e2], d22 = e2; d22.parentNode && !Ii(d22, "body"); ) Pi(d22.parentNode) ? (c2.push(d22.parentNode.host), d22 = d22.parentNode.host) : (c2.push(d22.parentNode), d22 = d22.parentNode);
  var h22, _2 = [], p22 = {}, v2 = false, g2 = false;
  if (Y$2(c2, (e3) => {
    var t2 = Ni(e3);
    "a" === e3.tagName.toLowerCase() && (v2 = e3.getAttribute("href"), v2 = t2 && v2 && Vi(v2) && v2), m$5(Ti(e3), "ph-no-capture") && (g2 = true), _2.push(Bs(e3, o22, a22, l22));
    var i3 = function(e4) {
      if (!Ni(e4)) return {};
      var t3 = {};
      return Y$2(e4.attributes, function(e5) {
        if (e5.name && 0 === e5.name.indexOf("data-ph-capture-attribute")) {
          var i4 = e5.name.replace("data-ph-capture-attribute-", ""), n3 = e5.value;
          i4 && n3 && Vi(n3) && (t3[i4] = n3);
        }
      }), t3;
    }(e3);
    K$2(p22, i3);
  }), g2) return { props: {}, explicitNoCapture: g2 };
  if (a22 || ("a" === e2.tagName.toLowerCase() || "button" === e2.tagName.toLowerCase() ? _2[0].$el_text = Gi(e2) : _2[0].$el_text = Oi(e2)), v2) {
    var f22, b2;
    _2[0].attr__href = v2;
    var y2 = null === (f22 = vt$1(v2)) || void 0 === f22 ? void 0 : f22.host, w2 = null == t$5 || null === (b2 = t$5.location) || void 0 === b2 ? void 0 : b2.host;
    y2 && w2 && y2 !== w2 && (h22 = v2);
  }
  return { props: K$2({ $event_type: s2.type, $ce_version: 1 }, u22 ? {} : { $elements: _2 }, { $elements_chain: Yi(_2) }, null !== (n2 = _2[0]) && void 0 !== n2 && n2.$el_text ? { $el_text: null === (r2 = _2[0]) || void 0 === r2 ? void 0 : r2.$el_text } : {}, h22 && "click" === s2.type ? { $external_click_url: h22 } : {}, p22) };
}
class Us {
  constructor(e2) {
    W$3(this, "_initialized", false), W$3(this, "_isDisabledServerSide", null), W$3(this, "rageclicks", new Ps()), W$3(this, "_elementsChainAsString", false), this.instance = e2, this._elementSelectors = null;
  }
  get config() {
    var e2, t2, i2 = C$4(this.instance.config.autocapture) ? this.instance.config.autocapture : {};
    return i2.url_allowlist = null === (e2 = i2.url_allowlist) || void 0 === e2 ? void 0 : e2.map((e3) => new RegExp(e3)), i2.url_ignorelist = null === (t2 = i2.url_ignorelist) || void 0 === t2 ? void 0 : t2.map((e3) => new RegExp(e3)), i2;
  }
  _addDomEventHandlers() {
    if (this.isBrowserSupported()) {
      if (t$5 && a$a) {
        var e2 = (e3) => {
          e3 = e3 || (null == t$5 ? void 0 : t$5.event);
          try {
            this._captureEvent(e3);
          } catch (e4) {
            Ds.error("Failed to capture event", e4);
          }
        }, i2 = (e3) => {
          e3 = e3 || (null == t$5 ? void 0 : t$5.event), this._captureEvent(e3, v$3);
        };
        ie$1(a$a, "submit", e2, false, true), ie$1(a$a, "change", e2, false, true), ie$1(a$a, "click", e2, false, true), this.config.capture_copied_text && (ie$1(a$a, "copy", i2, false, true), ie$1(a$a, "cut", i2, false, true));
      }
    } else Ds.info("Disabling Automatic Event Collection because this browser is not supported");
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (this._addDomEventHandlers(), this._initialized = true);
  }
  onRemoteConfig(e2) {
    e2.elementsChainAsString && (this._elementsChainAsString = e2.elementsChainAsString), this.instance.persistence && this.instance.persistence.register({ [ae]: !!e2.autocapture_opt_out }), this._isDisabledServerSide = !!e2.autocapture_opt_out, this.startIfEnabled();
  }
  setElementSelectors(e2) {
    this._elementSelectors = e2;
  }
  getElementSelectors(e2) {
    var t2, i2 = [];
    return null === (t2 = this._elementSelectors) || void 0 === t2 || t2.forEach((t3) => {
      var n2 = null == a$a ? void 0 : a$a.querySelectorAll(t3);
      null == n2 || n2.forEach((n3) => {
        e2 === n3 && i2.push(t3);
      });
    }), i2;
  }
  get isEnabled() {
    var e2, t2, i2 = null === (e2 = this.instance.persistence) || void 0 === e2 ? void 0 : e2.props[ae], n2 = this._isDisabledServerSide;
    if ($$3(n2) && !L$3(i2) && !this.instance.config.advanced_disable_decide) return false;
    var r2 = null !== (t2 = this._isDisabledServerSide) && void 0 !== t2 ? t2 : !!i2;
    return !!this.instance.config.autocapture && !r2;
  }
  _captureEvent(e2) {
    var i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "$autocapture";
    if (this.isEnabled) {
      var n2, r2 = Mi(e2);
      if (Ci(r2) && (r2 = r2.parentNode || null), "$autocapture" === i2 && "click" === e2.type && e2 instanceof MouseEvent) this.instance.config.rageclick && null !== (n2 = this.rageclicks) && void 0 !== n2 && n2.isRageClick(e2.clientX, e2.clientY, (/* @__PURE__ */ new Date()).getTime()) && this._captureEvent(e2, "$rageclick");
      var s2 = i2 === v$3;
      if (r2 && Di(r2, e2, this.config, s2, s2 ? ["copy", "cut"] : void 0)) {
        var { props: o22, explicitNoCapture: a22 } = Hs(r2, { e: e2, maskAllElementAttributes: this.instance.config.mask_all_element_attributes, maskAllText: this.instance.config.mask_all_text, elementAttributeIgnoreList: this.config.element_attribute_ignorelist, elementsChainAsString: this._elementsChainAsString });
        if (a22) return false;
        var l22 = this.getElementSelectors(r2);
        if (l22 && l22.length > 0 && (o22.$element_selectors = l22), i2 === v$3) {
          var u22, c2 = $i(null == t$5 || null === (u22 = t$5.getSelection()) || void 0 === u22 ? void 0 : u22.toString()), d22 = e2.type || "clipboard";
          if (!c2) return false;
          o22.$selected_content = c2, o22.$copy_type = d22;
        }
        return this.instance.capture(i2, o22), true;
      }
    }
  }
  isBrowserSupported() {
    return I$4(null == a$a ? void 0 : a$a.querySelectorAll);
  }
}
var zs = B$1("[TracingHeaders]");
class js {
  constructor(e2) {
    W$3(this, "_restoreXHRPatch", void 0), W$3(this, "_restoreFetchPatch", void 0), W$3(this, "_startCapturing", () => {
      var e3, t2, i2, n2;
      F$4(this._restoreXHRPatch) && (null === (e3 = _$4.__PosthogExtensions__) || void 0 === e3 || null === (t2 = e3.tracingHeadersPatchFns) || void 0 === t2 || t2._patchXHR(this.instance.sessionManager));
      F$4(this._restoreFetchPatch) && (null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.tracingHeadersPatchFns) || void 0 === n2 || n2._patchFetch(this.instance.sessionManager));
    }), this.instance = e2;
  }
  _loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = _$4.__PosthogExtensions__) && void 0 !== t2 && t2.tracingHeadersPatchFns && e2(), null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "tracing-headers", (t3) => {
      if (t3) return zs.error("failed to load script", t3);
      e2();
    });
  }
  startIfEnabledOrStop() {
    var e2, t2;
    this.instance.config.__add_tracing_headers ? this._loadScript(this._startCapturing) : (null === (e2 = this._restoreXHRPatch) || void 0 === e2 || e2.call(this), null === (t2 = this._restoreFetchPatch) || void 0 === t2 || t2.call(this), this._restoreXHRPatch = void 0, this._restoreFetchPatch = void 0);
  }
}
var Ws;
!function(e2) {
  e2[e2.PENDING = -1] = "PENDING", e2[e2.DENIED = 0] = "DENIED", e2[e2.GRANTED = 1] = "GRANTED";
}(Ws || (Ws = {}));
class Vs {
  constructor(e2) {
    this.instance = e2;
  }
  get config() {
    return this.instance.config;
  }
  get consent() {
    return this.getDnt() ? Ws.DENIED : this.storedConsent;
  }
  isOptedOut() {
    return this.consent === Ws.DENIED || this.consent === Ws.PENDING && this.config.opt_out_capturing_by_default;
  }
  isOptedIn() {
    return !this.isOptedOut();
  }
  optInOut(e2) {
    this.storage.set(this.storageKey, e2 ? 1 : 0, this.config.cookie_expiration, this.config.cross_subdomain_cookie, this.config.secure_cookie);
  }
  reset() {
    this.storage.remove(this.storageKey, this.config.cross_subdomain_cookie);
  }
  get storageKey() {
    var { token: e2, opt_out_capturing_cookie_prefix: t2 } = this.instance.config;
    return (t2 || "__ph_opt_in_out_") + e2;
  }
  get storedConsent() {
    var e2 = this.storage.get(this.storageKey);
    return "1" === e2 ? Ws.GRANTED : "0" === e2 ? Ws.DENIED : Ws.PENDING;
  }
  get storage() {
    if (!this._storage) {
      var e2 = this.config.opt_out_capturing_persistence_type;
      this._storage = "localStorage" === e2 ? at$1 : st$1;
      var t2 = "localStorage" === e2 ? st$1 : at$1;
      t2.get(this.storageKey) && (this._storage.get(this.storageKey) || this.optInOut("1" === t2.get(this.storageKey)), t2.remove(this.storageKey, this.config.cross_subdomain_cookie));
    }
    return this._storage;
  }
  getDnt() {
    return !!this.config.respect_dnt && !!ne$1([null == o$7 ? void 0 : o$7.doNotTrack, null == o$7 ? void 0 : o$7.msDoNotTrack, _$4.doNotTrack], (e2) => m$5([true, 1, "1", "yes"], e2));
  }
}
var Gs = B$1("[ExceptionAutocapture]");
class Js {
  constructor(e2) {
    var i2;
    W$3(this, "originalOnUnhandledRejectionHandler", void 0), W$3(this, "startCapturing", () => {
      var e3, i3, n2, r2;
      if (t$5 && this.isEnabled && !this.hasHandlers && !this.isCapturing) {
        var s2 = null === (e3 = _$4.__PosthogExtensions__) || void 0 === e3 || null === (i3 = e3.errorWrappingFunctions) || void 0 === i3 ? void 0 : i3.wrapOnError, o22 = null === (n2 = _$4.__PosthogExtensions__) || void 0 === n2 || null === (r2 = n2.errorWrappingFunctions) || void 0 === r2 ? void 0 : r2.wrapUnhandledRejection;
        if (s2 && o22) try {
          this.unwrapOnError = s2(this.captureException.bind(this)), this.unwrapUnhandledRejection = o22(this.captureException.bind(this));
        } catch (e4) {
          Gs.error("failed to start", e4), this.stopCapturing();
        }
        else Gs.error("failed to load error wrapping functions - cannot start");
      }
    }), this.instance = e2, this.remoteEnabled = !(null === (i2 = this.instance.persistence) || void 0 === i2 || !i2.props[ue$3]), this.startIfEnabled();
  }
  get isEnabled() {
    var e2;
    return null !== (e2 = this.remoteEnabled) && void 0 !== e2 && e2;
  }
  get isCapturing() {
    var e2;
    return !(null == t$5 || null === (e2 = t$5.onerror) || void 0 === e2 || !e2.__POSTHOG_INSTRUMENTED__);
  }
  get hasHandlers() {
    return this.originalOnUnhandledRejectionHandler || this.unwrapOnError;
  }
  startIfEnabled() {
    this.isEnabled && !this.isCapturing && (Gs.info("enabled, starting..."), this.loadScript(this.startCapturing));
  }
  loadScript(e2) {
    var t2, i2;
    this.hasHandlers && e2(), null === (t2 = _$4.__PosthogExtensions__) || void 0 === t2 || null === (i2 = t2.loadExternalDependency) || void 0 === i2 || i2.call(t2, this.instance, "exception-autocapture", (t3) => {
      if (t3) return Gs.error("failed to load script", t3);
      e2();
    });
  }
  stopCapturing() {
    var e2, t2;
    null === (e2 = this.unwrapOnError) || void 0 === e2 || e2.call(this), null === (t2 = this.unwrapUnhandledRejection) || void 0 === t2 || t2.call(this);
  }
  onRemoteConfig(e2) {
    var t2 = e2.autocaptureExceptions;
    this.remoteEnabled = !!t2 || false, this.instance.persistence && this.instance.persistence.register({ [ue$3]: this.remoteEnabled }), this.startIfEnabled();
  }
  captureException(e2) {
    var t2 = this.instance.requestRouter.endpointFor("ui");
    e2.$exception_personURL = "".concat(t2, "/project/").concat(this.instance.config.token, "/person/").concat(this.instance.get_distinct_id()), this.instance.exceptions.sendExceptionEvent(e2);
  }
}
var Ys = B$1("[Web Vitals]"), Ks = 9e5;
class Xs {
  constructor(e2) {
    var t2;
    W$3(this, "_enabledServerSide", false), W$3(this, "_initialized", false), W$3(this, "buffer", { url: void 0, metrics: [], firstMetricTimestamp: void 0 }), W$3(this, "_flushToCapture", () => {
      clearTimeout(this._delayedFlushTimer), 0 !== this.buffer.metrics.length && (this.instance.capture("$web_vitals", this.buffer.metrics.reduce((e3, t3) => j$5(j$5({}, e3), {}, { ["$web_vitals_".concat(t3.name, "_event")]: j$5({}, t3), ["$web_vitals_".concat(t3.name, "_value")]: t3.value }), {})), this.buffer = { url: void 0, metrics: [], firstMetricTimestamp: void 0 });
    }), W$3(this, "_addToBuffer", (e3) => {
      var t3, i2 = null === (t3 = this.instance.sessionManager) || void 0 === t3 ? void 0 : t3.checkAndGetSessionAndWindowId(true);
      if (F$4(i2)) Ys.error("Could not read session ID. Dropping metrics!");
      else {
        this.buffer = this.buffer || { url: void 0, metrics: [], firstMetricTimestamp: void 0 };
        var n2 = this._currentURL();
        if (!F$4(n2)) if (O$5(null == e3 ? void 0 : e3.name) || O$5(null == e3 ? void 0 : e3.value)) Ys.error("Invalid metric received", e3);
        else if (this._maxAllowedValue && e3.value >= this._maxAllowedValue) Ys.error("Ignoring metric with value >= " + this._maxAllowedValue, e3);
        else this.buffer.url !== n2 && (this._flushToCapture(), this._delayedFlushTimer = setTimeout(this._flushToCapture, this.flushToCaptureTimeoutMs)), F$4(this.buffer.url) && (this.buffer.url = n2), this.buffer.firstMetricTimestamp = F$4(this.buffer.firstMetricTimestamp) ? Date.now() : this.buffer.firstMetricTimestamp, e3.attribution && e3.attribution.interactionTargetElement && (e3.attribution.interactionTargetElement = void 0), this.buffer.metrics.push(j$5(j$5({}, e3), {}, { $current_url: n2, $session_id: i2.sessionId, $window_id: i2.windowId, timestamp: Date.now() })), this.buffer.metrics.length === this.allowedMetrics.length && this._flushToCapture();
      }
    }), W$3(this, "_startCapturing", () => {
      var e3, t3, i2, n2, r2 = _$4.__PosthogExtensions__;
      F$4(r2) || F$4(r2.postHogWebVitalsCallbacks) || ({ onLCP: e3, onCLS: t3, onFCP: i2, onINP: n2 } = r2.postHogWebVitalsCallbacks), e3 && t3 && i2 && n2 ? (this.allowedMetrics.indexOf("LCP") > -1 && e3(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("CLS") > -1 && t3(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("FCP") > -1 && i2(this._addToBuffer.bind(this)), this.allowedMetrics.indexOf("INP") > -1 && n2(this._addToBuffer.bind(this)), this._initialized = true) : Ys.error("web vitals callbacks not loaded - not starting");
    }), this.instance = e2, this._enabledServerSide = !(null === (t2 = this.instance.persistence) || void 0 === t2 || !t2.props[ce$1]), this.startIfEnabled();
  }
  get allowedMetrics() {
    var e2, t2, i2 = C$4(this.instance.config.capture_performance) ? null === (e2 = this.instance.config.capture_performance) || void 0 === e2 ? void 0 : e2.web_vitals_allowed_metrics : void 0;
    return F$4(i2) ? (null === (t2 = this.instance.persistence) || void 0 === t2 ? void 0 : t2.props[he$1]) || ["CLS", "FCP", "INP", "LCP"] : i2;
  }
  get flushToCaptureTimeoutMs() {
    return (C$4(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals_delayed_flush_ms : void 0) || 5e3;
  }
  get _maxAllowedValue() {
    var e2 = C$4(this.instance.config.capture_performance) && M$5(this.instance.config.capture_performance.__web_vitals_max_value) ? this.instance.config.capture_performance.__web_vitals_max_value : Ks;
    return 0 < e2 && e2 <= 6e4 ? Ks : e2;
  }
  get isEnabled() {
    var e2 = C$4(this.instance.config.capture_performance) ? this.instance.config.capture_performance.web_vitals : void 0;
    return L$3(e2) ? e2 : this._enabledServerSide;
  }
  startIfEnabled() {
    this.isEnabled && !this._initialized && (Ys.info("enabled, starting..."), this.loadScript(this._startCapturing));
  }
  onRemoteConfig(e2) {
    var t2 = C$4(e2.capturePerformance) && !!e2.capturePerformance.web_vitals, i2 = C$4(e2.capturePerformance) ? e2.capturePerformance.web_vitals_allowed_metrics : void 0;
    this.instance.persistence && (this.instance.persistence.register({ [ce$1]: t2 }), this.instance.persistence.register({ [he$1]: i2 })), this._enabledServerSide = t2, this.startIfEnabled();
  }
  loadScript(e2) {
    var t2, i2, n2;
    null !== (t2 = _$4.__PosthogExtensions__) && void 0 !== t2 && t2.postHogWebVitalsCallbacks && e2(), null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 || null === (n2 = i2.loadExternalDependency) || void 0 === n2 || n2.call(i2, this.instance, "web-vitals", (t3) => {
      t3 ? Ys.error("failed to load script", t3) : e2();
    });
  }
  _currentURL() {
    var e2 = t$5 ? t$5.location.href : void 0;
    return e2 || Ys.error("Could not determine current URL"), e2;
  }
}
var Qs = { icontains: (e2, i2) => !!t$5 && i2.href.toLowerCase().indexOf(e2.toLowerCase()) > -1, not_icontains: (e2, i2) => !!t$5 && -1 === i2.href.toLowerCase().indexOf(e2.toLowerCase()), regex: (e2, i2) => !!t$5 && gt$1(i2.href, e2), not_regex: (e2, i2) => !!t$5 && !gt$1(i2.href, e2), exact: (e2, t2) => t2.href === e2, is_not: (e2, t2) => t2.href !== e2 };
class Zs {
  constructor(e2) {
    var t2 = this;
    W$3(this, "getWebExperimentsAndEvaluateDisplayLogic", function() {
      var e3 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      t2.getWebExperiments((e4) => {
        Zs.logInfo("retrieved web experiments from the server"), t2._flagToExperiments = /* @__PURE__ */ new Map(), e4.forEach((e5) => {
          if (e5.feature_flag_key) {
            var i2;
            if (t2._flagToExperiments) Zs.logInfo("setting flag key ", e5.feature_flag_key, " to web experiment ", e5), null === (i2 = t2._flagToExperiments) || void 0 === i2 || i2.set(e5.feature_flag_key, e5);
            var n2 = t2.instance.getFeatureFlag(e5.feature_flag_key);
            R$4(n2) && e5.variants[n2] && t2.applyTransforms(e5.name, n2, e5.variants[n2].transforms);
          } else if (e5.variants) for (var r2 in e5.variants) {
            var s2 = e5.variants[r2];
            Zs.matchesTestVariant(s2) && t2.applyTransforms(e5.name, r2, s2.transforms);
          }
        });
      }, e3);
    }), this.instance = e2, this.instance.onFeatureFlags((e3) => {
      this.onFeatureFlags(e3);
    });
  }
  onFeatureFlags(e2) {
    if (this._is_bot()) Zs.logInfo("Refusing to render web experiment since the viewer is a likely bot");
    else if (!this.instance.config.disable_web_experiments) {
      if (O$5(this._flagToExperiments)) return this._flagToExperiments = /* @__PURE__ */ new Map(), this.loadIfEnabled(), void this.previewWebExperiment();
      Zs.logInfo("applying feature flags", e2), e2.forEach((e3) => {
        var t2;
        if (this._flagToExperiments && null !== (t2 = this._flagToExperiments) && void 0 !== t2 && t2.has(e3)) {
          var i2, n2 = this.instance.getFeatureFlag(e3), r2 = null === (i2 = this._flagToExperiments) || void 0 === i2 ? void 0 : i2.get(e3);
          n2 && null != r2 && r2.variants[n2] && this.applyTransforms(r2.name, n2, r2.variants[n2].transforms);
        }
      });
    }
  }
  previewWebExperiment() {
    var e2 = Zs.getWindowLocation();
    if (null != e2 && e2.search) {
      var t2 = mt$1(null == e2 ? void 0 : e2.search, "__experiment_id"), i2 = mt$1(null == e2 ? void 0 : e2.search, "__experiment_variant");
      t2 && i2 && (Zs.logInfo("previewing web experiments ".concat(t2, " && ").concat(i2)), this.getWebExperiments((e3) => {
        this.showPreviewWebExperiment(parseInt(t2), i2, e3);
      }, false, true));
    }
  }
  loadIfEnabled() {
    this.instance.config.disable_web_experiments || this.getWebExperimentsAndEvaluateDisplayLogic();
  }
  getWebExperiments(e2, t2, i2) {
    if (this.instance.config.disable_web_experiments && !i2) return e2([]);
    var n2 = this.instance.get_property("$web_experiments");
    if (n2 && !t2) return e2(n2);
    this.instance._send_request({ url: this.instance.requestRouter.endpointFor("api", "/api/web_experiments/?token=".concat(this.instance.config.token)), method: "GET", callback: (t3) => {
      if (200 !== t3.statusCode || !t3.json) return e2([]);
      var i3 = t3.json.experiments || [];
      return e2(i3);
    } });
  }
  showPreviewWebExperiment(e2, t2, i2) {
    var n2 = i2.filter((t3) => t3.id === e2);
    n2 && n2.length > 0 && (Zs.logInfo("Previewing web experiment [".concat(n2[0].name, "] with variant [").concat(t2, "]")), this.applyTransforms(n2[0].name, t2, n2[0].variants[t2].transforms, true));
  }
  static matchesTestVariant(e2) {
    return !O$5(e2.conditions) && (Zs.matchUrlConditions(e2) && Zs.matchUTMConditions(e2));
  }
  static matchUrlConditions(e2) {
    var t2;
    if (O$5(e2.conditions) || O$5(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.url)) return true;
    var i2, n2, r2, s2 = Zs.getWindowLocation();
    return !!s2 && (null === (i2 = e2.conditions) || void 0 === i2 || !i2.url || Qs[null !== (n2 = null === (r2 = e2.conditions) || void 0 === r2 ? void 0 : r2.urlMatchType) && void 0 !== n2 ? n2 : "icontains"](e2.conditions.url, s2));
  }
  static getWindowLocation() {
    return null == t$5 ? void 0 : t$5.location;
  }
  static matchUTMConditions(e2) {
    var t2;
    if (O$5(e2.conditions) || O$5(null === (t2 = e2.conditions) || void 0 === t2 ? void 0 : t2.utm)) return true;
    var i2 = fi.campaignParams();
    if (i2.utm_source) {
      var n2, r2, s2, o22, a22, l22, u22, c2, d22, h22, _2, p22, v2, g2, f22, m22, b2 = null === (n2 = e2.conditions) || void 0 === n2 || null === (r2 = n2.utm) || void 0 === r2 || !r2.utm_campaign || (null === (s2 = e2.conditions) || void 0 === s2 || null === (o22 = s2.utm) || void 0 === o22 ? void 0 : o22.utm_campaign) == i2.utm_campaign, y2 = null === (a22 = e2.conditions) || void 0 === a22 || null === (l22 = a22.utm) || void 0 === l22 || !l22.utm_source || (null === (u22 = e2.conditions) || void 0 === u22 || null === (c2 = u22.utm) || void 0 === c2 ? void 0 : c2.utm_source) == i2.utm_source, w2 = null === (d22 = e2.conditions) || void 0 === d22 || null === (h22 = d22.utm) || void 0 === h22 || !h22.utm_medium || (null === (_2 = e2.conditions) || void 0 === _2 || null === (p22 = _2.utm) || void 0 === p22 ? void 0 : p22.utm_medium) == i2.utm_medium, S2 = null === (v2 = e2.conditions) || void 0 === v2 || null === (g2 = v2.utm) || void 0 === g2 || !g2.utm_term || (null === (f22 = e2.conditions) || void 0 === f22 || null === (m22 = f22.utm) || void 0 === m22 ? void 0 : m22.utm_term) == i2.utm_term;
      return b2 && w2 && S2 && y2;
    }
    return false;
  }
  static logInfo(e2) {
    for (var t2 = arguments.length, i2 = new Array(t2 > 1 ? t2 - 1 : 0), n2 = 1; n2 < t2; n2++) i2[n2 - 1] = arguments[n2];
    q$2.info("[WebExperiments] ".concat(e2), i2);
  }
  applyTransforms(e2, t2, i2, n2) {
    var r2;
    this._is_bot() ? Zs.logInfo("Refusing to render web experiment since the viewer is a likely bot") : "control" !== t2 ? i2.forEach((i3) => {
      if (i3.selector) {
        var r3;
        Zs.logInfo("applying transform of variant ".concat(t2, " for experiment ").concat(e2, " "), i3);
        var s2, o22 = 0, a22 = null === (r3 = document) || void 0 === r3 ? void 0 : r3.querySelectorAll(i3.selector);
        if (null == a22 || a22.forEach((e3) => {
          var t3 = e3;
          o22 += 1, i3.attributes && i3.attributes.forEach((e4) => {
            switch (e4.name) {
              case "text":
                t3.innerText = e4.value;
                break;
              case "html":
                t3.innerHTML = e4.value;
                break;
              case "cssClass":
                t3.className = e4.value;
                break;
              default:
                t3.setAttribute(e4.name, e4.value);
            }
          }), i3.text && (t3.innerText = i3.text), i3.html && (t3.parentElement ? t3.parentElement.innerHTML = i3.html : t3.innerHTML = i3.html), i3.css && t3.setAttribute("style", i3.css);
        }), this.instance && this.instance.capture) this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_variant: t2, $web_experiment_preview: n2, $web_experiment_document_url: null === (s2 = Zs.getWindowLocation()) || void 0 === s2 ? void 0 : s2.href, $web_experiment_elements_modified: o22 });
      }
    }) : (Zs.logInfo("Control variants leave the page unmodified."), this.instance && this.instance.capture && this.instance.capture("$web_experiment_applied", { $web_experiment_name: e2, $web_experiment_preview: n2, $web_experiment_variant: t2, $web_experiment_document_url: null === (r2 = Zs.getWindowLocation()) || void 0 === r2 ? void 0 : r2.href, $web_experiment_elements_modified: 0 }));
  }
  _is_bot() {
    return o$7 && this.instance ? Cs(o$7, this.instance.config.custom_blocked_useragents) : void 0;
  }
}
class eo {
  constructor(e2) {
    this.instance = e2;
  }
  sendExceptionEvent(e2) {
    this.instance.capture("$exception", e2, { _noTruncate: true, _batchKey: "exceptionEvent" });
  }
}
var to = ["$set_once", "$set"], io = B$1("[SiteApps]");
class no {
  constructor(e2) {
    this.instance = e2, this.bufferedInvocations = [], this.apps = {};
  }
  get isEnabled() {
    return !!this.instance.config.opt_in_site_apps;
  }
  eventCollector(e2, t2) {
    if (t2) {
      var i2 = this.globalsForEvent(t2);
      this.bufferedInvocations.push(i2), this.bufferedInvocations.length > 1e3 && (this.bufferedInvocations = this.bufferedInvocations.slice(10));
    }
  }
  get siteAppLoaders() {
    var e2, t2;
    return null === (e2 = _$4._POSTHOG_REMOTE_CONFIG) || void 0 === e2 || null === (t2 = e2[this.instance.config.token]) || void 0 === t2 ? void 0 : t2.siteApps;
  }
  init() {
    if (this.isEnabled) {
      var e2 = this.instance._addCaptureHook(this.eventCollector.bind(this));
      this.stopBuffering = () => {
        e2(), this.bufferedInvocations = [], this.stopBuffering = void 0;
      };
    }
  }
  globalsForEvent(e2) {
    var t2, i2, n2, r2, s2, o22, a22;
    if (!e2) throw new Error("Event payload is required");
    var l22 = {}, u22 = this.instance.get_property("$groups") || [], c2 = this.instance.get_property("$stored_group_properties") || {};
    for (var [d22, h22] of Object.entries(c2)) l22[d22] = { id: u22[d22], type: d22, properties: h22 };
    var { $set_once: _2, $set: p22 } = e2;
    return { event: j$5(j$5({}, V$3(e2, to)), {}, { properties: j$5(j$5(j$5({}, e2.properties), p22 ? { $set: j$5(j$5({}, null !== (t2 = null === (i2 = e2.properties) || void 0 === i2 ? void 0 : i2.$set) && void 0 !== t2 ? t2 : {}), p22) } : {}), _2 ? { $set_once: j$5(j$5({}, null !== (n2 = null === (r2 = e2.properties) || void 0 === r2 ? void 0 : r2.$set_once) && void 0 !== n2 ? n2 : {}), _2) } : {}), elements_chain: null !== (s2 = null === (o22 = e2.properties) || void 0 === o22 ? void 0 : o22.$elements_chain) && void 0 !== s2 ? s2 : "", distinct_id: null === (a22 = e2.properties) || void 0 === a22 ? void 0 : a22.distinct_id }), person: { properties: this.instance.get_property("$stored_person_properties") }, groups: l22 };
  }
  setupSiteApp(e2) {
    var t2 = { id: e2.id, loaded: false, errored: false };
    this.apps[e2.id] = t2;
    var i2 = (i3) => {
      var n3;
      for (var r2 of (this.apps[e2.id].errored = !i3, this.apps[e2.id].loaded = true, io.info("Site app with id ".concat(e2.id, " ").concat(i3 ? "loaded" : "errored")), i3 && this.bufferedInvocations.length && (io.info("Processing ".concat(this.bufferedInvocations.length, " events for site app with id ").concat(e2.id)), this.bufferedInvocations.forEach((e3) => {
        var i4;
        return null === (i4 = t2.processEvent) || void 0 === i4 ? void 0 : i4.call(t2, e3);
      })), Object.values(this.apps))) if (!r2.loaded) return;
      null === (n3 = this.stopBuffering) || void 0 === n3 || n3.call(this);
    };
    try {
      var { processEvent: n2 } = e2.init({ posthog: this.instance, callback: (e3) => {
        i2(e3);
      } });
      n2 && (t2.processEvent = n2);
    } catch (t3) {
      io.error("Error while initializing PostHog app with config id ".concat(e2.id), t3), i2(false);
    }
  }
  onCapturedEvent(e2) {
    if (0 !== Object.keys(this.apps).length) {
      var t2 = this.globalsForEvent(e2);
      for (var i2 of Object.values(this.apps)) try {
        var n2;
        null === (n2 = i2.processEvent) || void 0 === n2 || n2.call(i2, t2);
      } catch (t3) {
        io.error("Error while processing event ".concat(e2.event, " for site app ").concat(i2.id), t3);
      }
    }
  }
  onRemoteConfig(e2) {
    var t2, i2, n2, r2 = this;
    if (null !== (t2 = this.siteAppLoaders) && void 0 !== t2 && t2.length) {
      if (!this.isEnabled) return void io.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
      for (var s2 of this.siteAppLoaders) this.setupSiteApp(s2);
      this.instance.on("eventCaptured", (e3) => this.onCapturedEvent(e3));
    } else if (null === (i2 = this.stopBuffering) || void 0 === i2 || i2.call(this), null !== (n2 = e2.siteApps) && void 0 !== n2 && n2.length) if (this.isEnabled) {
      var o22 = function(e3, t3) {
        var i3, n3;
        _$4["__$$ph_site_app_".concat(e3)] = r2.instance, null === (i3 = _$4.__PosthogExtensions__) || void 0 === i3 || null === (n3 = i3.loadSiteApp) || void 0 === n3 || n3.call(i3, r2.instance, t3, (t4) => {
          if (t4) return io.error("Error while initializing PostHog app with config id ".concat(e3), t4);
        });
      };
      for (var { id: a22, url: l22 } of e2.siteApps) o22(a22, l22);
    } else io.error('PostHog site apps are disabled. Enable the "opt_in_site_apps" config to proceed.');
  }
}
var ro = {}, so = () => {
}, oo = "posthog", ao = !hr && -1 === (null == h$5 ? void 0 : h$5.indexOf("MSIE")) && -1 === (null == h$5 ? void 0 : h$5.indexOf("Mozilla")), lo$1 = () => {
  var e2, i2, n2;
  return { api_host: "https://us.i.posthog.com", ui_host: null, token: "", autocapture: true, rageclick: true, cross_subdomain_cookie: (i2 = null == a$a ? void 0 : a$a.location, n2 = null == i2 ? void 0 : i2.hostname, !!R$4(n2) && "herokuapp.com" !== n2.split(".").slice(-2).join(".")), persistence: "localStorage+cookie", persistence_name: "", loaded: so, store_google: true, custom_campaign_params: [], custom_blocked_useragents: [], save_referrer: true, capture_pageview: true, capture_pageleave: "if_capture_pageview", debug: l$5 && R$4(null == l$5 ? void 0 : l$5.search) && -1 !== l$5.search.indexOf("__posthog_debug=true") || false, verbose: false, cookie_expiration: 365, upgrade: false, disable_session_recording: false, disable_persistence: false, disable_web_experiments: true, disable_surveys: false, enable_recording_console_log: void 0, secure_cookie: "https:" === (null == t$5 || null === (e2 = t$5.location) || void 0 === e2 ? void 0 : e2.protocol), ip: true, opt_out_capturing_by_default: false, opt_out_persistence_by_default: false, opt_out_useragent_filter: false, opt_out_capturing_persistence_type: "localStorage", opt_out_capturing_cookie_prefix: null, opt_in_site_apps: false, property_denylist: [], respect_dnt: false, sanitize_properties: null, request_headers: {}, inapp_protocol: "//", inapp_link_new_window: false, request_batching: true, properties_string_max_length: 65535, session_recording: {}, mask_all_element_attributes: false, mask_all_text: false, advanced_disable_decide: false, advanced_disable_feature_flags: false, advanced_disable_feature_flags_on_first_load: false, advanced_disable_toolbar_metrics: false, feature_flag_request_timeout_ms: 3e3, on_request_error: (e3) => {
    var t2 = "Bad HTTP status: " + e3.statusCode + " " + e3.text;
    q$2.error(t2);
  }, get_device_id: (e3) => e3, _onCapture: so, capture_performance: void 0, name: "posthog", bootstrap: {}, disable_compression: false, session_idle_timeout_seconds: 1800, person_profiles: "identified_only", __add_tracing_headers: false, before_send: void 0 };
}, uo = (e2) => {
  var t2 = {};
  F$4(e2.process_person) || (t2.person_profiles = e2.process_person), F$4(e2.xhr_headers) || (t2.request_headers = e2.xhr_headers), F$4(e2.cookie_name) || (t2.persistence_name = e2.cookie_name), F$4(e2.disable_cookie) || (t2.disable_persistence = e2.disable_cookie);
  var i2 = K$2({}, t2, e2);
  return x$3(e2.property_blacklist) && (F$4(e2.property_denylist) ? i2.property_denylist = e2.property_blacklist : x$3(e2.property_denylist) ? i2.property_denylist = [...e2.property_blacklist, ...e2.property_denylist] : q$2.error("Invalid value for property_denylist config: " + e2.property_denylist)), i2;
};
class co {
  constructor() {
    W$3(this, "__forceAllowLocalhost", false);
  }
  get _forceAllowLocalhost() {
    return this.__forceAllowLocalhost;
  }
  set _forceAllowLocalhost(e2) {
    q$2.error("WebPerformanceObserver is deprecated and has no impact on network capture. Use `_forceAllowLocalhostNetworkCapture` on `posthog.sessionRecording`"), this.__forceAllowLocalhost = e2;
  }
}
class ho {
  get decideEndpointWasHit() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.featureFlags) || void 0 === t2 ? void 0 : t2.hasLoadedFlags) && void 0 !== e2 && e2;
  }
  constructor() {
    W$3(this, "webPerformance", new co()), W$3(this, "version", p$5.LIB_VERSION), W$3(this, "_internalEventEmitter", new Mr()), this.config = lo$1(), this.SentryIntegration = Cr, this.sentryIntegration = (e2) => function(e3, t2) {
      var i2 = Ir(e3, t2);
      return { name: xr, processEvent: (e4) => i2(e4) };
    }(this, e2), this.__request_queue = [], this.__loaded = false, this.analyticsDefaultEndpoint = "/e/", this._initialPageviewCaptured = false, this._initialPersonProfilesConfig = null, this.featureFlags = new Ve(this), this.toolbar = new ur(this), this.scrollManager = new As(this), this.pageViewManager = new Or(this), this.surveys = new ys(this), this.experiments = new Zs(this), this.exceptions = new eo(this), this.rateLimiter = new Ss(this), this.requestRouter = new kr(this), this.consent = new Vs(this), this.people = { set: (e2, t2, i2) => {
      var n2 = R$4(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(n2), null == i2 || i2({});
    }, set_once: (e2, t2, i2) => {
      var n2 = R$4(e2) ? { [e2]: t2 } : e2;
      this.setPersonProperties(void 0, n2), null == i2 || i2({});
    } }, this.on("eventCaptured", (e2) => q$2.info('send "'.concat(null == e2 ? void 0 : e2.event, '"'), e2));
  }
  init(e2, t2, i2) {
    if (i2 && i2 !== oo) {
      var n2, r2 = null !== (n2 = ro[i2]) && void 0 !== n2 ? n2 : new ho();
      return r2._init(e2, t2, i2), ro[i2] = r2, ro[oo][i2] = r2, r2;
    }
    return this._init(e2, t2, i2);
  }
  _init(i2) {
    var n2, r2, s2, o22 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, a22 = arguments.length > 2 ? arguments[2] : void 0;
    if (F$4(i2) || T$5(i2)) return q$2.critical("PostHog was initialized without a token. This likely indicates a misconfiguration. Please check the first argument passed to posthog.init()"), this;
    if (this.__loaded) return q$2.warn("You have already initialized PostHog! Re-initializing is a no-op"), this;
    this.__loaded = true, this.config = {}, this._triggered_notifs = [], o22.person_profiles && (this._initialPersonProfilesConfig = o22.person_profiles), this.set_config(K$2({}, lo$1(), uo(o22), { name: a22, token: i2 })), this.config.on_xhr_error && q$2.error("on_xhr_error is deprecated. Use on_request_error instead"), this.compression = o22.disable_compression ? void 0 : e$5.GZipJS, this.persistence = new bi(this.config), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new bi(j$5(j$5({}, this.config), {}, { persistence: "sessionStorage" }));
    var l22 = j$5({}, this.persistence.props), u22 = j$5({}, this.sessionPersistence.props);
    if (this._requestQueue = new cr((e2) => this._send_retriable_request(e2)), this._retryQueue = new br(this), this.__request_queue = [], this.config.__preview_experimental_cookieless_mode || (this.sessionManager = new Sr(this), this.sessionPropsManager = new ks(this.sessionManager, this.persistence)), new js(this).startIfEnabledOrStop(), this.siteApps = new no(this), null === (n2 = this.siteApps) || void 0 === n2 || n2.init(), this.config.__preview_experimental_cookieless_mode || (this.sessionRecording = new ir(this), this.sessionRecording.startIfEnabledOrStop()), this.config.disable_scroll_properties || this.scrollManager.startMeasuringScrollPosition(), this.autocapture = new Us(this), this.autocapture.startIfEnabled(), this.surveys.loadIfEnabled(), this.heatmaps = new Ls(this), this.heatmaps.startIfEnabled(), this.webVitalsAutocapture = new Xs(this), this.exceptionObserver = new Js(this), this.exceptionObserver.startIfEnabled(), this.deadClicksAutocapture = new $s(this, Ts), this.deadClicksAutocapture.startIfEnabled(), p$5.DEBUG = p$5.DEBUG || this.config.debug, p$5.DEBUG && q$2.info("Starting in debug mode", { this: this, config: o22, thisC: j$5({}, this.config), p: l22, s: u22 }), this._sync_opt_out_with_persistence(), void 0 !== (null === (r2 = o22.bootstrap) || void 0 === r2 ? void 0 : r2.distinctID)) {
      var c2, d22, h22 = this.config.get_device_id(Ze()), _2 = null !== (c2 = o22.bootstrap) && void 0 !== c2 && c2.isIdentifiedID ? h22 : o22.bootstrap.distinctID;
      this.persistence.set_property(Te$2, null !== (d22 = o22.bootstrap) && void 0 !== d22 && d22.isIdentifiedID ? "identified" : "anonymous"), this.register({ distinct_id: o22.bootstrap.distinctID, $device_id: _2 });
    }
    if (this._hasBootstrappedFeatureFlags()) {
      var v2, g2, f22 = Object.keys((null === (v2 = o22.bootstrap) || void 0 === v2 ? void 0 : v2.featureFlags) || {}).filter((e2) => {
        var t2, i3;
        return !(null === (t2 = o22.bootstrap) || void 0 === t2 || null === (i3 = t2.featureFlags) || void 0 === i3 || !i3[e2]);
      }).reduce((e2, t2) => {
        var i3, n3;
        return e2[t2] = (null === (i3 = o22.bootstrap) || void 0 === i3 || null === (n3 = i3.featureFlags) || void 0 === n3 ? void 0 : n3[t2]) || false, e2;
      }, {}), m22 = Object.keys((null === (g2 = o22.bootstrap) || void 0 === g2 ? void 0 : g2.featureFlagPayloads) || {}).filter((e2) => f22[e2]).reduce((e2, t2) => {
        var i3, n3, r3, s3;
        null !== (i3 = o22.bootstrap) && void 0 !== i3 && null !== (n3 = i3.featureFlagPayloads) && void 0 !== n3 && n3[t2] && (e2[t2] = null === (r3 = o22.bootstrap) || void 0 === r3 || null === (s3 = r3.featureFlagPayloads) || void 0 === s3 ? void 0 : s3[t2]);
        return e2;
      }, {});
      this.featureFlags.receivedFeatureFlags({ featureFlags: f22, featureFlagPayloads: m22 });
    }
    if (this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: qe, $device_id: null }, "");
    else if (!this.get_distinct_id()) {
      var b2 = this.config.get_device_id(Ze());
      this.register_once({ distinct_id: b2, $device_id: b2 }, ""), this.persistence.set_property(Te$2, "anonymous");
    }
    return null == t$5 || null === (s2 = t$5.addEventListener) || void 0 === s2 || s2.call(t$5, "onpagehide" in self ? "pagehide" : "unload", this._handle_unload.bind(this)), this.toolbar.maybeLoadToolbar(), o22.segment ? $r(this, () => this._loaded()) : this._loaded(), I$4(this.config._onCapture) && this.config._onCapture !== so && (q$2.warn("onCapture is deprecated. Please use `before_send` instead"), this.on("eventCaptured", (e2) => this.config._onCapture(e2.event, e2))), this;
  }
  _onRemoteConfig(t2) {
    var i2, n2, r2, s2, o22, l22, u22, c2, d22;
    if (!a$a || !a$a.body) return q$2.info("document not ready yet, trying again in 500 milliseconds..."), void setTimeout(() => {
      this._onRemoteConfig(t2);
    }, 500);
    this.compression = void 0, t2.supportedCompression && !this.config.disable_compression && (this.compression = m$5(t2.supportedCompression, e$5.GZipJS) ? e$5.GZipJS : m$5(t2.supportedCompression, e$5.Base64) ? e$5.Base64 : void 0), null !== (i2 = t2.analytics) && void 0 !== i2 && i2.endpoint && (this.analyticsDefaultEndpoint = t2.analytics.endpoint), this.set_config({ person_profiles: this._initialPersonProfilesConfig ? this._initialPersonProfilesConfig : t2.defaultIdentifiedOnly ? "identified_only" : "always" }), null === (n2 = this.siteApps) || void 0 === n2 || n2.onRemoteConfig(t2), null === (r2 = this.sessionRecording) || void 0 === r2 || r2.onRemoteConfig(t2), null === (s2 = this.autocapture) || void 0 === s2 || s2.onRemoteConfig(t2), null === (o22 = this.heatmaps) || void 0 === o22 || o22.onRemoteConfig(t2), null === (l22 = this.surveys) || void 0 === l22 || l22.onRemoteConfig(t2), null === (u22 = this.webVitalsAutocapture) || void 0 === u22 || u22.onRemoteConfig(t2), null === (c2 = this.exceptionObserver) || void 0 === c2 || c2.onRemoteConfig(t2), null === (d22 = this.deadClicksAutocapture) || void 0 === d22 || d22.onRemoteConfig(t2);
  }
  _loaded() {
    try {
      this.config.loaded(this);
    } catch (e2) {
      q$2.critical("`loaded` function failed", e2);
    }
    this._start_queue_if_opted_in(), this.config.capture_pageview && setTimeout(() => {
      this.consent.isOptedIn() && this._captureInitialPageview();
    }, 1), new rr(this).load(), this.featureFlags.decide();
  }
  _start_queue_if_opted_in() {
    var e2;
    this.has_opted_out_capturing() || this.config.request_batching && (null === (e2 = this._requestQueue) || void 0 === e2 || e2.enable());
  }
  _dom_loaded() {
    this.has_opted_out_capturing() || J$4(this.__request_queue, (e2) => this._send_retriable_request(e2)), this.__request_queue = [], this._start_queue_if_opted_in();
  }
  _handle_unload() {
    var e2, t2;
    this.config.request_batching ? (this._shouldCapturePageleave() && this.capture("$pageleave"), null === (e2 = this._requestQueue) || void 0 === e2 || e2.unload(), null === (t2 = this._retryQueue) || void 0 === t2 || t2.unload()) : this._shouldCapturePageleave() && this.capture("$pageleave", null, { transport: "sendBeacon" });
  }
  _send_request(e2) {
    this.__loaded && (ao ? this.__request_queue.push(e2) : this.rateLimiter.isServerRateLimited(e2.batchKey) || (e2.transport = e2.transport || this.config.api_transport, e2.url = pr(e2.url, { ip: this.config.ip ? 1 : 0 }), e2.headers = j$5({}, this.config.request_headers), e2.compression = "best-available" === e2.compression ? this.compression : e2.compression, e2.fetchOptions = e2.fetchOptions || this.config.fetch_options, ((e3) => {
      var t2, i2, n2, r2 = j$5({}, e3);
      r2.timeout = r2.timeout || 6e4, r2.url = pr(r2.url, { _: (/* @__PURE__ */ new Date()).getTime().toString(), ver: p$5.LIB_VERSION, compression: r2.compression });
      var s2 = null !== (t2 = r2.transport) && void 0 !== t2 ? t2 : "fetch", o22 = null !== (i2 = null === (n2 = ne$1(fr, (e4) => e4.transport === s2)) || void 0 === n2 ? void 0 : n2.method) && void 0 !== i2 ? i2 : fr[0].method;
      if (!o22) throw new Error("No available transport method");
      o22(r2);
    })(j$5(j$5({}, e2), {}, { callback: (t2) => {
      var i2, n2, r2;
      (this.rateLimiter.checkForLimiting(t2), t2.statusCode >= 400) && (null === (n2 = (r2 = this.config).on_request_error) || void 0 === n2 || n2.call(r2, t2));
      null === (i2 = e2.callback) || void 0 === i2 || i2.call(e2, t2);
    } }))));
  }
  _send_retriable_request(e2) {
    this._retryQueue ? this._retryQueue.retriableRequest(e2) : this._send_request(e2);
  }
  _execute_array(e2) {
    var t2, i2 = [], n2 = [], r2 = [];
    J$4(e2, (e3) => {
      e3 && (t2 = e3[0], x$3(t2) ? r2.push(e3) : I$4(e3) ? e3.call(this) : x$3(e3) && "alias" === t2 ? i2.push(e3) : x$3(e3) && -1 !== t2.indexOf("capture") && I$4(this[t2]) ? r2.push(e3) : n2.push(e3));
    });
    var s2 = function(e3, t3) {
      J$4(e3, function(e4) {
        if (x$3(e4[0])) {
          var i3 = t3;
          Y$2(e4, function(e5) {
            i3 = i3[e5[0]].apply(i3, e5.slice(1));
          });
        } else this[e4[0]].apply(this, e4.slice(1));
      }, t3);
    };
    s2(i2, this), s2(n2, this), s2(r2, this);
  }
  _hasBootstrappedFeatureFlags() {
    var e2, t2;
    return (null === (e2 = this.config.bootstrap) || void 0 === e2 ? void 0 : e2.featureFlags) && Object.keys(null === (t2 = this.config.bootstrap) || void 0 === t2 ? void 0 : t2.featureFlags).length > 0 || false;
  }
  push(e2) {
    this._execute_array([e2]);
  }
  capture(e2, t2, i2) {
    var n2;
    if (this.__loaded && this.persistence && this.sessionPersistence && this._requestQueue) {
      if (!this.consent.isOptedOut()) if (!F$4(e2) && R$4(e2)) {
        if (this.config.opt_out_useragent_filter || !this._is_bot()) {
          var r2 = null != i2 && i2.skip_client_rate_limiting ? void 0 : this.rateLimiter.clientRateLimitContext();
          if (null == r2 || !r2.isRateLimited) {
            this.sessionPersistence.update_search_keyword(), this.config.store_google && this.sessionPersistence.update_campaign_params(), this.config.save_referrer && this.sessionPersistence.update_referrer_info(), (this.config.store_google || this.config.save_referrer) && this.persistence.set_initial_person_info();
            var s2 = /* @__PURE__ */ new Date(), o22 = (null == i2 ? void 0 : i2.timestamp) || s2, a22 = Ze(), l22 = { uuid: a22, event: e2, properties: this._calculate_event_properties(e2, t2 || {}, o22, a22) };
            r2 && (l22.properties.$lib_rate_limit_remaining_tokens = r2.remainingTokens), (null == i2 ? void 0 : i2.$set) && (l22.$set = null == i2 ? void 0 : i2.$set);
            var u22 = this._calculate_set_once_properties(null == i2 ? void 0 : i2.$set_once);
            u22 && (l22.$set_once = u22), (l22 = te$2(l22, null != i2 && i2._noTruncate ? null : this.config.properties_string_max_length)).timestamp = o22, F$4(null == i2 ? void 0 : i2.timestamp) || (l22.properties.$event_time_override_provided = true, l22.properties.$event_time_override_system_time = s2);
            var c2 = j$5(j$5({}, l22.properties.$set), l22.$set);
            if (P$5(c2) || this.setPersonPropertiesForFlags(c2), !O$5(this.config.before_send)) {
              var d22 = this._runBeforeSend(l22);
              if (!d22) return;
              l22 = d22;
            }
            this._internalEventEmitter.emit("eventCaptured", l22);
            var h22 = { method: "POST", url: null !== (n2 = null == i2 ? void 0 : i2._url) && void 0 !== n2 ? n2 : this.requestRouter.endpointFor("api", this.analyticsDefaultEndpoint), data: l22, compression: "best-available", batchKey: null == i2 ? void 0 : i2._batchKey };
            return !this.config.request_batching || i2 && (null == i2 || !i2._batchKey) || null != i2 && i2.send_instantly ? this._send_retriable_request(h22) : this._requestQueue.enqueue(h22), l22;
          }
          q$2.critical("This capture call is ignored due to client rate limiting.");
        }
      } else q$2.error("No event name provided to posthog.capture");
    } else q$2.uninitializedWarning("posthog.capture");
  }
  _addCaptureHook(e2) {
    return this.on("eventCaptured", (t2) => e2(t2.event, t2));
  }
  _calculate_event_properties(e2, t2, i2, n2) {
    if (i2 = i2 || /* @__PURE__ */ new Date(), !this.persistence || !this.sessionPersistence) return t2;
    var r2 = this.persistence.remove_event_timer(e2), s2 = j$5({}, t2);
    if (s2.token = this.config.token, this.config.__preview_experimental_cookieless_mode && (s2.$cklsh_mode = true), "$snapshot" === e2) {
      var o22 = j$5(j$5({}, this.persistence.properties()), this.sessionPersistence.properties());
      return s2.distinct_id = o22.distinct_id, (!R$4(s2.distinct_id) && !M$5(s2.distinct_id) || T$5(s2.distinct_id)) && q$2.error("Invalid distinct_id for replay event. This indicates a bug in your implementation"), s2;
    }
    var l22, u22 = fi.properties();
    if (this.sessionManager) {
      var { sessionId: c2, windowId: d22 } = this.sessionManager.checkAndGetSessionAndWindowId();
      s2.$session_id = c2, s2.$window_id = d22;
    }
    if (this.sessionRecording && (s2.$recording_status = this.sessionRecording.status), this.requestRouter.region === yr.CUSTOM && (s2.$lib_custom_api_host = this.config.api_host), this.sessionPropsManager && this.config.__preview_send_client_session_params && ("$pageview" === e2 || "$pageleave" === e2 || "$autocapture" === e2)) {
      var _2 = this.sessionPropsManager.getSessionProps();
      s2 = K$2(s2, _2);
    }
    if (l22 = "$pageview" === e2 ? this.pageViewManager.doPageView(i2, n2) : "$pageleave" === e2 ? this.pageViewManager.doPageLeave(i2) : this.pageViewManager.doEvent(), s2 = K$2(s2, l22), "$pageview" === e2 && a$a && (s2.title = a$a.title), !F$4(r2)) {
      var p22 = i2.getTime() - r2;
      s2.$duration = parseFloat((p22 / 1e3).toFixed(3));
    }
    h$5 && this.config.opt_out_useragent_filter && (s2.$browser_type = this._is_bot() ? "bot" : "browser"), (s2 = K$2({}, u22, this.persistence.properties(), this.sessionPersistence.properties(), s2)).$is_identified = this._isIdentified(), x$3(this.config.property_denylist) ? Y$2(this.config.property_denylist, function(e3) {
      delete s2[e3];
    }) : q$2.error("Invalid value for property_denylist config: " + this.config.property_denylist + " or property_blacklist config: " + this.config.property_blacklist);
    var v2 = this.config.sanitize_properties;
    v2 && (q$2.error("sanitize_properties is deprecated. Use before_send instead"), s2 = v2(s2, e2));
    var g2 = this._hasPersonProcessing();
    return s2.$process_person_profile = g2, g2 && this._requirePersonProcessing("_calculate_event_properties"), s2;
  }
  _calculate_set_once_properties(e2) {
    if (!this.persistence || !this._hasPersonProcessing()) return e2;
    var t2 = K$2({}, this.persistence.get_initial_props(), e2 || {}), i2 = this.config.sanitize_properties;
    return i2 && (q$2.error("sanitize_properties is deprecated. Use before_send instead"), t2 = i2(t2, "$set_once")), P$5(t2) ? void 0 : t2;
  }
  register(e2, t2) {
    var i2;
    null === (i2 = this.persistence) || void 0 === i2 || i2.register(e2, t2);
  }
  register_once(e2, t2, i2) {
    var n2;
    null === (n2 = this.persistence) || void 0 === n2 || n2.register_once(e2, t2, i2);
  }
  register_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.register(e2);
  }
  unregister(e2) {
    var t2;
    null === (t2 = this.persistence) || void 0 === t2 || t2.unregister(e2);
  }
  unregister_for_session(e2) {
    var t2;
    null === (t2 = this.sessionPersistence) || void 0 === t2 || t2.unregister(e2);
  }
  _register_single(e2, t2) {
    this.register({ [e2]: t2 });
  }
  getFeatureFlag(e2, t2) {
    return this.featureFlags.getFeatureFlag(e2, t2);
  }
  getFeatureFlagPayload(e2) {
    var t2 = this.featureFlags.getFeatureFlagPayload(e2);
    try {
      return JSON.parse(t2);
    } catch (e3) {
      return t2;
    }
  }
  isFeatureEnabled(e2, t2) {
    return this.featureFlags.isFeatureEnabled(e2, t2);
  }
  reloadFeatureFlags() {
    this.featureFlags.reloadFeatureFlags();
  }
  updateEarlyAccessFeatureEnrollment(e2, t2) {
    this.featureFlags.updateEarlyAccessFeatureEnrollment(e2, t2);
  }
  getEarlyAccessFeatures(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    return this.featureFlags.getEarlyAccessFeatures(e2, t2);
  }
  on(e2, t2) {
    return this._internalEventEmitter.on(e2, t2);
  }
  onFeatureFlags(e2) {
    return this.featureFlags.onFeatureFlags(e2);
  }
  onSessionId(e2) {
    var t2, i2;
    return null !== (t2 = null === (i2 = this.sessionManager) || void 0 === i2 ? void 0 : i2.onSessionId(e2)) && void 0 !== t2 ? t2 : () => {
    };
  }
  getSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getSurveys(e2, t2);
  }
  getActiveMatchingSurveys(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    this.surveys.getActiveMatchingSurveys(e2, t2);
  }
  renderSurvey(e2, t2) {
    this.surveys.renderSurvey(e2, t2);
  }
  canRenderSurvey(e2) {
    this.surveys.canRenderSurvey(e2);
  }
  getNextSurveyStep(e2, t2, i2) {
    return this.surveys.getNextSurveyStep(e2, t2, i2);
  }
  identify(e2, t2, i2) {
    if (!this.__loaded || !this.persistence) return q$2.uninitializedWarning("posthog.identify");
    if (M$5(e2) && (e2 = e2.toString(), q$2.warn("The first argument to posthog.identify was a number, but it should be a string. It has been converted to a string.")), e2) {
      if (["distinct_id", "distinctid"].includes(e2.toLowerCase())) q$2.critical('The string "'.concat(e2, '" was set in posthog.identify which indicates an error. This ID should be unique to the user and not a hardcoded string.'));
      else if (this._requirePersonProcessing("posthog.identify")) {
        var n2 = this.get_distinct_id();
        if (this.register({ $user_id: e2 }), !this.get_property("$device_id")) {
          var r2 = n2;
          this.register_once({ $had_persisted_distinct_id: true, $device_id: r2 }, "");
        }
        e2 !== n2 && e2 !== this.get_property(se$2) && (this.unregister(se$2), this.register({ distinct_id: e2 }));
        var s2 = "anonymous" === (this.persistence.get_property(Te$2) || "anonymous");
        e2 !== n2 && s2 ? (this.persistence.set_property(Te$2, "identified"), this.setPersonPropertiesForFlags(t2 || {}, false), this.capture("$identify", { distinct_id: e2, $anon_distinct_id: n2 }, { $set: t2 || {}, $set_once: i2 || {} }), this.featureFlags.setAnonymousDistinctId(n2)) : (t2 || i2) && this.setPersonProperties(t2, i2), e2 !== n2 && (this.reloadFeatureFlags(), this.unregister(Re$2));
      }
    } else q$2.error("Unique user id has not been set in posthog.identify");
  }
  setPersonProperties(e2, t2) {
    (e2 || t2) && this._requirePersonProcessing("posthog.setPersonProperties") && (this.setPersonPropertiesForFlags(e2 || {}), this.capture("$set", { $set: e2 || {}, $set_once: t2 || {} }));
  }
  group(e2, t2, i2) {
    if (e2 && t2) {
      if (this._requirePersonProcessing("posthog.group")) {
        var n2 = this.getGroups();
        n2[e2] !== t2 && this.resetGroupPropertiesForFlags(e2), this.register({ $groups: j$5(j$5({}, n2), {}, { [e2]: t2 }) }), i2 && (this.capture("$groupidentify", { $group_type: e2, $group_key: t2, $group_set: i2 }), this.setGroupPropertiesForFlags({ [e2]: i2 })), n2[e2] === t2 || i2 || this.reloadFeatureFlags();
      }
    } else q$2.error("posthog.group requires a group type and group key");
  }
  resetGroups() {
    this.register({ $groups: {} }), this.resetGroupPropertiesForFlags(), this.reloadFeatureFlags();
  }
  setPersonPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.featureFlags.setPersonPropertiesForFlags(e2, t2);
  }
  resetPersonPropertiesForFlags() {
    this.featureFlags.resetPersonPropertiesForFlags();
  }
  setGroupPropertiesForFlags(e2) {
    var t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this._requirePersonProcessing("posthog.setGroupPropertiesForFlags") && this.featureFlags.setGroupPropertiesForFlags(e2, t2);
  }
  resetGroupPropertiesForFlags(e2) {
    this.featureFlags.resetGroupPropertiesForFlags(e2);
  }
  reset(e2) {
    var t2, i2, n2, r2, s2;
    if (q$2.info("reset"), !this.__loaded) return q$2.uninitializedWarning("posthog.reset");
    var o22 = this.get_property("$device_id");
    if (this.consent.reset(), null === (t2 = this.persistence) || void 0 === t2 || t2.clear(), null === (i2 = this.sessionPersistence) || void 0 === i2 || i2.clear(), null === (n2 = this.surveys) || void 0 === n2 || n2.reset(), null === (r2 = this.persistence) || void 0 === r2 || r2.set_property(Te$2, "anonymous"), null === (s2 = this.sessionManager) || void 0 === s2 || s2.resetSessionId(), this.config.__preview_experimental_cookieless_mode) this.register_once({ distinct_id: qe, $device_id: null }, "");
    else {
      var a22 = this.config.get_device_id(Ze());
      this.register_once({ distinct_id: a22, $device_id: e2 ? a22 : o22 }, "");
    }
  }
  get_distinct_id() {
    return this.get_property("distinct_id");
  }
  getGroups() {
    return this.get_property("$groups") || {};
  }
  get_session_id() {
    var e2, t2;
    return null !== (e2 = null === (t2 = this.sessionManager) || void 0 === t2 ? void 0 : t2.checkAndGetSessionAndWindowId(true).sessionId) && void 0 !== e2 ? e2 : "";
  }
  get_session_replay_url(e2) {
    if (!this.sessionManager) return "";
    var { sessionId: t2, sessionStartTimestamp: i2 } = this.sessionManager.checkAndGetSessionAndWindowId(true), n2 = this.requestRouter.endpointFor("ui", "/project/".concat(this.config.token, "/replay/").concat(t2));
    if (null != e2 && e2.withTimestamp && i2) {
      var r2, s2 = null !== (r2 = e2.timestampLookBack) && void 0 !== r2 ? r2 : 10;
      if (!i2) return n2;
      var o22 = Math.max(Math.floor(((/* @__PURE__ */ new Date()).getTime() - i2) / 1e3) - s2, 0);
      n2 += "?t=".concat(o22);
    }
    return n2;
  }
  alias(e2, t2) {
    return e2 === this.get_property(re$2) ? (q$2.critical("Attempting to create alias for existing People user - aborting."), -2) : this._requirePersonProcessing("posthog.alias") ? (F$4(t2) && (t2 = this.get_distinct_id()), e2 !== t2 ? (this._register_single(se$2, e2), this.capture("$create_alias", { alias: e2, distinct_id: t2 })) : (q$2.warn("alias matches current distinct_id - skipping api call."), this.identify(e2), -1)) : void 0;
  }
  set_config(e2) {
    var t2, i2, n2, r2, s2 = j$5({}, this.config);
    C$4(e2) && (K$2(this.config, uo(e2)), null === (t2 = this.persistence) || void 0 === t2 || t2.update_config(this.config, s2), this.sessionPersistence = "sessionStorage" === this.config.persistence || "memory" === this.config.persistence ? this.persistence : new bi(j$5(j$5({}, this.config), {}, { persistence: "sessionStorage" })), at$1.is_supported() && "true" === at$1.get("ph_debug") && (this.config.debug = true), this.config.debug && (p$5.DEBUG = true, q$2.info("set_config", { config: e2, oldConfig: s2, newConfig: j$5({}, this.config) })), null === (i2 = this.sessionRecording) || void 0 === i2 || i2.startIfEnabledOrStop(), null === (n2 = this.autocapture) || void 0 === n2 || n2.startIfEnabled(), null === (r2 = this.heatmaps) || void 0 === r2 || r2.startIfEnabled(), this.surveys.loadIfEnabled(), this._sync_opt_out_with_persistence());
  }
  startSessionRecording(e2) {
    var t2 = true === e2, i2 = { sampling: t2 || !(null == e2 || !e2.sampling), linked_flag: t2 || !(null == e2 || !e2.linked_flag), url_trigger: t2 || !(null == e2 || !e2.url_trigger), event_trigger: t2 || !(null == e2 || !e2.event_trigger) };
    if (Object.values(i2).some(Boolean)) {
      var n2, r2, s2, o22, a22;
      if (null === (n2 = this.sessionManager) || void 0 === n2 || n2.checkAndGetSessionAndWindowId(), i2.sampling) null === (r2 = this.sessionRecording) || void 0 === r2 || r2.overrideSampling();
      if (i2.linked_flag) null === (s2 = this.sessionRecording) || void 0 === s2 || s2.overrideLinkedFlag();
      if (i2.url_trigger) null === (o22 = this.sessionRecording) || void 0 === o22 || o22.overrideTrigger("url");
      if (i2.event_trigger) null === (a22 = this.sessionRecording) || void 0 === a22 || a22.overrideTrigger("event");
    }
    this.set_config({ disable_session_recording: false });
  }
  stopSessionRecording() {
    this.set_config({ disable_session_recording: true });
  }
  sessionRecordingStarted() {
    var e2;
    return !(null === (e2 = this.sessionRecording) || void 0 === e2 || !e2.started);
  }
  captureException(e2, t2) {
    var i2, n2 = new Error("PostHog syntheticException"), r2 = I$4(null === (i2 = _$4.__PosthogExtensions__) || void 0 === i2 ? void 0 : i2.parseErrorAsProperties) ? _$4.__PosthogExtensions__.parseErrorAsProperties([e2.message, void 0, void 0, void 0, e2], { syntheticException: n2 }) : j$5({ $exception_level: "error", $exception_list: [{ type: e2.name, value: e2.message, mechanism: { handled: true, synthetic: false } }] }, t2);
    this.exceptions.sendExceptionEvent(r2);
  }
  loadToolbar(e2) {
    return this.toolbar.loadToolbar(e2);
  }
  get_property(e2) {
    var t2;
    return null === (t2 = this.persistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  getSessionProperty(e2) {
    var t2;
    return null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.props[e2];
  }
  toString() {
    var e2, t2 = null !== (e2 = this.config.name) && void 0 !== e2 ? e2 : oo;
    return t2 !== oo && (t2 = oo + "." + t2), t2;
  }
  _isIdentified() {
    var e2, t2;
    return "identified" === (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.get_property(Te$2)) || "identified" === (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.get_property(Te$2));
  }
  _hasPersonProcessing() {
    var e2, t2, i2, n2;
    return !("never" === this.config.person_profiles || "identified_only" === this.config.person_profiles && !this._isIdentified() && P$5(this.getGroups()) && (null === (e2 = this.persistence) || void 0 === e2 || null === (t2 = e2.props) || void 0 === t2 || !t2[se$2]) && (null === (i2 = this.persistence) || void 0 === i2 || null === (n2 = i2.props) || void 0 === n2 || !n2[De$1]));
  }
  _shouldCapturePageleave() {
    return true === this.config.capture_pageleave || "if_capture_pageview" === this.config.capture_pageleave && this.config.capture_pageview;
  }
  createPersonProfile() {
    this._hasPersonProcessing() || this._requirePersonProcessing("posthog.createPersonProfile") && this.setPersonProperties({}, {});
  }
  _requirePersonProcessing(e2) {
    return "never" === this.config.person_profiles ? (q$2.error(e2 + ' was called, but process_person is set to "never". This call will be ignored.'), false) : (this._register_single(De$1, true), true);
  }
  _sync_opt_out_with_persistence() {
    var e2, t2, i2, n2, r2 = this.consent.isOptedOut(), s2 = this.config.opt_out_persistence_by_default, o22 = this.config.disable_persistence || r2 && !!s2;
    (null === (e2 = this.persistence) || void 0 === e2 ? void 0 : e2.disabled) !== o22 && (null === (i2 = this.persistence) || void 0 === i2 || i2.set_disabled(o22));
    (null === (t2 = this.sessionPersistence) || void 0 === t2 ? void 0 : t2.disabled) !== o22 && (null === (n2 = this.sessionPersistence) || void 0 === n2 || n2.set_disabled(o22));
  }
  opt_in_capturing(e2) {
    var t2;
    (this.consent.optInOut(true), this._sync_opt_out_with_persistence(), F$4(null == e2 ? void 0 : e2.captureEventName) || null != e2 && e2.captureEventName) && this.capture(null !== (t2 = null == e2 ? void 0 : e2.captureEventName) && void 0 !== t2 ? t2 : "$opt_in", null == e2 ? void 0 : e2.captureProperties, { send_instantly: true });
    this.config.capture_pageview && this._captureInitialPageview();
  }
  opt_out_capturing() {
    this.consent.optInOut(false), this._sync_opt_out_with_persistence();
  }
  has_opted_in_capturing() {
    return this.consent.isOptedIn();
  }
  has_opted_out_capturing() {
    return this.consent.isOptedOut();
  }
  clear_opt_in_out_capturing() {
    this.consent.reset(), this._sync_opt_out_with_persistence();
  }
  _is_bot() {
    return o$7 ? Cs(o$7, this.config.custom_blocked_useragents) : void 0;
  }
  _captureInitialPageview() {
    a$a && !this._initialPageviewCaptured && (this._initialPageviewCaptured = true, this.capture("$pageview", { title: a$a.title }, { send_instantly: true }));
  }
  debug(e2) {
    false === e2 ? (null == t$5 || t$5.console.log("You've disabled debug mode."), localStorage && localStorage.removeItem("ph_debug"), this.set_config({ debug: false })) : (null == t$5 || t$5.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`."), localStorage && localStorage.setItem("ph_debug", "true"), this.set_config({ debug: true }));
  }
  _runBeforeSend(e2) {
    if (O$5(this.config.before_send)) return e2;
    var t2 = x$3(this.config.before_send) ? this.config.before_send : [this.config.before_send], i2 = e2;
    for (var n2 of t2) {
      if (i2 = n2(i2), O$5(i2)) {
        var r2 = "Event '".concat(e2.event, "' was rejected in beforeSend function");
        return D$3(e2.event) ? q$2.warn("".concat(r2, ". This can cause unexpected behavior.")) : q$2.info(r2), null;
      }
      i2.properties && !P$5(i2.properties) || q$2.warn("Event '".concat(e2.event, "' has no properties after beforeSend function, this is likely an error."));
    }
    return i2;
  }
  getPageViewId() {
    var e2;
    return null === (e2 = this.pageViewManager._currentPageview) || void 0 === e2 ? void 0 : e2.pageViewId;
  }
}
!function(e2, t2) {
  for (var i2 = 0; i2 < t2.length; i2++) e2.prototype[t2[i2]] = Z$2(e2.prototype[t2[i2]]);
}(ho, ["identify"]);
var _o, po = (_o = ro[oo] = new ho(), function() {
  function e2() {
    e2.done || (e2.done = true, ao = false, Y$2(ro, function(e3) {
      e3._dom_loaded();
    }));
  }
  null != a$a && a$a.addEventListener && ("complete" === a$a.readyState ? e2() : a$a.addEventListener("DOMContentLoaded", e2, false)), t$5 && ie$1(t$5, "load", e2, true);
}(), _o);
var PostHogContext = reactExports.createContext({ client: po });
function PostHogProvider(_a3) {
  var children = _a3.children, client = _a3.client, apiKey = _a3.apiKey, options2 = _a3.options;
  var posthog = reactExports.useMemo(function() {
    if (client && apiKey) {
      console.warn("[PostHog.js] You have provided both a client and an apiKey to PostHogProvider. The apiKey will be ignored in favour of the client.");
    }
    if (client && options2) {
      console.warn("[PostHog.js] You have provided both a client and options to PostHogProvider. The options will be ignored in favour of the client.");
    }
    if (client) {
      return client;
    }
    if (apiKey) {
      if (po.__loaded) {
        console.warn("[PostHog.js] was already loaded elsewhere. This may cause issues.");
      }
      po.init(apiKey, options2);
    }
    return po;
  }, [client, apiKey]);
  return React$2.createElement(PostHogContext.Provider, { value: { client: posthog } }, children);
}
var usePostHog = function() {
  var client = reactExports.useContext(PostHogContext).client;
  return client;
};
var define_RWJS_ENV_default = { RWJS_API_GRAPHQL_URL: "https://api.landingsite.ai/graphql", RWJS_API_URL: "https://api.landingsite.ai", __REDWOOD__APP_TITLE: "Landingsite", RWJS_EXP_STREAMING_SSR: false, RWJS_EXP_RSC: false };
globalThis.RWJS_API_GRAPHQL_URL = define_RWJS_ENV_default.RWJS_API_GRAPHQL_URL;
globalThis.RWJS_API_URL = define_RWJS_ENV_default.RWJS_API_URL;
globalThis.__REDWOOD__APP_TITLE = define_RWJS_ENV_default.__REDWOOD__APP_TITLE;
globalThis.RWJS_EXP_STREAMING_SSR = define_RWJS_ENV_default.RWJS_EXP_STREAMING_SSR;
globalThis.RWJS_EXP_RSC = define_RWJS_ENV_default.RWJS_EXP_RSC;
class InfallibleErrorBoundary extends React$2.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { hasError: false });
  }
  static getDerivedStateFromError() {
    return { hasError: true };
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ React$2.createElement("h1", null, "Something went wrong and we are unable to show this page.");
    }
    return this.props.children;
  }
}
class FatalErrorBoundary extends React$2.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", { hasError: false, error: void 0 });
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  render() {
    const { page: Page } = this.props;
    if (this.state.hasError) {
      return /* @__PURE__ */ React$2.createElement(InfallibleErrorBoundary, null, /* @__PURE__ */ React$2.createElement(Page, { error: this.state.error }));
    }
    return this.props.children;
  }
}
function createUseAuth(AuthContext) {
  const useAuth2 = () => {
    const context2 = React$2.useContext(AuthContext);
    if (!context2) {
      throw new Error("useAuth must be used within an AuthProvider");
    }
    return context2;
  };
  return useAuth2;
}
function useNoAuth() {
  return {
    loading: false,
    isAuthenticated: false,
    logIn: async () => {
    },
    logOut: async () => {
    },
    signUp: async () => {
    },
    currentUser: null,
    userMetadata: null,
    getToken: async () => null,
    getCurrentUser: async () => null,
    hasRole: () => false,
    reauthenticate: async () => {
    },
    forgotPassword: async () => {
    },
    resetPassword: async () => {
    },
    validateResetToken: async () => {
    },
    type: "default",
    client: void 0,
    hasError: false
  };
}
function createAuthContext() {
  return React$2.createContext(void 0);
}
const spaDefaultAuthProviderState = {
  loading: true,
  isAuthenticated: false,
  userMetadata: null,
  currentUser: null,
  hasError: false
};
const middlewareDefaultAuthProviderState = {
  loading: false,
  isAuthenticated: false,
  userMetadata: null,
  currentUser: null,
  hasError: false
};
const getAuthInitialStateFromServer = () => {
  if (globalThis == null ? void 0 : globalThis.__REDWOOD__SERVER__AUTH_STATE__) {
    const initialState = {
      ...middlewareDefaultAuthProviderState,
      encryptedSession: null,
      ...(globalThis == null ? void 0 : globalThis.__REDWOOD__SERVER__AUTH_STATE__) || {}
    };
    globalThis.__REDWOOD__SERVER__AUTH_STATE__ = null;
    return initialState;
  }
  return null;
};
const ServerAuthContext = React$2.createContext(
  getAuthInitialStateFromServer()
);
const useToken = (authImplementation) => {
  return reactExports.useCallback(async () => {
    try {
      const token = await authImplementation.getToken();
      return token;
    } catch (e2) {
      console.error("Caught internal:", e2);
      return null;
    }
  }, [authImplementation]);
};
const useCurrentUser = (authImplementation) => {
  const getToken = useToken(authImplementation);
  return reactExports.useCallback(async () => {
    var _a3;
    const token = await getToken();
    const response = await globalThis.fetch(globalThis.RWJS_API_GRAPHQL_URL, {
      method: "POST",
      credentials: "include",
      headers: {
        "content-type": "application/json",
        "auth-provider": authImplementation.type,
        authorization: `Bearer ${token}`
      },
      body: JSON.stringify({
        query: "query __REDWOOD__AUTH_GET_CURRENT_USER { redwood { currentUser } }"
      })
    });
    if (response.ok) {
      const { data } = await response.json();
      return (_a3 = data == null ? void 0 : data.redwood) == null ? void 0 : _a3.currentUser;
    } else {
      throw new Error(
        `Could not fetch current user: ${response.statusText} (${response.status})`
      );
    }
  }, [authImplementation, getToken]);
};
const useForgotPassword = (authImplementation) => {
  return reactExports.useCallback(
    async (username) => {
      if (authImplementation.forgotPassword) {
        return await authImplementation.forgotPassword(username);
      } else {
        throw new Error(
          `Auth client ${authImplementation.type} does not implement this function`
        );
      }
    },
    [authImplementation]
  );
};
const useHasRole = (currentUser) => {
  return reactExports.useCallback(
    (rolesToCheck) => {
      var _a3, _b2;
      if (currentUser == null ? void 0 : currentUser.roles) {
        if (typeof rolesToCheck === "string") {
          if (typeof currentUser.roles === "string") {
            return currentUser.roles === rolesToCheck;
          } else if (Array.isArray(currentUser.roles)) {
            return (_a3 = currentUser.roles) == null ? void 0 : _a3.some(
              (allowedRole) => rolesToCheck === allowedRole
            );
          }
        }
        if (Array.isArray(rolesToCheck)) {
          if (Array.isArray(currentUser.roles)) {
            return (_b2 = currentUser.roles) == null ? void 0 : _b2.some(
              (allowedRole) => rolesToCheck.includes(allowedRole)
            );
          } else if (typeof currentUser.roles === "string") {
            return rolesToCheck.some(
              (allowedRole) => (currentUser == null ? void 0 : currentUser.roles) === allowedRole
            );
          }
        }
      }
      return false;
    },
    [currentUser]
  );
};
const notAuthenticatedState = {
  isAuthenticated: false,
  currentUser: null,
  userMetadata: null,
  loading: false,
  hasError: false
};
const useReauthenticate = (authImplementation, setAuthProviderState, getCurrentUser) => {
  const getToken = useToken(authImplementation);
  return reactExports.useCallback(async () => {
    if (authImplementation.loadWhileReauthenticating) {
      setAuthProviderState((oldState) => ({
        ...oldState,
        loading: true
      }));
    }
    try {
      const token = await getToken();
      let currentUser;
      if (token || authImplementation.middlewareAuthEnabled) {
        currentUser = await getCurrentUser();
      }
      if (!currentUser) {
        let loading = false;
        if (authImplementation.clientHasLoaded) {
          loading = !authImplementation.clientHasLoaded();
        }
        setAuthProviderState({
          ...notAuthenticatedState,
          loading,
          client: authImplementation.client
        });
      } else {
        const userMetadata = await authImplementation.getUserMetadata();
        setAuthProviderState((oldState) => ({
          ...oldState,
          userMetadata,
          currentUser,
          isAuthenticated: !!currentUser,
          loading: false,
          client: authImplementation.client
        }));
      }
    } catch (e2) {
      setAuthProviderState({
        ...notAuthenticatedState,
        hasError: true,
        error: e2
      });
    }
  }, [authImplementation, setAuthProviderState, getToken, getCurrentUser]);
};
const useLogIn = (authImplementation, setAuthProviderState, getCurrentUser) => {
  const reauthenticate = useReauthenticate(
    authImplementation,
    setAuthProviderState,
    getCurrentUser
  );
  return reactExports.useCallback(
    async (options2) => {
      setAuthProviderState(spaDefaultAuthProviderState);
      const loginResult = await authImplementation.login(options2);
      await reauthenticate();
      return loginResult;
    },
    [authImplementation, reauthenticate, setAuthProviderState]
  );
};
const useLogOut = (authImplementation, setAuthProviderState) => {
  return reactExports.useCallback(
    async (options2) => {
      const logoutOutput = await authImplementation.logout(options2);
      setAuthProviderState({
        userMetadata: null,
        currentUser: null,
        isAuthenticated: false,
        hasError: false,
        error: void 0,
        loading: false
      });
      return logoutOutput;
    },
    [authImplementation, setAuthProviderState]
  );
};
const useResetPassword = (authImplementation) => {
  return reactExports.useCallback(
    async (options2) => {
      if (authImplementation.resetPassword) {
        return await authImplementation.resetPassword(options2);
      } else {
        throw new Error(
          `Auth client ${authImplementation.type} does not implement this function`
        );
      }
    },
    [authImplementation]
  );
};
const useSignUp = (authImplementation, setAuthProviderState, getCurrentUser) => {
  const reauthenticate = useReauthenticate(
    authImplementation,
    setAuthProviderState,
    getCurrentUser
  );
  return reactExports.useCallback(
    async (options2) => {
      const signupOutput = await authImplementation.signup(options2);
      await reauthenticate();
      return signupOutput;
    },
    [authImplementation, reauthenticate]
  );
};
const useValidateResetToken = (authImplementation) => {
  return reactExports.useCallback(
    async (resetToken) => {
      if (authImplementation.validateResetToken) {
        return await authImplementation.validateResetToken(resetToken);
      } else {
        throw new Error(
          `Auth client ${authImplementation.type} does not implement this function`
        );
      }
    },
    [authImplementation]
  );
};
function createAuthProvider(AuthContext, authImplementation, customProviderHooks) {
  const AuthProvider2 = ({ children }) => {
    const serverAuthState = reactExports.useContext(ServerAuthContext);
    const [authProviderState, setAuthProviderState] = reactExports.useState(serverAuthState || spaDefaultAuthProviderState);
    const getToken = useToken(authImplementation);
    const getCurrentUser = (
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useCurrentUser(authImplementation)
    );
    const reauthenticate = useReauthenticate(
      authImplementation,
      setAuthProviderState,
      getCurrentUser
    );
    const hasRole = (
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useHasRole(authProviderState.currentUser)
    );
    const signUp = useSignUp(
      authImplementation,
      setAuthProviderState,
      getCurrentUser
    );
    const logIn = useLogIn(
      authImplementation,
      setAuthProviderState,
      getCurrentUser
    );
    const logOut = useLogOut(authImplementation, setAuthProviderState);
    const forgotPassword = useForgotPassword(authImplementation);
    const resetPassword = useResetPassword(authImplementation);
    const validateResetToken = useValidateResetToken(authImplementation);
    const type = authImplementation.type;
    const client = authImplementation.client;
    reactExports.useEffect(() => {
      async function doRestoreState() {
        var _a3;
        await ((_a3 = authImplementation.restoreAuthState) == null ? void 0 : _a3.call(authImplementation));
        if (!serverAuthState) {
          reauthenticate();
        }
      }
      doRestoreState();
    }, [reauthenticate, serverAuthState]);
    return /* @__PURE__ */ React$2.createElement(
      AuthContext.Provider,
      {
        value: {
          ...authProviderState,
          signUp,
          logIn,
          logOut,
          getToken,
          getCurrentUser,
          hasRole,
          reauthenticate,
          forgotPassword,
          resetPassword,
          validateResetToken,
          client,
          type
        }
      },
      children
    );
  };
  return AuthProvider2;
}
function createAuthentication(authImplementation, customProviderHooks) {
  const AuthContext = createAuthContext();
  const useAuth2 = createUseAuth(AuthContext);
  const AuthProvider2 = createAuthProvider(
    AuthContext,
    authImplementation
  );
  return { AuthContext, AuthProvider: AuthProvider2, useAuth: useAuth2 };
}
const getApiGraphQLUrl = () => {
  return globalThis.RWJS_API_GRAPHQL_URL;
};
const FetchConfigContext = React$2.createContext({
  uri: getApiGraphQLUrl()
});
const FetchConfigProvider = ({
  useAuth: useAuth2 = useNoAuth,
  ...rest
}) => {
  const { isAuthenticated, type } = useAuth2();
  if (!isAuthenticated) {
    return /* @__PURE__ */ React$2.createElement(
      FetchConfigContext.Provider,
      {
        value: { uri: getApiGraphQLUrl() },
        ...rest
      }
    );
  }
  const headers = {
    "auth-provider": type
  };
  return /* @__PURE__ */ React$2.createElement(
    FetchConfigContext.Provider,
    {
      value: {
        uri: getApiGraphQLUrl(),
        headers
      },
      ...rest
    }
  );
};
const useFetchConfig = () => React$2.useContext(FetchConfigContext);
const GraphQLHooksContext = React$2.createContext({
  useQuery: () => {
    throw new Error(
      "You must register a useQuery hook via the `GraphQLHooksProvider`"
    );
  },
  useMutation: () => {
    throw new Error(
      "You must register a useMutation hook via the `GraphQLHooksProvider`"
    );
  },
  useSubscription: () => {
    throw new Error(
      "You must register a useSubscription hook via the `GraphQLHooksProvider`"
    );
  },
  useSuspenseQuery: () => {
    throw new Error(
      "You must register a useSuspenseQuery hook via the `GraphQLHooksProvider`."
    );
  },
  //  These are apollo specific hooks!
  useBackgroundQuery: () => {
    throw new Error(
      "You must register a useBackgroundQuery hook via the `GraphQLHooksProvider`."
    );
  },
  useReadQuery: () => {
    throw new Error(
      "You must register a useReadQuery hook via the `GraphQLHooksProvider`."
    );
  }
});
const GraphQLHooksProvider = ({
  useQuery: useQuery2,
  useMutation: useMutation2,
  useSubscription: useSubscription2,
  useSuspenseQuery: useSuspenseQuery2,
  useBackgroundQuery: useBackgroundQuery2,
  useReadQuery: useReadQuery2,
  children
}) => {
  return /* @__PURE__ */ React$2.createElement(
    GraphQLHooksContext.Provider,
    {
      value: {
        useQuery: useQuery2,
        useMutation: useMutation2,
        useSubscription: useSubscription2,
        useSuspenseQuery: useSuspenseQuery2,
        useBackgroundQuery: useBackgroundQuery2,
        useReadQuery: useReadQuery2
      }
    },
    children
  );
};
function useQuery$1(query, options2) {
  return React$2.useContext(GraphQLHooksContext).useQuery(
    query,
    options2
  );
}
function useMutation$1(mutation, options2) {
  return React$2.useContext(GraphQLHooksContext).useMutation(
    mutation,
    options2
  );
}
const CellCacheContext = reactExports.createContext(void 0);
function useCellCacheContext() {
  const context2 = reactExports.useContext(CellCacheContext);
  if (!context2) {
    throw new Error(
      "useCellCacheContext must be used within a CellCacheContextProvider"
    );
  }
  return context2;
}
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p3 in b3) if (Object.prototype.hasOwnProperty.call(b3, p3)) d4[p3] = b3[p3];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3)) t2[p3] = s2[p3];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p3 in s2) if (Object.prototype.hasOwnProperty.call(s2, p3) && e2.indexOf(p3) < 0)
    t2[p3] = s2[p3];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p3 = Object.getOwnPropertySymbols(s2); i2 < p3.length; i2++) {
      if (e2.indexOf(p3[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p3[i2]))
        t2[p3[i2]] = s2[p3[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d3 = decorators[i2]) r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f3) {
    if (f3 !== void 0 && typeof f3 !== "function") throw new TypeError("Function expected");
    return f3;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context2 = {};
    for (var p3 in contextIn) context2[p3] = p3 === "access" ? {} : contextIn[p3];
    for (var p3 in contextIn.access) context2.access[p3] = contextIn.access[p3];
    context2.addInitializer = function(f3) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f3 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f3, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f3, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P3, generator) {
  function adopt(value) {
    return value instanceof P3 ? value : new P3(function(resolve) {
      resolve(value);
    });
  }
  return new (P3 || (P3 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f3 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding = Object.create ? function(o3, m3, k2, k22) {
  if (k22 === void 0) k22 = k2;
  var desc = Object.getOwnPropertyDescriptor(m3, k2);
  if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m3[k2];
    } };
  }
  Object.defineProperty(o3, k22, desc);
} : function(o3, m3, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o3[k22] = m3[k2];
};
function __exportStar(m3, o3) {
  for (var p3 in m3) if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(o3, p3)) __createBinding(o3, m3, p3);
}
function __values(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o3[s2], i2 = 0;
  if (m3) return m3.call(o3);
  if (o3 && typeof o3.length === "number") return {
    next: function() {
      if (o3 && i2 >= o3.length) o3 = void 0;
      return { value: o3 && o3[i2++], done: !o3 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n2) {
  var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m3) return o3;
  var i2 = m3.call(o3), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read(arguments[i2]));
  return ar2;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il2; i2++)
    for (var a3 = arguments[i2], j2 = 0, jl2 = a3.length; j2 < jl2; j2++, k2++)
      r2[k2] = a3[j2];
  return r2;
}
function __spreadArray(to2, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l3 = from2.length, ar2; i2 < l3; i2++) {
    if (ar2 || !(i2 in from2)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from2, 0, i2);
      ar2[i2] = from2[i2];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f3) {
    return function(v2) {
      return Promise.resolve(v2).then(f3, reject);
    };
  }
  function verb(n2, f3) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a3, b2) {
          q2.push([n2, v2, a3, b2]) > 1 || resume(n2, v2);
        });
      };
      if (f3) i2[n2] = f3(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v2) {
    if (f3(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i2, p3;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f3) {
    i2[n2] = o3[n2] ? function(v2) {
      return (p3 = !p3) ? { value: __await(o3[n2](v2)), done: false } : f3 ? f3(v2) : v2;
    } : f3;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o3[Symbol.asyncIterator], i2;
  return m3 ? m3.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o3[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d3, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d3 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault = Object.create ? function(o3, v2) {
  Object.defineProperty(o3, "default", { enumerable: true, value: v2 });
} : function(o3, v2) {
  o3["default"] = v2;
};
var ownKeys = function(o3) {
  ownKeys = Object.getOwnPropertyNames || function(o4) {
    var ar2 = [];
    for (var k2 in o4) if (Object.prototype.hasOwnProperty.call(o4, k2)) ar2[ar2.length] = k2;
    return ar2;
  };
  return ownKeys(o3);
};
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 = ownKeys(mod), i2 = 0; i2 < k2.length; i2++) if (k2[i2] !== "default") __createBinding(result, mod, k2[i2]);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f3) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner2;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner2 = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner2) dispose = function() {
      try {
        inner2.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function __disposeResources(env) {
  function fail(e2) {
    env.error = env.hasError ? new _SuppressedError(e2, env.error, "An error was suppressed during disposal.") : e2;
    env.hasError = true;
  }
  var r2, s2 = 0;
  function next() {
    while (r2 = env.stack.pop()) {
      try {
        if (!r2.async && s2 === 1) return s2 = 0, env.stack.push(r2), Promise.resolve().then(next);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
        } else s2 |= 1;
      } catch (e2) {
        fail(e2);
      }
    }
    if (s2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
    return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function(m3, tsx, d3, ext, cm) {
      return tsx ? preserveJsx ? ".jsx" : ".js" : d3 && (!ext || !cm) ? m3 : d3 + ext + "." + cm.toLowerCase() + "js";
    });
  }
  return path;
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __rewriteRelativeImportExtension,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
var genericMessage = "Invariant Violation";
var _a = Object.setPrototypeOf, setPrototypeOf = _a === void 0 ? function(obj, proto) {
  obj.__proto__ = proto;
  return obj;
} : _a;
var InvariantError = (
  /** @class */
  function(_super) {
    __extends(InvariantError2, _super);
    function InvariantError2(message) {
      if (message === void 0) {
        message = genericMessage;
      }
      var _this = _super.call(this, typeof message === "number" ? genericMessage + ": " + message + " (see https://github.com/apollographql/invariant-packages)" : message) || this;
      _this.framesToPop = 1;
      _this.name = genericMessage;
      setPrototypeOf(_this, InvariantError2.prototype);
      return _this;
    }
    return InvariantError2;
  }(Error)
);
function invariant$4(condition, message) {
  if (!condition) {
    throw new InvariantError(message);
  }
}
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf("log");
function wrapConsoleMethod(name) {
  return function() {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      var method = console[name] || console.log;
      return method.apply(console, arguments);
    }
  };
}
(function(invariant22) {
  invariant22.debug = wrapConsoleMethod("debug");
  invariant22.log = wrapConsoleMethod("log");
  invariant22.warn = wrapConsoleMethod("warn");
  invariant22.error = wrapConsoleMethod("error");
})(invariant$4 || (invariant$4 = {}));
function setVerbosity(level) {
  var old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}
const invariant$5 = invariant$4;
const invariant$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InvariantError,
  default: invariant$5,
  get invariant() {
    return invariant$4;
  },
  setVerbosity
}, Symbol.toStringTag, { value: "Module" }));
var version$1 = "3.11.1";
function maybe$1(thunk) {
  try {
    return thunk();
  } catch (_a3) {
  }
}
const global$1 = maybe$1(function() {
  return globalThis;
}) || maybe$1(function() {
  return window;
}) || maybe$1(function() {
  return self;
}) || maybe$1(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe$1(function() {
  return maybe$1.constructor("return this")();
});
var prefixCounts$1 = /* @__PURE__ */ new Map();
function makeUniqueId$1(prefix) {
  var count2 = prefixCounts$1.get(prefix) || 1;
  prefixCounts$1.set(prefix, count2 + 1);
  return "".concat(prefix, ":").concat(count2, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay$1(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId$1("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}
function wrap$3(fn2) {
  return function(message) {
    var args = [];
    for (var _i2 = 1; _i2 < arguments.length; _i2++) {
      args[_i2 - 1] = arguments[_i2];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn2.apply(void 0, [message].concat(args));
  };
}
var invariant$3 = Object.assign(function invariant2(condition, message) {
  var args = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    args[_i2 - 2] = arguments[_i2];
  }
  if (!condition) {
    invariant$4(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
  }
}, {
  debug: wrap$3(invariant$4.debug),
  log: wrap$3(invariant$4.log),
  warn: wrap$3(invariant$4.warn),
  error: wrap$3(invariant$4.error)
});
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    optionalParams[_i2 - 1] = arguments[_i2];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version$1);
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay$1(arg, 2).slice(0, 1e3);
  } catch (_a3) {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global$1[ApolloErrorMessageHandler] && global$1[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version: version$1,
    message,
    args: messageArgs.map(stringify)
  })));
}
var DEV = globalThis.__DEV__ !== false;
const globals$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEV,
  InvariantError,
  __DEV__: DEV,
  global: global$1,
  invariant: invariant$3,
  maybe: maybe$1,
  newInvariantError
}, Symbol.toStringTag, { value: "Module" }));
const version = "16.9.0";
const versionInfo = Object.freeze({
  major: 16,
  minor: 9,
  patch: 0,
  preReleaseTag: null
});
function devAssert$2(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
function invariant$2(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant$2(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
function printLocation(location2) {
  return printSourceLocation(
    location2.source,
    getLocation(location2.source, location2.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i2 = 0; i2 < locationLine.length; i2 += 80) {
      subLines.push(locationLine.slice(i2, i2 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_2, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
class GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location2 of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location2);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error) {
  return error.toString();
}
function formatError(error) {
  return error.toJSON();
}
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}
let Location$1 = class Location {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
let Token$1 = class Token {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
const QueryDocumentKeys$1 = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues$1 = new Set(Object.keys(QueryDocumentKeys$1));
function isNode$2(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues$1.has(maybeKind);
}
var OperationTypeNode$1;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode$1 || (OperationTypeNode$1 = {}));
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
var Kind$1;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind$1 || (Kind$1 = {}));
function isWhiteSpace$1(code) {
  return code === 9 || code === 32;
}
function isDigit$2(code) {
  return code >= 48 && code <= 57;
}
function isLetter$1(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart$1(code) {
  return isLetter$1(code) || code === 95;
}
function isNameContinue$1(code) {
  return isLetter$1(code) || isDigit$2(code) || code === 95;
}
function dedentBlockStringLines$1(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    var _firstNonEmptyLine;
    const line = lines[i2];
    const indent2 = leadingWhitespace$1(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
    lastNonEmptyLine = i2;
    if (i2 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace$1(str) {
  let i2 = 0;
  while (i2 < str.length && isWhiteSpace$1(str.charCodeAt(i2))) {
    ++i2;
  }
  return i2;
}
function isPrintableAsBlockString$1(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i2 = 0; i2 < value.length; ++i2) {
    switch (value.codePointAt(i2)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString$1(value, options2) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace$1(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options2 !== null && options2 !== void 0 && options2.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace$1(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));
class Lexer {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token$1(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
}
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location2) {
  return isLeadingSurrogate(body.charCodeAt(location2)) && isTrailingSurrogate(body.charCodeAt(location2 + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location2) {
  const code = lexer.source.body.codePointAt(location2);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token$1(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit$2(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart$1(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit$2(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart$1(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit$2(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit$2(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size2 = 3;
  while (size2 < 12) {
    const code = body.charCodeAt(position + size2++);
    if (code === 125) {
      if (size2 < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size: size2
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size2
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines$1(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue$1(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}
const MAX_ARRAY_LENGTH$1 = 10;
const MAX_RECURSIVE_DEPTH$1 = 2;
function inspect$2(value) {
  return formatValue$1(value, []);
}
function formatValue$1(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue$1(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue$1(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable$1(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue$1(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray$1(value, seenValues);
  }
  return formatObject$1(value, seenValues);
}
function isJSONable$1(value) {
  return typeof value.toJSON === "function";
}
function formatObject$1(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[" + getObjectTag$1(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue$1(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray$1(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH$1, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue$1(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag$1(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
const isProduction = globalThis.process && // eslint-disable-next-line no-undef
true;
const instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect$2(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);
class Source {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert$2(false, `Body must be a string. Received: ${inspect$2(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert$2(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert$2(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source);
}
function parse(source, options2) {
  const parser2 = new Parser(source, options2);
  return parser2.parseDocument();
}
function parseValue(source, options2) {
  const parser2 = new Parser(source, options2);
  parser2.expectToken(TokenKind.SOF);
  const value = parser2.parseValueLiteral(false);
  parser2.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options2) {
  const parser2 = new Parser(source, options2);
  parser2.expectToken(TokenKind.SOF);
  const value = parser2.parseConstValueLiteral();
  parser2.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options2) {
  const parser2 = new Parser(source, options2);
  parser2.expectToken(TokenKind.SOF);
  const type = parser2.parseTypeReference();
  parser2.expectToken(TokenKind.EOF);
  return type;
}
class Parser {
  constructor(source, options2 = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options2;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind$1.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind$1.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind$1.OPERATION_DEFINITION,
        operation: OperationTypeNode$1.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind$1.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode$1.QUERY;
      case "mutation":
        return OperationTypeNode$1.MUTATION;
      case "subscription":
        return OperationTypeNode$1.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind$1.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind$1.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind$1.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind$1.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind$1.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind$1.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind$1.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind$1.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind$1.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind$1.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind$1.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind$1.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind$1.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind$1.NULL
            });
          default:
            return this.node(token, {
              kind: Kind$1.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind$1.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind$1.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind$1.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind$1.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind$1.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind$1.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind$1.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind$1.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind$1.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind$1.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind$1.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind$1.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind$1.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue2;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue2 = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind$1.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue: defaultValue2,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind$1.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind$1.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind$1.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind$1.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind$1.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind$1.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind$1.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location$1(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
}
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}
const MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x2) => `"${x2}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
function identityFunc(x2) {
  return x2;
}
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
function mapValue(map, fn2) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn2(map[key], key);
  }
  return result;
}
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit$1(aChar) && isDigit$1(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit$1(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit$1(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
const DIGIT_0 = 48;
const DIGIT_9 = 57;
function isDigit$1(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
function suggestionList(input, options2) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options2) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a3, b2) => {
    const distanceDiff = optionsByDistance[a3] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a3, b2);
  });
}
class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a3 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a3.length < b2.length) {
      const tmp = a3;
      a3 = b2;
      b2 = tmp;
    }
    const aLength = a3.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j2 = 0; j2 <= bLength; j2++) {
      rows[0][j2] = j2;
    }
    for (let i2 = 1; i2 <= aLength; i2++) {
      const upRow = rows[(i2 - 1) % 3];
      const currentRow = rows[i2 % 3];
      let smallestCell = currentRow[0] = i2;
      for (let j2 = 1; j2 <= bLength; j2++) {
        const cost = a3[i2 - 1] === b2[j2 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j2] + 1,
          // delete
          currentRow[j2 - 1] + 1,
          // insert
          upRow[j2 - 1] + cost
          // substitute
        );
        if (i2 > 1 && j2 > 1 && a3[i2 - 1] === b2[j2 - 2] && a3[i2 - 2] === b2[j2 - 1]) {
          const doubleDiagonalCell = rows[(i2 - 2) % 3][j2 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j2] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i2 = 0; i2 < strLength; ++i2) {
    array[i2] = str.charCodeAt(i2);
  }
  return array;
}
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}
function printString$2(str) {
  return `"${str.replace(escapedRegExp$1, escapedReplacer$1)}"`;
}
const escapedRegExp$1 = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer$1(str) {
  return escapeSequences$1[str.charCodeAt(0)];
}
const escapeSequences$1 = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK$1 = Object.freeze({});
function visit$1(root2, visitor2, visitorKeys = QueryDocumentKeys$1) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind$1)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind$1(visitor2, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index2 = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode$2(node) || devAssert$2(false, `Invalid AST Node: ${inspect$2(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor2, node, key, parent, path, ancestors);
      if (result === BREAK$1) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode$2(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function visitInParallel$1(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(Kind$1)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i2 = 0; i2 < visitors.length; ++i2) {
      const { enter, leave } = getEnterLeaveForKind$1(visitors[i2], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i2] = enter;
      leaveList[i2] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i2 = 0; i2 < visitors.length; i2++) {
          if (skipping[i2] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i2]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i2], args);
            if (result === false) {
              skipping[i2] = node;
            } else if (result === BREAK$1) {
              skipping[i2] = BREAK$1;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i2 = 0; i2 < visitors.length; i2++) {
          if (skipping[i2] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i2]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i2], args);
            if (result === BREAK$1) {
              skipping[i2] = BREAK$1;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i2] === node) {
            skipping[i2] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind$1(visitor2, kind) {
  const kindVisitor = visitor2[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor2.enter,
    leave: visitor2.leave
  };
}
function getVisitFn$1(visitor2, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind$1(visitor2, kind);
  return isLeaving ? leave : enter;
}
function print$3(ast2) {
  return visit$1(ast2, printDocASTReducer$1);
}
const MAX_LINE_LENGTH$1 = 80;
const printDocASTReducer$1 = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join$1(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap$2("(", join$1(node.variableDefinitions, ", "), ")");
      const prefix = join$1(
        [
          node.operation,
          join$1([node.name, varDefs]),
          join$1(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue: defaultValue2, directives }) => variable + ": " + type + wrap$2(" = ", defaultValue2) + wrap$2(" ", join$1(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block$1(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap$2("", alias, ": ") + name;
      let argsLine = prefix + wrap$2("(", join$1(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH$1) {
        argsLine = prefix + wrap$2("(\n", indent$1(join$1(args, "\n")), "\n)");
      }
      return join$1([argsLine, join$1(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap$2(" ", join$1(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join$1(
      [
        "...",
        wrap$2("on ", typeCondition),
        join$1(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap$2("(", join$1(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$2("", join$1(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString$1(value) : printString$2(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join$1(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join$1(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap$2("(", join$1(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$2("", description, "\n") + join$1(["schema", join$1(directives, " "), block$1(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap$2("", description, "\n") + join$1(["scalar", name, join$1(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$2("", description, "\n") + join$1(
      [
        "type",
        name,
        wrap$2("implements ", join$1(interfaces, " & ")),
        join$1(directives, " "),
        block$1(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap$2("", description, "\n") + name + (hasMultilineItems$1(args) ? wrap$2("(\n", indent$1(join$1(args, "\n")), "\n)") : wrap$2("(", join$1(args, ", "), ")")) + ": " + type + wrap$2(" ", join$1(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue: defaultValue2, directives }) => wrap$2("", description, "\n") + join$1(
      [name + ": " + type, wrap$2("= ", defaultValue2), join$1(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap$2("", description, "\n") + join$1(
      [
        "interface",
        name,
        wrap$2("implements ", join$1(interfaces, " & ")),
        join$1(directives, " "),
        block$1(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap$2("", description, "\n") + join$1(
      ["union", name, join$1(directives, " "), wrap$2("= ", join$1(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap$2("", description, "\n") + join$1(["enum", name, join$1(directives, " "), block$1(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap$2("", description, "\n") + join$1([name, join$1(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap$2("", description, "\n") + join$1(["input", name, join$1(directives, " "), block$1(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap$2("", description, "\n") + "directive @" + name + (hasMultilineItems$1(args) ? wrap$2("(\n", indent$1(join$1(args, "\n")), "\n)") : wrap$2("(", join$1(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join$1(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join$1(
      ["extend schema", join$1(directives, " "), block$1(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join$1(["extend scalar", name, join$1(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join$1(
      [
        "extend type",
        name,
        wrap$2("implements ", join$1(interfaces, " & ")),
        join$1(directives, " "),
        block$1(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join$1(
      [
        "extend interface",
        name,
        wrap$2("implements ", join$1(interfaces, " & ")),
        join$1(directives, " "),
        block$1(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join$1(
      [
        "extend union",
        name,
        join$1(directives, " "),
        wrap$2("= ", join$1(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join$1(["extend enum", name, join$1(directives, " "), block$1(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join$1(["extend input", name, join$1(directives, " "), block$1(fields)], " ")
  }
};
function join$1(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block$1(array) {
  return wrap$2("{\n", indent$1(join$1(array, "\n")), "\n}");
}
function wrap$2(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent$1(str) {
  return wrap$2("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems$1(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind$1.NULL:
      return null;
    case Kind$1.INT:
      return parseInt(valueNode.value, 10);
    case Kind$1.FLOAT:
      return parseFloat(valueNode.value);
    case Kind$1.STRING:
    case Kind$1.ENUM:
    case Kind$1.BOOLEAN:
      return valueNode.value;
    case Kind$1.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind$1.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind$1.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
function assertName(name) {
  name != null || devAssert$2(false, "Must provide name.");
  typeof name === "string" || devAssert$2(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i2 = 1; i2 < name.length; ++i2) {
    if (!isNameContinue$1(name.charCodeAt(i2))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart$1(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function assertType(type) {
  if (!isType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL type.`);
  }
  return type;
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function assertScalarType(type) {
  if (!isScalarType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL Scalar type.`);
  }
  return type;
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function assertObjectType(type) {
  if (!isObjectType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL Object type.`);
  }
  return type;
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function assertInterfaceType(type) {
  if (!isInterfaceType(type)) {
    throw new Error(
      `Expected ${inspect$2(type)} to be a GraphQL Interface type.`
    );
  }
  return type;
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function assertUnionType(type) {
  if (!isUnionType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL Union type.`);
  }
  return type;
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function assertEnumType(type) {
  if (!isEnumType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL Enum type.`);
  }
  return type;
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function assertInputObjectType(type) {
  if (!isInputObjectType(type)) {
    throw new Error(
      `Expected ${inspect$2(type)} to be a GraphQL Input Object type.`
    );
  }
  return type;
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function assertListType(type) {
  if (!isListType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL List type.`);
  }
  return type;
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function assertNonNullType(type) {
  if (!isNonNullType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL Non-Null type.`);
  }
  return type;
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function assertInputType(type) {
  if (!isInputType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL input type.`);
  }
  return type;
}
function isOutputType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isWrappingType(type) && isOutputType(type.ofType);
}
function assertOutputType(type) {
  if (!isOutputType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL output type.`);
  }
  return type;
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function assertLeafType(type) {
  if (!isLeafType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL leaf type.`);
  }
  return type;
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function assertCompositeType(type) {
  if (!isCompositeType(type)) {
    throw new Error(
      `Expected ${inspect$2(type)} to be a GraphQL composite type.`
    );
  }
  return type;
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
function assertAbstractType(type) {
  if (!isAbstractType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL abstract type.`);
  }
  return type;
}
class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert$2(false, `Expected ${inspect$2(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert$2(
      false,
      `Expected ${inspect$2(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function assertWrappingType(type) {
  if (!isWrappingType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL wrapping type.`);
  }
  return type;
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function assertNullableType(type) {
  if (!isNullableType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL nullable type.`);
  }
  return type;
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function isNamedType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type);
}
function assertNamedType(type) {
  if (!isNamedType(type)) {
    throw new Error(`Expected ${inspect$2(type)} to be a GraphQL named type.`);
  }
  return type;
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
class GraphQLScalarType {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert$2(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect$2(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert$2(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert$2(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLObjectType {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert$2(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect$2(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert$2(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert$2(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert$2(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert$2(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect$2(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert$2(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
class GraphQLInterfaceType {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert$2(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect$2(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLUnionType {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert$2(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect$2(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert$2(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
class GraphQLEnumType {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect$2(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect$2(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind$1.ENUM) {
      const valueStr = print$3(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print$3(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert$2(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert$2(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect$2(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
class GraphQLInputObjectType {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert$2(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert$2(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
const GRAPHQL_MAX_INT = 2147483647;
const GRAPHQL_MIN_INT = -2147483648;
const GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect$2(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect$2(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect$2(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind$1.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print$3(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
const GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect$2(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect$2(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind$1.FLOAT && valueNode.kind !== Kind$1.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print$3(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
const GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect$2(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect$2(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind$1.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print$3(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect$2(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect$2(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind$1.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print$3(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect$2(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect$2(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind$1.STRING && valueNode.kind !== Kind$1.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print$3(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
const specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function isSpecifiedScalarType(type) {
  return specifiedScalarTypes.some(({ name }) => type.name === name);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(
      `Expected ${inspect$2(directive)} to be a GraphQL directive.`
    );
  }
  return directive;
}
class GraphQLDirective {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert$2(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert$2(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
const GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
const GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
const DEFAULT_DEPRECATION_REASON = "No longer supported";
const GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
const GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
const GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
const specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name }) => name === directive.name);
}
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind$1.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind$1.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind$1.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind$1.OBJECT_FIELD,
          name: {
            kind: Kind$1.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind$1.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind$1.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind$1.INT,
        value: stringNum
      } : {
        kind: Kind$1.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind$1.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind$1.INT,
          value: serialized
        };
      }
      return {
        kind: Kind$1.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect$2(serialized)}.`);
  }
  invariant$2(false, "Unexpected input type: " + inspect$2(type));
}
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
const __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
const __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
const __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
const __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant$2(false, `Unexpected type: "${inspect$2(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type) => {
        if (isInputObjectType(type)) {
          return type.isOneOf;
        }
      }
    }
  })
});
const __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
const __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue: defaultValue2 } = inputValue;
        const valueAST = astFromValue(defaultValue2, type);
        return valueAST ? print$3(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
const __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
const __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
const SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);
function isIntrospectionType(type) {
  return introspectionTypes.some(({ name }) => type.name === name);
}
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect$2(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
class GraphQLSchema {
  // Used as a cache for validateSchema().
  constructor(config) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config.assumeValid === true ? [] : void 0;
    isObjectLike(config) || devAssert$2(false, "Must provide configuration object.");
    !config.types || Array.isArray(config.types) || devAssert$2(
      false,
      `"types" must be Array if provided but got: ${inspect$2(config.types)}.`
    );
    !config.directives || Array.isArray(config.directives) || devAssert$2(
      false,
      `"directives" must be Array if provided but got: ${inspect$2(config.directives)}.`
    );
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config.query;
    this._mutationType = config.mutation;
    this._subscriptionType = config.subscription;
    this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config.types);
    if (config.types != null) {
      for (const type of config.types) {
        allReferencedTypes.delete(type);
        collectReferencedTypes(type, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert$2(
        false,
        "One of the provided types for building the Schema is missing a name."
      );
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(
          `Schema must contain uniquely named types but contains multiple types named "${typeName}".`
        );
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode$1.QUERY:
        return this.getQueryType();
      case OperationTypeNode$1.MUTATION:
        return this.getMutationType();
      case OperationTypeNode$1.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name) {
    return this.getTypeMap()[name];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map = this._subTypeMap[abstractType.name];
    if (map === void 0) {
      map = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type of abstractType.getTypes()) {
          map[type.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type of implementations.objects) {
          map[type.name] = true;
        }
        for (const type of implementations.interfaces) {
          map[type.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map;
    }
    return map[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name) {
    return this.getDirectives().find((directive) => directive.name === name);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
}
function collectReferencedTypes(type, typeSet) {
  const namedType = getNamedType(type);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context2 = new SchemaValidationContext(schema);
  validateRootTypes(context2);
  validateDirectives(context2);
  validateTypes(context2);
  const errors2 = context2.getErrors();
  schema.__validationErrors = errors2;
  return errors2;
}
function assertValidSchema(schema) {
  const errors2 = validateSchema(schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error) => error.message).join("\n\n"));
  }
}
class SchemaValidationContext {
  constructor(schema) {
    this._errors = [];
    this.schema = schema;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(
      new GraphQLError(message, {
        nodes: _nodes
      })
    );
  }
  getErrors() {
    return this._errors;
  }
}
function validateRootTypes(context2) {
  const schema = context2.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context2.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context2.reportError(
      `Query root type must be Object type, it cannot be ${inspect$2(
        queryType
      )}.`,
      (_getOperationTypeNode = getOperationTypeNode(
        schema,
        OperationTypeNode$1.QUERY
      )) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode
    );
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context2.reportError(
      `Mutation root type must be Object type if provided, it cannot be ${inspect$2(mutationType)}.`,
      (_getOperationTypeNode2 = getOperationTypeNode(
        schema,
        OperationTypeNode$1.MUTATION
      )) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode
    );
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context2.reportError(
      `Subscription root type must be Object type if provided, it cannot be ${inspect$2(subscriptionType)}.`,
      (_getOperationTypeNode3 = getOperationTypeNode(
        schema,
        OperationTypeNode$1.SUBSCRIPTION
      )) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode
    );
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap(
    // FIXME: https://github.com/graphql/graphql-js/issues/2203
    (schemaNode) => {
      var _schemaNode$operation;
      return (
        /* c8 ignore next */
        (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []
      );
    }
  ).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context2) {
  for (const directive of context2.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context2.reportError(
        `Expected directive but got: ${inspect$2(directive)}.`,
        directive === null || directive === void 0 ? void 0 : directive.astNode
      );
      continue;
    }
    validateName(context2, directive);
    for (const arg of directive.args) {
      validateName(context2, arg);
      if (!isInputType(arg.type)) {
        context2.reportError(
          `The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect$2(arg.type)}.`,
          arg.astNode
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context2.reportError(
          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
          ]
        );
      }
    }
  }
}
function validateName(context2, node) {
  if (node.name.startsWith("__")) {
    context2.reportError(
      `Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      node.astNode
    );
  }
}
function validateTypes(context2) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context2);
  const typeMap = context2.schema.getTypeMap();
  for (const type of Object.values(typeMap)) {
    if (!isNamedType(type)) {
      context2.reportError(
        `Expected GraphQL named type but got: ${inspect$2(type)}.`,
        type.astNode
      );
      continue;
    }
    if (!isIntrospectionType(type)) {
      validateName(context2, type);
    }
    if (isObjectType(type)) {
      validateFields(context2, type);
      validateInterfaces(context2, type);
    } else if (isInterfaceType(type)) {
      validateFields(context2, type);
      validateInterfaces(context2, type);
    } else if (isUnionType(type)) {
      validateUnionMembers(context2, type);
    } else if (isEnumType(type)) {
      validateEnumValues(context2, type);
    } else if (isInputObjectType(type)) {
      validateInputFields(context2, type);
      validateInputObjectCircularRefs(type);
    }
  }
}
function validateFields(context2, type) {
  const fields = Object.values(type.getFields());
  if (fields.length === 0) {
    context2.reportError(`Type ${type.name} must define one or more fields.`, [
      type.astNode,
      ...type.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context2, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context2.reportError(
        `The type of ${type.name}.${field.name} must be Output Type but got: ${inspect$2(field.type)}.`,
        (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type
      );
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context2, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context2.reportError(
          `The type of ${type.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect$2(arg.type)}.`,
          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type
        );
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context2.reportError(
          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,
          [
            getDeprecatedDirectiveNode(arg.astNode),
            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
          ]
        );
      }
    }
  }
}
function validateInterfaces(context2, type) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context2.reportError(
        `Type ${inspect$2(type)} must only implement Interface types, it cannot implement ${inspect$2(iface)}.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (type === iface) {
      context2.reportError(
        `Type ${type.name} cannot implement itself because it would create a circular reference.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context2.reportError(
        `Type ${type.name} can only implement ${iface.name} once.`,
        getAllImplementsInterfaceNodes(type, iface)
      );
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context2, type, iface);
    validateTypeImplementsInterface(context2, type, iface);
  }
}
function validateTypeImplementsInterface(context2, type, iface) {
  const typeFieldMap = type.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context2.reportError(
        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,
        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes]
      );
      continue;
    }
    if (!isTypeSubTypeOf(context2.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context2.reportError(
        `Interface field ${iface.name}.${fieldName} expects type ${inspect$2(ifaceField.type)} but ${type.name}.${fieldName} is type ${inspect$2(typeField.type)}.`,
        [
          (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
          (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
        ]
      );
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context2.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,
          [ifaceArg.astNode, typeField.astNode]
        );
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context2.reportError(
          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect$2(ifaceArg.type)} but ${type.name}.${fieldName}(${argName}:) is type ${inspect$2(typeArg.type)}.`,
          [
            (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
            (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
          ]
        );
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context2.reportError(
          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,
          [typeArg.astNode, ifaceField.astNode]
        );
      }
    }
  }
}
function validateTypeImplementsAncestors(context2, type, iface) {
  const ifaceInterfaces = type.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context2.reportError(
        transitive === type ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,
        [
          ...getAllImplementsInterfaceNodes(iface, transitive),
          ...getAllImplementsInterfaceNodes(type, iface)
        ]
      );
    }
  }
}
function validateUnionMembers(context2, union) {
  const memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context2.reportError(
      `Union type ${union.name} must define one or more member types.`,
      [union.astNode, ...union.extensionASTNodes]
    );
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context2.reportError(
        `Union type ${union.name} can only include type ${memberType.name} once.`,
        getUnionMemberTypeNodes(union, memberType.name)
      );
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context2.reportError(
        `Union type ${union.name} can only include Object types, it cannot include ${inspect$2(memberType)}.`,
        getUnionMemberTypeNodes(union, String(memberType))
      );
    }
  }
}
function validateEnumValues(context2, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context2.reportError(
      `Enum type ${enumType.name} must define one or more values.`,
      [enumType.astNode, ...enumType.extensionASTNodes]
    );
  }
  for (const enumValue of enumValues) {
    validateName(context2, enumValue);
  }
}
function validateInputFields(context2, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context2.reportError(
      `Input Object type ${inputObj.name} must define one or more fields.`,
      [inputObj.astNode, ...inputObj.extensionASTNodes]
    );
  }
  for (const field of fields) {
    validateName(context2, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context2.reportError(
        `The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect$2(field.type)}.`,
        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type
      );
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context2.reportError(
        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,
        [
          getDeprecatedDirectiveNode(field.astNode),
          (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
        ]
      );
    }
    if (inputObj.isOneOf) {
      validateOneOfInputObjectField(inputObj, field, context2);
    }
  }
}
function validateOneOfInputObjectField(type, field, context2) {
  if (isNonNullType(field.type)) {
    var _field$astNode4;
    context2.reportError(
      `OneOf input field ${type.name}.${field.name} must be nullable.`,
      (_field$astNode4 = field.astNode) === null || _field$astNode4 === void 0 ? void 0 : _field$astNode4.type
    );
  }
  if (field.defaultValue !== void 0) {
    context2.reportError(
      `OneOf input field ${type.name}.${field.name} cannot have a default value.`,
      field.astNode
    );
  }
}
function createInputObjectCircularRefsValidator(context2) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context2.reportError(
            `Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`,
            cyclePath.map((fieldObj) => fieldObj.astNode)
          );
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type, iface) {
  const { astNode, extensionASTNodes } = type;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (
      /* c8 ignore next */
      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []
    );
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union, typeName) {
  const { astNode, extensionASTNodes } = union;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (
      /* c8 ignore next */
      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []
    );
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(
    (node) => node.name.value === GraphQLDeprecatedDirective.name
  );
}
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind$1.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind$1.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind$1.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
class TypeInfo {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef$1;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema = this._schema;
    switch (node.kind) {
      case Kind$1.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(
          isCompositeType(namedType) ? namedType : void 0
        );
        break;
      }
      case Kind$1.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind$1.DIRECTIVE:
        this._directive = schema.getDirective(node.name.value);
        break;
      case Kind$1.OPERATION_DEFINITION: {
        const rootType = schema.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind$1.INLINE_FRAGMENT:
      case Kind$1.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind$1.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema, node.type);
        this._inputTypeStack.push(
          isInputType(inputType) ? inputType : void 0
        );
        break;
      }
      case Kind$1.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find(
            (arg) => arg.name === node.name.value
          );
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind$1.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind$1.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(
          inputField ? inputField.defaultValue : void 0
        );
        this._inputTypeStack.push(
          isInputType(inputFieldType) ? inputFieldType : void 0
        );
        break;
      }
      case Kind$1.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind$1.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind$1.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind$1.DIRECTIVE:
        this._directive = null;
        break;
      case Kind$1.OPERATION_DEFINITION:
      case Kind$1.INLINE_FRAGMENT:
      case Kind$1.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind$1.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind$1.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind$1.LIST:
      case Kind$1.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind$1.ENUM:
        this._enumValue = null;
        break;
    }
  }
}
function getFieldDef$1(schema, parentType, fieldNode) {
  const name = fieldNode.name.value;
  if (name === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name];
  }
}
function visitWithTypeInfo(typeInfo, visitor2) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn2 = getEnterLeaveForKind$1(visitor2, node.kind).enter;
      if (fn2) {
        const result = fn2.apply(visitor2, args);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode$2(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn2 = getEnterLeaveForKind$1(visitor2, node.kind).leave;
      let result;
      if (fn2) {
        result = fn2.apply(visitor2, args);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind$1.OPERATION_DEFINITION || node.kind === Kind$1.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind$1.FIELD || node.kind === Kind$1.FRAGMENT_SPREAD || node.kind === Kind$1.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind$1.VARIABLE || node.kind === Kind$1.INT || node.kind === Kind$1.FLOAT || node.kind === Kind$1.STRING || node.kind === Kind$1.BOOLEAN || node.kind === Kind$1.NULL || node.kind === Kind$1.ENUM || node.kind === Kind$1.LIST || node.kind === Kind$1.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind$1.LIST ? node.values.some(isConstValueNode) : node.kind === Kind$1.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind$1.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind$1.NAMED_TYPE || node.kind === Kind$1.LIST_TYPE || node.kind === Kind$1.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind$1.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind$1.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind$1.SCALAR_TYPE_DEFINITION || node.kind === Kind$1.OBJECT_TYPE_DEFINITION || node.kind === Kind$1.INTERFACE_TYPE_DEFINITION || node.kind === Kind$1.UNION_TYPE_DEFINITION || node.kind === Kind$1.ENUM_TYPE_DEFINITION || node.kind === Kind$1.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind$1.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind$1.SCALAR_TYPE_EXTENSION || node.kind === Kind$1.OBJECT_TYPE_EXTENSION || node.kind === Kind$1.INTERFACE_TYPE_EXTENSION || node.kind === Kind$1.UNION_TYPE_EXTENSION || node.kind === Kind$1.ENUM_TYPE_EXTENSION || node.kind === Kind$1.INPUT_OBJECT_TYPE_EXTENSION;
}
function ExecutableDefinitionsRule(context2) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind$1.SCHEMA_DEFINITION || definition.kind === Kind$1.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context2.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}
function FieldsOnCorrectTypeRule(context2) {
  return {
    Field(node) {
      const type = context2.getParentType();
      if (type) {
        const fieldDef = context2.getFieldDef();
        if (!fieldDef) {
          const schema = context2.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context2.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x2) => x2.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
function FragmentsOnCompositeTypesRule(context2) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context2.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print$3(typeCondition);
          context2.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context2.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print$3(node.typeCondition);
        context2.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesRule(context2) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context2),
    Argument(argNode) {
      const argDef = context2.getArgument();
      const fieldDef = context2.getFieldDef();
      const parentType = context2.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context2.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context2) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context2.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind$1.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context2.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}
function KnownDirectivesRule(context2) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context2.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind$1.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context2.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context2.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant$2(false);
  switch (appliedTo.kind) {
    case Kind$1.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind$1.FIELD:
      return DirectiveLocation.FIELD;
    case Kind$1.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind$1.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind$1.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind$1.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind$1.SCHEMA_DEFINITION:
    case Kind$1.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind$1.SCALAR_TYPE_DEFINITION:
    case Kind$1.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind$1.OBJECT_TYPE_DEFINITION:
    case Kind$1.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind$1.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind$1.INTERFACE_TYPE_DEFINITION:
    case Kind$1.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind$1.UNION_TYPE_DEFINITION:
    case Kind$1.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind$1.ENUM_TYPE_DEFINITION:
    case Kind$1.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind$1.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind$1.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind$1.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind$1.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant$2(false);
      return parentNode.kind === Kind$1.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant$2(false, "Unexpected kind: " + inspect$2(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode$1.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode$1.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode$1.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
function KnownFragmentNamesRule(context2) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context2.getFragment(fragmentName);
      if (!fragment) {
        context2.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}
function KnownTypeNamesRule(context2) {
  const schema = context2.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context2.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context2.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
const standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
function LoneAnonymousOperationRule(context2) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind$1.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context2.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function LoneSchemaDefinitionRule(context2) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context2.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context2.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context2.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}
const MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context2) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind$1.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context2.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind$1.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context2.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}
function NoFragmentCyclesRule(context2) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context2.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context2.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s2) => '"' + s2.name.value + '"').join(", ");
        context2.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
function NoUndefinedVariablesRule(context2) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context2.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context2.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
function NoUnusedFragmentsRule(context2) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context2.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context2.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}
function NoUnusedVariablesRule(context2) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context2.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context2.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind$1.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind$1.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind$1.INT:
    case Kind$1.FLOAT:
    case Kind$1.STRING:
    case Kind$1.BOOLEAN:
    case Kind$1.NULL:
    case Kind$1.ENUM:
    case Kind$1.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context2) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context2,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context2.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context2.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context2, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i2 = 0; i2 < fragmentNames.length; i2++) {
      collectConflictsBetweenFieldsAndFragment(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i2]
      );
      for (let j2 = i2 + 1; j2 < fragmentNames.length; j2++) {
        collectConflictsBetweenFragments(
          context2,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i2],
          fragmentNames[j2]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context2, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context2.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context2, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context2.getFragment(fragmentName1);
  const fragment2 = context2.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context2, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context2,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context2,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context2,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context2, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i2 = 0; i2 < fields.length; i2++) {
        for (let j2 = i2 + 1; j2 < fields.length; j2++) {
          const conflict = findConflict(
            context2,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i2],
            fields[j2]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context2, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context2,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context2, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect$2(type1)}" and "${inspect$2(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context2,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue$1(value1) === stringifyValue$1(value2);
  });
}
function stringifyValue$1(value) {
  return print$3(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context2,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context2, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context2.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context2,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context2, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind$1.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind$1.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind$1.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context2.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context2,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
class PairSet {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a3, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a3, b2, areMutuallyExclusive) {
    const [key1, key2] = a3 < b2 ? [a3, b2] : [b2, a3];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
}
function PossibleFragmentSpreadsRule(context2) {
  return {
    InlineFragment(node) {
      const fragType = context2.getType();
      const parentType = context2.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context2.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect$2(parentType);
        const fragTypeStr = inspect$2(fragType);
        context2.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context2, fragName);
      const parentType = context2.getParentType();
      if (fragType && parentType && !doTypesOverlap(context2.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect$2(parentType);
        const fragTypeStr = inspect$2(fragType);
        context2.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context2, name) {
  const frag = context2.getFragment(name);
  if (frag) {
    const type = typeFromAST(context2.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}
function PossibleTypeExtensionsRule(context2) {
  const schema = context2.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context2.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context2.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context2.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
const defKindToExtKind = {
  [Kind$1.SCALAR_TYPE_DEFINITION]: Kind$1.SCALAR_TYPE_EXTENSION,
  [Kind$1.OBJECT_TYPE_DEFINITION]: Kind$1.OBJECT_TYPE_EXTENSION,
  [Kind$1.INTERFACE_TYPE_DEFINITION]: Kind$1.INTERFACE_TYPE_EXTENSION,
  [Kind$1.UNION_TYPE_DEFINITION]: Kind$1.UNION_TYPE_EXTENSION,
  [Kind$1.ENUM_TYPE_DEFINITION]: Kind$1.ENUM_TYPE_EXTENSION,
  [Kind$1.INPUT_OBJECT_TYPE_DEFINITION]: Kind$1.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind$1.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind$1.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind$1.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind$1.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind$1.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind$1.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant$2(false, "Unexpected type: " + inspect$2(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind$1.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind$1.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind$1.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind$1.UNION_TYPE_EXTENSION:
      return "union";
    case Kind$1.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind$1.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant$2(false, "Unexpected kind: " + inspect$2(kind));
  }
}
function ProvidedRequiredArgumentsRule(context2) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context2),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context2.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect$2(argDef.type);
            context2.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context2) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context2.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind$1.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect$2(argDef.type) : print$3(argDef.type);
              context2.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind$1.NON_NULL_TYPE && arg.defaultValue == null;
}
function ScalarLeafsRule(context2) {
  return {
    Field(node) {
      const type = context2.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect$2(type);
            context2.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect$2(type);
          context2.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function printPathArray(path) {
  return path.map(
    (key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key
  ).join("");
}
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function coerceInputValue(inputValue, type, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type, onError, void 0);
}
function defaultOnError(path, invalidValue, error) {
  let errorPrefix = "Invalid value " + inspect$2(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error.message = errorPrefix + ": " + error.message;
  throw error;
}
function coerceInputValueImpl(inputValue, type, onError, path) {
  if (isNonNullType(type)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type.ofType, onError, path);
    }
    onError(
      pathToArray(path),
      inputValue,
      new GraphQLError(
        `Expected non-nullable type "${inspect$2(type)}" not to be null.`
      )
    );
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index2) => {
        const itemPath = addPath(path, index2, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(inputValue)) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}" to be an object.`)
      );
      return;
    }
    const coercedValue = {};
    const fieldDefs = type.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect$2(field.type);
          onError(
            pathToArray(path),
            inputValue,
            new GraphQLError(
              `Field "${field.name}" of required type "${typeStr}" was not provided.`
            )
          );
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(
        fieldValue,
        field.type,
        onError,
        addPath(path, field.name, type.name)
      );
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(
          fieldName,
          Object.keys(type.getFields())
        );
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Field "${fieldName}" is not defined by type "${type.name}".` + didYouMean(suggestions)
          )
        );
      }
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedValue);
      if (keys.length !== 1) {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(
            `Exactly one key must be specified for OneOf type "${type.name}".`
          )
        );
      }
      const key = keys[0];
      const value = coercedValue[key];
      if (value === null) {
        onError(
          pathToArray(path).concat(key),
          value,
          new GraphQLError(`Field "${key}" must be non-null.`)
        );
      }
    }
    return coercedValue;
  }
  if (isLeafType(type)) {
    let parseResult;
    try {
      parseResult = type.parseValue(inputValue);
    } catch (error) {
      if (error instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error);
      } else {
        onError(
          pathToArray(path),
          inputValue,
          new GraphQLError(`Expected type "${type.name}". ` + error.message, {
            originalError: error
          })
        );
      }
      return;
    }
    if (parseResult === void 0) {
      onError(
        pathToArray(path),
        inputValue,
        new GraphQLError(`Expected type "${type.name}".`)
      );
    }
    return parseResult;
  }
  invariant$2(false, "Unexpected input type: " + inspect$2(type));
}
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind$1.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind$1.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind$1.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind$1.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind$1.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant$2(false, "Unexpected input type: " + inspect$2(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind$1.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
function getVariableValues(schema, varDefNodes, inputs, options2) {
  const errors2 = [];
  const maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors;
  try {
    const coerced = coerceVariableValues(
      schema,
      varDefNodes,
      inputs,
      (error) => {
        if (maxErrors != null && errors2.length >= maxErrors) {
          throw new GraphQLError(
            "Too many errors processing variables, error limit reached. Execution aborted."
          );
        }
        errors2.push(error);
      }
    );
    if (errors2.length === 0) {
      return {
        coerced
      };
    }
  } catch (error) {
    errors2.push(error);
  }
  return {
    errors: errors2
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print$3(varDefNode.type);
      onError(
        new GraphQLError(
          `Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`,
          {
            nodes: varDefNode.type
          }
        )
      );
      continue;
    }
    if (!hasOwnProperty$9(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect$2(varType);
        onError(
          new GraphQLError(
            `Variable "$${varName}" of required type "${varTypeStr}" was not provided.`,
            {
              nodes: varDefNode
            }
          )
        );
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect$2(varType);
      onError(
        new GraphQLError(
          `Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`,
          {
            nodes: varDefNode
          }
        )
      );
      continue;
    }
    coercedValues[varName] = coerceInputValue(
      value,
      varType,
      (path, invalidValue, error) => {
        let prefix = `Variable "$${varName}" got invalid value ` + inspect$2(invalidValue);
        if (path.length > 0) {
          prefix += ` at "${varName}${printPathArray(path)}"`;
        }
        onError(
          new GraphQLError(prefix + "; " + error.message, {
            nodes: varDefNode,
            originalError: error
          })
        );
      }
    );
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect$2(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind$1.NULL;
    if (valueNode.kind === Kind$1.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty$9(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect$2(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect$2(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print$3(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty$9(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields$1(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind$1.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind$1.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind$1.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function SingleFieldSubscriptionsRule(context2) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context2.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName2 = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context2.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind$1.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context2.reportError(
              new GraphQLError(
                operationName2 != null ? `Subscription "${operationName2}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context2.reportError(
                new GraphQLError(
                  operationName2 != null ? `Subscription "${operationName2}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}
function UniqueArgumentDefinitionNamesRule(context2) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context2.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}
function UniqueArgumentNamesRule(context2) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context2.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}
function UniqueDirectiveNamesRule(context2) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context2.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context2.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
function UniqueDirectivesPerLocationRule(context2) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context2.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind$1.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind$1.SCHEMA_DEFINITION || node.kind === Kind$1.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context2.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
function UniqueEnumValueNamesRule(context2) {
  const schema = context2.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context2.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context2.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
function UniqueFieldDefinitionNamesRule(context2) {
  const schema = context2.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context2.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context2.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}
function UniqueFragmentNamesRule(context2) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context2.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
function UniqueInputFieldNamesRule(context2) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant$2(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context2.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
function UniqueOperationNamesRule(context2) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName2 = node.name;
      if (operationName2) {
        if (knownOperationNames[operationName2.value]) {
          context2.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName2.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName2.value],
                  operationName2
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName2.value] = operationName2;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
function UniqueOperationTypesRule(context2) {
  const schema = context2.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context2.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context2.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
function UniqueTypeNamesRule(context2) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context2.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context2.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context2.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
function UniqueVariableNamesRule(context2) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context2.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}
function ValuesOfCorrectTypeRule(context2) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type = getNullableType(context2.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context2, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context2.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context2, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect$2(fieldDef.type);
          context2.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(
          context2,
          node,
          type,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context2.getParentInputType());
      const fieldType = context2.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context2.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context2.getInputType();
      if (isNonNullType(type)) {
        context2.reportError(
          new GraphQLError(
            `Expected value of type "${inspect$2(type)}", found ${print$3(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context2, node),
    IntValue: (node) => isValidValueNode(context2, node),
    FloatValue: (node) => isValidValueNode(context2, node),
    StringValue: (node) => isValidValueNode(context2, node),
    BooleanValue: (node) => isValidValueNode(context2, node)
  };
}
function isValidValueNode(context2, node) {
  const locationType = context2.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect$2(locationType);
    context2.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print$3(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect$2(locationType);
      context2.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print$3(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect$2(locationType);
    if (error instanceof GraphQLError) {
      context2.reportError(error);
    } else {
      context2.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print$3(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context2, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context2.reportError(
      new GraphQLError(
        `OneOf Input Object "${type.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind$1.NULL;
  const isVariable2 = (value === null || value === void 0 ? void 0 : value.kind) === Kind$1.VARIABLE;
  if (isNullLiteral) {
    context2.reportError(
      new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable2) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind$1.NON_NULL_TYPE;
    if (isNullableVariable) {
      context2.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}
function VariablesAreInputTypesRule(context2) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context2.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print$3(node.type);
        context2.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}
function VariablesInAllowedPositionRule(context2) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context2.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue: defaultValue2 } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context2.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue2
            )) {
              const varTypeStr = inspect$2(varType);
              const typeStr = inspect$2(type);
              context2.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind$1.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
const recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
const specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
const specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);
class ASTValidationContext {
  constructor(ast2, onError) {
    this._ast = ast2;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error) {
    this._onError(error);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind$1.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set;
      while (set = setsToVisit.pop()) {
        for (const selection of set.selections) {
          if (selection.kind === Kind$1.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}
class SDLValidationContext extends ASTValidationContext {
  constructor(ast2, schema, onError) {
    super(ast2, onError);
    this._schema = schema;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}
class ValidationContext extends ASTValidationContext {
  constructor(schema, ast2, typeInfo, onError) {
    super(ast2, onError);
    this._schema = schema;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit$1(
        node,
        visitWithTypeInfo(typeInfo, {
          VariableDefinition: () => false,
          Variable(variable) {
            newUsages.push({
              node: variable,
              type: typeInfo.getInputType(),
              defaultValue: typeInfo.getDefaultValue()
            });
          }
        })
      );
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}
function validate(schema, documentAST, rules = specifiedRules, options2, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options2 === null || options2 === void 0 ? void 0 : options2.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert$2(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors2 = [];
  const context2 = new ValidationContext(
    schema,
    documentAST,
    typeInfo,
    (error) => {
      if (errors2.length >= maxErrors) {
        errors2.push(
          new GraphQLError(
            "Too many validation errors, error limit reached. Validation aborted."
          )
        );
        throw abortObj;
      }
      errors2.push(error);
    }
  );
  const visitor2 = visitInParallel$1(rules.map((rule) => rule(context2)));
  try {
    visit$1(documentAST, visitWithTypeInfo(typeInfo, visitor2));
  } catch (e2) {
    if (e2 !== abortObj) {
      throw e2;
    }
  }
  return errors2;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules) {
  const errors2 = [];
  const context2 = new SDLValidationContext(
    documentAST,
    schemaToExtend,
    (error) => {
      errors2.push(error);
    }
  );
  const visitors = rules.map((rule) => rule(context2));
  visit$1(documentAST, visitInParallel$1(visitors));
  return errors2;
}
function assertValidSDL(documentAST) {
  const errors2 = validateSDL(documentAST);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error) => error.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors2 = validateSDL(documentAST, schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error) => error.message).join("\n\n"));
  }
}
function memoize3(fn2) {
  let cache0;
  return function memoized(a1, a22, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a22);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a22, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn2(a1, a22, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i2, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i2];
    }
    return resolvedObject;
  });
}
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect$2(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, {
    nodes: (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes,
    source: originalError.source,
    positions: originalError.positions,
    path,
    originalError
  });
}
function isLocatedGraphQLError(error) {
  return Array.isArray(error.path);
}
const collectSubfields = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields$1(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);
function execute$1(args) {
  arguments.length < 2 || devAssert$2(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const { schema, document: document2, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result = executeOperation(exeContext, operation, rootValue);
    if (isPromise(result)) {
      return result.then(
        (data) => buildResponse(data, exeContext.errors),
        (error) => {
          exeContext.errors.push(error);
          return buildResponse(null, exeContext.errors);
        }
      );
    }
    return buildResponse(result, exeContext.errors);
  } catch (error) {
    exeContext.errors.push(error);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result = execute$1(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function buildResponse(data, errors2) {
  return errors2.length === 0 ? {
    data
  } : {
    errors: errors2,
    data
  };
}
function assertValidExecutionArguments(schema, document2, rawVariableValues) {
  document2 || devAssert$2(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert$2(
    false,
    "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
  );
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case Kind$1.OPERATION_DEFINITION:
        if (operationName2 == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError(
                "Must provide operation name if query contains multiple operations."
              )
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName2) {
          operation = definition;
        }
        break;
      case Kind$1.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
    }
  }
  if (!operation) {
    if (operationName2 != null) {
      return [new GraphQLError(`Unknown operation named "${operationName2}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(
    schema,
    variableDefinitions,
    rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {},
    {
      maxErrors: 50
    }
  );
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(
      `Schema is not configured to execute ${operation.operation} operation.`,
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    rootType,
    operation.selectionSet
  );
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode$1.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode$1.MUTATION:
      return executeFieldsSerially(
        exeContext,
        rootType,
        rootValue,
        path,
        rootFields
      );
    case OperationTypeNode$1.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(
    fields.entries(),
    (results, [responseName, fieldNodes]) => {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result === void 0) {
        return results;
      }
      if (isPromise(result)) {
        return result.then((resolvedResult) => {
          results[responseName] = resolvedResult;
          return results;
        });
      }
      results[responseName] = result;
      return results;
    },
    /* @__PURE__ */ Object.create(null)
  );
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  try {
    for (const [responseName, fieldNodes] of fields.entries()) {
      const fieldPath = addPath(path, responseName, parentType.name);
      const result = executeField(
        exeContext,
        parentType,
        sourceValue,
        fieldNodes,
        fieldPath
      );
      if (result !== void 0) {
        results[responseName] = result;
        if (isPromise(result)) {
          containsPromise = true;
        }
      }
    }
  } catch (error) {
    if (containsPromise) {
      return promiseForObject(results).finally(() => {
        throw error;
      });
    }
    throw error;
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    parentType,
    path
  );
  try {
    const args = getArgumentValues(
      fieldDef,
      fieldNodes[0],
      exeContext.variableValues
    );
    const contextValue = exeContext.contextValue;
    const result = resolveFn(source, args, contextValue, info);
    let completed;
    if (isPromise(result)) {
      completed = result.then(
        (resolved) => completeValue(exeContext, returnType, fieldNodes, info, path, resolved)
      );
    } else {
      completed = completeValue(
        exeContext,
        returnType,
        fieldNodes,
        info,
        path,
        result
      );
    }
    if (isPromise(completed)) {
      return completed.then(void 0, (rawError) => {
        const error = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error;
  }
  exeContext.errors.push(error);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(
      exeContext,
      returnType.ofType,
      fieldNodes,
      info,
      path,
      result
    );
    if (completed === null) {
      throw new Error(
        `Cannot return null for non-nullable field ${info.parentType.name}.${info.fieldName}.`
      );
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(
      exeContext,
      returnType,
      fieldNodes,
      info,
      path,
      result
    );
  }
  invariant$2(
    false,
    "Cannot complete value of unexpected output type: " + inspect$2(returnType)
  );
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (!isIterableObject(result)) {
    throw new GraphQLError(
      `Expected Iterable, but did not find one for field "${info.parentType.name}.${info.fieldName}".`
    );
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result, (item, index2) => {
    const itemPath = addPath(path, index2, void 0);
    try {
      let completedItem;
      if (isPromise(item)) {
        completedItem = item.then(
          (resolved) => completeValue(
            exeContext,
            itemType,
            fieldNodes,
            info,
            itemPath,
            resolved
          )
        );
      } else {
        completedItem = completeValue(
          exeContext,
          itemType,
          fieldNodes,
          info,
          itemPath,
          item
        );
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error = locatedError(
            rawError,
            fieldNodes,
            pathToArray(itemPath)
          );
          return handleFieldError(error, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
  const serializedResult = returnType.serialize(result);
  if (serializedResult == null) {
    throw new Error(
      `Expected \`${inspect$2(returnType)}.serialize(${inspect$2(result)})\` to return non-nullable value, returned: ${inspect$2(serializedResult)}`
    );
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(
      (resolvedRuntimeType) => completeObjectValue(
        exeContext,
        ensureValidRuntimeType(
          resolvedRuntimeType,
          exeContext,
          returnType,
          fieldNodes,
          info,
          result
        ),
        fieldNodes,
        info,
        path,
        result
      )
    );
  }
  return completeObjectValue(
    exeContext,
    ensureValidRuntimeType(
      runtimeType,
      exeContext,
      returnType,
      fieldNodes,
      info,
      result
    ),
    fieldNodes,
    info,
    path,
    result
  );
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
      fieldNodes
    );
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError(
      "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
    );
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info.parentType.name}.${info.fieldName}" with value ${inspect$2(result)}, received "${inspect$2(runtimeTypeName)}".`
    );
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(
      `Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(
      `Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`,
      {
        nodes: fieldNodes
      }
    );
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return executeFields(
          exeContext,
          returnType,
          result,
          path,
          subFieldNodes
        );
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError(
    `Expected value of type "${returnType.name}" but got: ${inspect$2(result)}.`,
    {
      nodes: fieldNodes
    }
  );
}
const defaultTypeResolver = function(value, contextValue, info, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i2 = 0; i2 < possibleTypes.length; i2++) {
    const type = possibleTypes[i2];
    if (type.isTypeOf) {
      const isTypeOfResult = type.isTypeOf(value, contextValue, info);
      if (isPromise(isTypeOfResult)) {
        promisedIsTypeOfResults[i2] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i2 = 0; i2 < isTypeOfResults.length; i2++) {
        if (isTypeOfResults[i2]) {
          return possibleTypes[i2].name;
        }
      }
    });
  }
};
const defaultFieldResolver = function(source, args, contextValue, info) {
  if (isObjectLike(source) || typeof source === "function") {
    const property = source[info.fieldName];
    if (typeof property === "function") {
      return source[info.fieldName](args, contextValue, info);
    }
    return property;
  }
};
function getFieldDef(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
function graphql$2(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result = graphqlImpl(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert$2(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document2;
  try {
    document2 = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document2);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute$1({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName: operationName2,
    fieldResolver,
    typeResolver
  });
}
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
function mapAsyncIterator(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result) {
    if (result.done) {
      return result;
    }
    try {
      return {
        value: await callback(result.value),
        done: false
      };
    } catch (error) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e2) {
        }
      }
      throw error;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error));
      }
      throw error;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function subscribe(args) {
  arguments.length < 2 || devAssert$2(
    false,
    "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
  );
  const resultOrStream = await createSourceEventStream(args);
  if (!isAsyncIterable(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute$1({ ...args, rootValue: payload });
  return mapAsyncIterator(resultOrStream, mapSourceToResponse);
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg && "document" in firstArg) {
    return firstArg;
  }
  return {
    schema: firstArg,
    // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
    document: args[1],
    rootValue: args[2],
    contextValue: args[3],
    variableValues: args[4],
    operationName: args[5],
    subscribeFieldResolver: args[6]
  };
}
async function createSourceEventStream(...rawArgs) {
  const args = toNormalizedArgs(rawArgs);
  const { schema, document: document2, variableValues } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable(eventStream)) {
      throw new Error(
        `Subscription field must return Async Iterable. Received: ${inspect$2(eventStream)}.`
      );
    }
    return eventStream;
  } catch (error) {
    if (error instanceof GraphQLError) {
      return {
        errors: [error]
      };
    }
    throw error;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError(
      "Schema is not configured to execute subscription operation.",
      {
        nodes: operation
      }
    );
  }
  const rootFields = collectFields(
    schema,
    fragments,
    variableValues,
    rootType,
    operation.selectionSet
  );
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(
      `The subscription field "${fieldName}" is not defined.`,
      {
        nodes: fieldNodes
      }
    );
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info = buildResolveInfo(
    exeContext,
    fieldDef,
    fieldNodes,
    rootType,
    path
  );
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error) {
    throw locatedError(error, fieldNodes, pathToArray(path));
  }
}
function NoDeprecatedCustomRule(context2) {
  return {
    Field(node) {
      const fieldDef = context2.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context2.getParentType();
        parentType != null || invariant$2(false);
        context2.reportError(
          new GraphQLError(
            `The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    },
    Argument(node) {
      const argDef = context2.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context2.getDirective();
        if (directiveDef != null) {
          context2.reportError(
            new GraphQLError(
              `Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        } else {
          const parentType = context2.getParentType();
          const fieldDef = context2.getFieldDef();
          parentType != null && fieldDef != null || invariant$2(false);
          context2.reportError(
            new GraphQLError(
              `Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context2.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context2.reportError(
            new GraphQLError(
              `The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context2.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context2.getInputType());
        enumTypeDef != null || invariant$2(false);
        context2.reportError(
          new GraphQLError(
            `The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function NoSchemaIntrospectionCustomRule(context2) {
  return {
    Field(node) {
      const type = getNamedType(context2.getType());
      if (type && isIntrospectionType(type)) {
        context2.reportError(
          new GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getIntrospectionQuery(options2) {
  const optionsWithDefault = {
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false,
    oneOf: false,
    ...options2
  };
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  const oneOf = optionsWithDefault.oneOf ? "isOneOf" : "";
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      ${oneOf}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
function getOperationAST(documentAST, operationName2) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind$1.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName2 == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName2) {
        return definition;
      }
    }
  }
  return operation;
}
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError(
        "Schema does not define the required query root type.",
        {
          nodes: operation
        }
      );
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", {
        nodes: operation
      });
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", {
        nodes: operation
      });
    }
    return subscriptionType;
  }
  throw new GraphQLError(
    "Can only have query, mutation and subscription operations.",
    {
      nodes: operation
    }
  );
}
function introspectionFromSchema(schema, options2) {
  const optionsWithDefaults = {
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true,
    oneOf: true,
    ...options2
  };
  const document2 = parse(getIntrospectionQuery(optionsWithDefaults));
  const result = executeSync({
    schema,
    document: document2
  });
  !result.errors && result.data || invariant$2(false);
  return result.data;
}
function buildClientSchema(introspection, options2) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert$2(
    false,
    `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect$2(
      introspection
    )}.`
  );
  const schemaIntrospection = introspection.__schema;
  const typeMap = keyValMap(
    schemaIntrospection.types,
    (typeIntrospection) => typeIntrospection.name,
    (typeIntrospection) => buildType(typeIntrospection)
  );
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect$2(typeRef)}.`);
    }
    const type = typeMap[typeName];
    if (!type) {
      throw new Error(
        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`
      );
    }
    return type;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type) {
    if (type != null && type.name != null && type.kind != null) {
      switch (type.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type);
        case TypeKind.OBJECT:
          return buildObjectDef(type);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type);
        case TypeKind.UNION:
          return buildUnionDef(type);
        case TypeKind.ENUM:
          return buildEnumDef(type);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type);
      }
    }
    const typeStr = inspect$2(type);
    throw new Error(
      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`
    );
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect$2(implementingIntrospection);
      throw new Error(
        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`
      );
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect$2(unionIntrospection);
      throw new Error(
        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`
      );
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect$2(enumIntrospection);
      throw new Error(
        `Introspection result missing enumValues: ${enumIntrospectionStr}.`
      );
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(
        enumIntrospection.enumValues,
        (valueIntrospection) => valueIntrospection.name,
        (valueIntrospection) => ({
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        })
      )
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect$2(inputObjectIntrospection);
      throw new Error(
        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`
      );
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),
      isOneOf: inputObjectIntrospection.isOneOf
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(
        `Introspection result missing fields: ${inspect$2(typeIntrospection)}.`
      );
    }
    return keyValMap(
      typeIntrospection.fields,
      (fieldIntrospection) => fieldIntrospection.name,
      buildField
    );
  }
  function buildField(fieldIntrospection) {
    const type = getType(fieldIntrospection.type);
    if (!isOutputType(type)) {
      const typeStr = inspect$2(type);
      throw new Error(
        `Introspection must provide output type for fields, but received: ${typeStr}.`
      );
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect$2(fieldIntrospection);
      throw new Error(
        `Introspection result missing field args: ${fieldIntrospectionStr}.`
      );
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(
      inputValueIntrospections,
      (inputValue) => inputValue.name,
      buildInputValue
    );
  }
  function buildInputValue(inputValueIntrospection) {
    const type = getType(inputValueIntrospection.type);
    if (!isInputType(type)) {
      const typeStr = inspect$2(type);
      throw new Error(
        `Introspection must provide input type for arguments, but received: ${typeStr}.`
      );
    }
    const defaultValue2 = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : void 0;
    return {
      description: inputValueIntrospection.description,
      type,
      defaultValue: defaultValue2,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect$2(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive args: ${directiveIntrospectionStr}.`
      );
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect$2(directiveIntrospection);
      throw new Error(
        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`
      );
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
function extendSchema(schema, documentAST, options2) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind$1.DOCUMENT || devAssert$2(false, "Must provide valid Document AST.");
  if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options2);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options2) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind$1.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind$1.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind$1.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name = typeNode.name.value;
    typeMap[name] = (_stdTypeMap$name = stdTypeMap[name]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = {
    // Get the extended root operation types.
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription),
    // Then, incorporate schema definition and all schema extensions.
    ...schemaDef && getOperationTypes([schemaDef]),
    ...getOperationTypes(schemaExtensions)
  };
  return {
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value,
    ...operationTypes,
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  };
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    }
    if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      args: mapValue(config.args, extendArg)
    });
  }
  function extendNamedType(type) {
    if (isIntrospectionType(type) || isSpecifiedScalarType(type)) {
      return type;
    }
    if (isScalarType(type)) {
      return extendScalarType(type);
    }
    if (isObjectType(type)) {
      return extendObjectType(type);
    }
    if (isInterfaceType(type)) {
      return extendInterfaceType(type);
    }
    if (isUnionType(type)) {
      return extendUnionType(type);
    }
    if (isEnumType(type)) {
      return extendEnumType(type);
    }
    if (isInputObjectType(type)) {
      return extendInputObjectType(type);
    }
    invariant$2(false, "Unexpected type: " + inspect$2(type));
  }
  function extendInputObjectType(type) {
    var _typeExtensionsMap$co;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType({
      ...config,
      fields: () => ({
        ...mapValue(config.fields, (field) => ({
          ...field,
          type: replaceType(field.type)
        })),
        ...buildInputFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendEnumType(type) {
    var _typeExtensionsMap$ty;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType({
      ...config,
      values: { ...config.values, ...buildEnumValueMap(extensions) },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendScalarType(type) {
    var _typeExtensionsMap$co2;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType({
      ...config,
      specifiedByURL,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendObjectType(type) {
    var _typeExtensionsMap$co3;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendInterfaceType(type) {
    var _typeExtensionsMap$co4;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType({
      ...config,
      interfaces: () => [
        ...type.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => ({
        ...mapValue(config.fields, extendField),
        ...buildFieldMap(extensions)
      }),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendUnionType(type) {
    var _typeExtensionsMap$co5;
    const config = type.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType({
      ...config,
      types: () => [
        ...type.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    });
  }
  function extendField(field) {
    return {
      ...field,
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    };
  }
  function extendArg(arg) {
    return { ...arg, type: replaceType(arg.type) };
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (
        /* c8 ignore next */
        (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : []
      );
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name = node.name.value;
    const type = (_stdTypeMap$name2 = stdTypeMap[name]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name];
    if (type === void 0) {
      throw new Error(`Unknown type: "${name}".`);
    }
    return type;
  }
  function getWrappedType(node) {
    if (node.kind === Kind$1.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind$1.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      // @ts-expect-error
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (
        /* c8 ignore next */
        (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : []
      );
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          // Note: While this could make assertions to get the correctly typed
          // value, that would throw immediately while type system validation
          // with validateSchema() will produce more actionable results.
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = (
      /* c8 ignore next */
      args !== null && args !== void 0 ? args : []
    );
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (
        /* c8 ignore next */
        (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : []
      );
      for (const field of fieldsNodes) {
        var _field$description2;
        const type = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (
        /* c8 ignore next */
        (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : []
      );
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$interfaces$map, _node$interfaces;
        return (
          /* c8 ignore next */
          (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : []
        );
      }
    );
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (node) => {
        var _node$types$map, _node$types;
        return (
          /* c8 ignore next */
          (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : []
        );
      }
    );
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind$1.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind$1.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind$1.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind$1.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind$1.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind$1.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes,
          isOneOf: isOneOf(astNode)
        });
      }
    }
  }
}
const stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function isOneOf(node) {
  return Boolean(getDirectiveValues(GraphQLOneOfDirective, node));
}
function buildASTSchema(documentAST, options2) {
  documentAST != null && documentAST.kind === Kind$1.DOCUMENT || devAssert$2(false, "Must provide valid Document AST.");
  if ((options2 === null || options2 === void 0 ? void 0 : options2.assumeValid) !== true && (options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config = extendSchemaImpl(emptySchemaConfig, documentAST, options2);
  if (config.astNode == null) {
    for (const type of config.types) {
      switch (type.name) {
        case "Query":
          config.query = type;
          break;
        case "Mutation":
          config.mutation = type;
          break;
        case "Subscription":
          config.subscription = type;
          break;
      }
    }
  }
  const directives = [
    ...config.directives,
    // If specified directives were not explicitly declared, add them.
    ...specifiedDirectives.filter(
      (stdDirective) => config.directives.every(
        (directive) => directive.name !== stdDirective.name
      )
    )
  ];
  return new GraphQLSchema({ ...config, directives });
}
function buildSchema(source, options2) {
  const document2 = parse(source, {
    noLocation: options2 === null || options2 === void 0 ? void 0 : options2.noLocation,
    allowLegacyFragmentVariables: options2 === null || options2 === void 0 ? void 0 : options2.allowLegacyFragmentVariables
  });
  return buildASTSchema(document2, {
    assumeValidSDL: options2 === null || options2 === void 0 ? void 0 : options2.assumeValidSDL,
    assumeValid: options2 === null || options2 === void 0 ? void 0 : options2.assumeValid
  });
}
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(
    sortByName(schemaConfig.types),
    (type) => type.name,
    sortNamedType
  );
  return new GraphQLSchema({
    ...schemaConfig,
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  });
  function replaceType(type) {
    if (isListType(type)) {
      return new GraphQLList(replaceType(type.ofType));
    } else if (isNonNullType(type)) {
      return new GraphQLNonNull(replaceType(type.ofType));
    }
    return replaceNamedType(type);
  }
  function replaceNamedType(type) {
    return typeMap[type.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config = directive.toConfig();
    return new GraphQLDirective({
      ...config,
      locations: sortBy(config.locations, (x2) => x2),
      args: sortArgs(config.args)
    });
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => ({ ...arg, type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => ({
      ...field,
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type) {
    if (isScalarType(type) || isIntrospectionType(type)) {
      return type;
    }
    if (isObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLObjectType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isInterfaceType(type)) {
      const config = type.toConfig();
      return new GraphQLInterfaceType({
        ...config,
        interfaces: () => sortTypes(config.interfaces),
        fields: () => sortFields2(config.fields)
      });
    }
    if (isUnionType(type)) {
      const config = type.toConfig();
      return new GraphQLUnionType({
        ...config,
        types: () => sortTypes(config.types)
      });
    }
    if (isEnumType(type)) {
      const config = type.toConfig();
      return new GraphQLEnumType({
        ...config,
        values: sortObjMap(config.values, (value) => value)
      });
    }
    if (isInputObjectType(type)) {
      const config = type.toConfig();
      return new GraphQLInputObjectType({
        ...config,
        fields: () => sortInputFields(config.fields)
      });
    }
    invariant$2(false, "Unexpected type: " + inspect$2(type));
  }
}
function sortObjMap(map, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
function printSchema(schema) {
  return printFilteredSchema(
    schema,
    (n2) => !isSpecifiedDirective(n2),
    isDefinedType
  );
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type) {
  return !isSpecifiedScalarType(type) && !isIntrospectionType(type);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type) => printType(type))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type) {
  if (isScalarType(type)) {
    return printScalar(type);
  }
  if (isObjectType(type)) {
    return printObject(type);
  }
  if (isInterfaceType(type)) {
    return printInterface(type);
  }
  if (isUnionType(type)) {
    return printUnion(type);
  }
  if (isEnumType(type)) {
    return printEnum(type);
  }
  if (isInputObjectType(type)) {
    return printInputObject(type);
  }
  invariant$2(false, "Unexpected type: " + inspect$2(type));
}
function printScalar(type) {
  return printDescription(type) + `scalar ${type.name}` + printSpecifiedByURL(type);
}
function printImplementedInterfaces(type) {
  const interfaces = type.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i2) => i2.name).join(" & ") : "";
}
function printObject(type) {
  return printDescription(type) + `type ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printInterface(type) {
  return printDescription(type) + `interface ${type.name}` + printImplementedInterfaces(type) + printFields(type);
}
function printUnion(type) {
  const types = type.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type) + "union " + type.name + possibleTypes;
}
function printEnum(type) {
  const values = type.getValues().map(
    (value, i2) => printDescription(value, "  ", !i2) + "  " + value.name + printDeprecated(value.deprecationReason)
  );
  return printDescription(type) + `enum ${type.name}` + printBlock(values);
}
function printInputObject(type) {
  const fields = Object.values(type.getFields()).map(
    (f3, i2) => printDescription(f3, "  ", !i2) + "  " + printInputValue(f3)
  );
  return printDescription(type) + `input ${type.name}` + (type.isOneOf ? " @oneOf" : "") + printBlock(fields);
}
function printFields(type) {
  const fields = Object.values(type.getFields()).map(
    (f3, i2) => printDescription(f3, "  ", !i2) + "  " + f3.name + printArgs(f3.args, "  ") + ": " + String(f3.type) + printDeprecated(f3.deprecationReason)
  );
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(
    (arg, i2) => printDescription(arg, "  " + indentation, !i2) + "  " + indentation + printInputValue(arg)
  ).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print$3(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print$3({
      kind: Kind$1.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print$3({
    kind: Kind$1.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString2 = print$3({
    kind: Kind$1.STRING,
    value: description,
    block: isPrintableAsBlockString$1(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString2.replace(/\n/g, "\n" + indentation) + "\n";
}
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind$1.DOCUMENT,
    definitions
  };
}
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind$1.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind$1.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(
          definitionNode.selectionSet
        );
        break;
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName2 = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName2] = {
      kind: Kind$1.DOCUMENT,
      definitions: documentAST.definitions.filter(
        (node) => node === operation || node.kind === Kind$1.FRAGMENT_DEFINITION && dependencies.has(node.name.value)
      )
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit$1(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString$1(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
function assertValidName(name) {
  const error = isValidNameError(name);
  if (error) {
    throw error;
  }
  return name;
}
function isValidNameError(name) {
  typeof name === "string" || devAssert$2(false, "Expected name to be a string.");
  if (name.startsWith("__")) {
    return new GraphQLError(
      `Name "${name}" must not begin with "__", which is reserved by GraphQL introspection.`
    );
  }
  try {
    assertName(name);
  } catch (error) {
    return error;
  }
}
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in BreakingChangeType
  );
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter(
    (change) => change.type in DangerousChangeType
  );
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(
    oldSchema.getDirectives(),
    newSchema.getDirectives()
  );
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location2 of oldDirective.locations) {
      if (!newDirective.locations.includes(location2)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location2} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(
    Object.values(oldSchema.getTypeMap()),
    Object.values(newSchema.getTypeMap())
  );
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(
        ...findFieldChanges(oldType, newType),
        ...findImplementedInterfacesChanges(oldType, newType)
      );
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(
    Object.values(oldType.getFields()),
    Object.values(newType.getFields())
  );
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(
      oldField.type,
      newField.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(
      oldArg.type,
      newArg.type
    );
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return (
      // if they're both lists, make sure the underlying types are compatible
      isListType(newType) && isChangeSafeForObjectOrInterfaceField(
        oldType.ofType,
        newType.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
    );
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return (
    // if they're both named types, see if their names are equivalent
    isNamedType(newType) && oldType.name === newType.name || // moving from nullable to non-null of the same underlying type is safe
    isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType)
  );
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return (
      // if they're both non-null, make sure the underlying types are
      // compatible
      isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(
        oldType.ofType,
        newType.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType)
    );
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type) {
  if (isScalarType(type)) {
    return "a Scalar type";
  }
  if (isObjectType(type)) {
    return "an Object type";
  }
  if (isInterfaceType(type)) {
    return "an Interface type";
  }
  if (isUnionType(type)) {
    return "a Union type";
  }
  if (isEnumType(type)) {
    return "an Enum type";
  }
  if (isInputObjectType(type)) {
    return "an Input type";
  }
  invariant$2(false, "Unexpected type: " + inspect$2(type));
}
function stringifyValue(value, type) {
  const ast2 = astFromValue(value, type);
  ast2 != null || invariant$2(false);
  return print$3(sortValueNode(ast2));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name }) => name);
  const newMap = keyMap(newArray, ({ name }) => name);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
const graphql$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BREAK: BREAK$1,
  get BreakingChangeType() {
    return BreakingChangeType;
  },
  DEFAULT_DEPRECATION_REASON,
  get DangerousChangeType() {
    return DangerousChangeType;
  },
  get DirectiveLocation() {
    return DirectiveLocation;
  },
  ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule,
  GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT,
  GraphQLBoolean,
  GraphQLDeprecatedDirective,
  GraphQLDirective,
  GraphQLEnumType,
  GraphQLError,
  GraphQLFloat,
  GraphQLID,
  GraphQLIncludeDirective,
  GraphQLInputObjectType,
  GraphQLInt,
  GraphQLInterfaceType,
  GraphQLList,
  GraphQLNonNull,
  GraphQLObjectType,
  GraphQLOneOfDirective,
  GraphQLScalarType,
  GraphQLSchema,
  GraphQLSkipDirective,
  GraphQLSpecifiedByDirective,
  GraphQLString,
  GraphQLUnionType,
  get Kind() {
    return Kind$1;
  },
  KnownArgumentNamesRule,
  KnownDirectivesRule,
  KnownFragmentNamesRule,
  KnownTypeNamesRule,
  Lexer,
  Location: Location$1,
  LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule,
  MaxIntrospectionDepthRule,
  NoDeprecatedCustomRule,
  NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule,
  NoUnusedFragmentsRule,
  NoUnusedVariablesRule,
  get OperationTypeNode() {
    return OperationTypeNode$1;
  },
  OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule,
  ScalarLeafsRule,
  SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule,
  Source,
  Token: Token$1,
  get TokenKind() {
    return TokenKind;
  },
  TypeInfo,
  get TypeKind() {
    return TypeKind;
  },
  TypeMetaFieldDef,
  TypeNameMetaFieldDef,
  UniqueArgumentDefinitionNamesRule,
  UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule,
  UniqueOperationNamesRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueVariableNamesRule,
  ValidationContext,
  ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule,
  __Directive,
  __DirectiveLocation,
  __EnumValue,
  __Field,
  __InputValue,
  __Schema,
  __Type,
  __TypeKind,
  assertAbstractType,
  assertCompositeType,
  assertDirective,
  assertEnumType,
  assertEnumValueName,
  assertInputObjectType,
  assertInputType,
  assertInterfaceType,
  assertLeafType,
  assertListType,
  assertName,
  assertNamedType,
  assertNonNullType,
  assertNullableType,
  assertObjectType,
  assertOutputType,
  assertScalarType,
  assertSchema,
  assertType,
  assertUnionType,
  assertValidName,
  assertValidSchema,
  assertWrappingType,
  astFromValue,
  buildASTSchema,
  buildClientSchema,
  buildSchema,
  coerceInputValue,
  concatAST,
  createSourceEventStream,
  defaultFieldResolver,
  defaultTypeResolver,
  doTypesOverlap,
  execute: execute$1,
  executeSync,
  extendSchema,
  findBreakingChanges,
  findDangerousChanges,
  formatError,
  getArgumentValues,
  getDirectiveValues,
  getEnterLeaveForKind: getEnterLeaveForKind$1,
  getIntrospectionQuery,
  getLocation,
  getNamedType,
  getNullableType,
  getOperationAST,
  getOperationRootType,
  getVariableValues,
  getVisitFn: getVisitFn$1,
  graphql: graphql$2,
  graphqlSync,
  introspectionFromSchema,
  introspectionTypes,
  isAbstractType,
  isCompositeType,
  isConstValueNode,
  isDefinitionNode,
  isDirective,
  isEnumType,
  isEqualType,
  isExecutableDefinitionNode,
  isInputObjectType,
  isInputType,
  isInterfaceType,
  isIntrospectionType,
  isLeafType,
  isListType,
  isNamedType,
  isNonNullType,
  isNullableType,
  isObjectType,
  isOutputType,
  isRequiredArgument,
  isRequiredInputField,
  isScalarType,
  isSchema,
  isSelectionNode,
  isSpecifiedDirective,
  isSpecifiedScalarType,
  isType,
  isTypeDefinitionNode,
  isTypeExtensionNode,
  isTypeNode,
  isTypeSubTypeOf,
  isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode,
  isUnionType,
  isValidNameError,
  isValueNode,
  isWrappingType,
  lexicographicSortSchema,
  locatedError,
  parse,
  parseConstValue,
  parseType,
  parseValue,
  print: print$3,
  printError,
  printIntrospectionSchema,
  printLocation,
  printSchema,
  printSourceLocation,
  printType,
  recommendedRules,
  resolveObjMapThunk,
  resolveReadonlyArrayThunk,
  responsePathAsArray: pathToArray,
  separateOperations,
  specifiedDirectives,
  specifiedRules,
  specifiedScalarTypes,
  stripIgnoredCharacters,
  subscribe,
  syntaxError,
  typeFromAST,
  validate,
  validateSchema,
  valueFromAST,
  valueFromASTUntyped,
  version,
  versionInfo,
  visit: visit$1,
  visitInParallel: visitInParallel$1,
  visitWithTypeInfo
}, Symbol.toStringTag, { value: "Module" }));
function shouldInclude$1(_a3, variables) {
  var directives = _a3.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives$1(directives).every(function(_a22) {
    var directive = _a22.directive, ifArgument = _a22.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant$3(evaledValue !== void 0, 69, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function getDirectiveNames$1(root2) {
  var names = [];
  visit$1(root2, {
    Directive: function(node) {
      names.push(node.name.value);
    }
  });
  return names;
}
var hasAnyDirectives$1 = function(names, root2) {
  return hasDirectives$1(names, root2, false);
};
var hasAllDirectives$1 = function(names, root2) {
  return hasDirectives$1(names, root2, true);
};
function hasDirectives$1(names, root2, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  visit$1(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK$1;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports$1(document2) {
  return document2 && hasDirectives$1(["client", "export"], document2, true);
}
function isInclusionDirective$1(_a3) {
  var value = _a3.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives$1(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective$1(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant$3(directiveArguments && directiveArguments.length === 1, 70, directiveName);
      var ifArgument = directiveArguments[0];
      invariant$3(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
      var ifValue = ifArgument.value;
      invariant$3(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
const defaultMakeData = () => /* @__PURE__ */ Object.create(null);
const { forEach, slice } = Array.prototype;
const { hasOwnProperty: hasOwnProperty$8 } = Object.prototype;
class Trie {
  constructor(weakness = true, makeData = defaultMakeData) {
    this.weakness = weakness;
    this.makeData = makeData;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(array) {
    let node = this;
    forEach.call(array, (key) => node = node.getChildTrie(key));
    return hasOwnProperty$8.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(array) {
    let node = this;
    for (let i2 = 0, len = array.length; node && i2 < len; ++i2) {
      const map = node.mapFor(array[i2], false);
      node = map && map.get(array[i2]);
    }
    return node && node.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(array) {
    let data;
    if (array.length) {
      const head = array[0];
      const map = this.mapFor(head, false);
      const child = map && map.get(head);
      if (child) {
        data = child.removeArray(slice.call(array, 1));
        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
          map.delete(head);
        }
      }
    } else {
      data = this.data;
      delete this.data;
    }
    return data;
  }
  getChildTrie(key) {
    const map = this.mapFor(key, true);
    let child = map.get(key);
    if (!child)
      map.set(key, child = new Trie(this.weakness, this.makeData));
    return child;
  }
  mapFor(key, create) {
    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
}
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    case "function":
      return true;
  }
  return false;
}
const lib$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Trie
}, Symbol.toStringTag, { value: "Module" }));
var isReactNative$1 = maybe$1(function() {
  return navigator.product;
}) == "ReactNative";
var canUseWeakMap$1 = typeof WeakMap === "function" && !(isReactNative$1 && !global.HermesInternal);
var canUseWeakSet$1 = typeof WeakSet === "function";
var canUseSymbol$1 = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol$1 = canUseSymbol$1 && Symbol.asyncIterator;
var canUseDOM$1 = typeof maybe$1(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM$1 = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  maybe$1(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false
);
var canUseLayoutEffect$1 = (canUseDOM$1 || isReactNative$1) && !usingJSDOM$1;
function isNonNullObject$1(obj) {
  return obj !== null && typeof obj === "object";
}
function isPlainObject$2(obj) {
  return obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);
}
function getFragmentQueryDocument$1(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        73,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant$3(fragments.length === 1, 74, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap$1(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection$1(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant$3(fragment, 75, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
function defaultDispose$1() {
}
class StrongCache {
  constructor(max2 = Infinity, dispose = defaultDispose$1) {
    this.max = max2;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.map.set(key, node);
    return node.value;
  }
  clean() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      if (node === this.newest) {
        this.newest = node.older;
      }
      if (node === this.oldest) {
        this.oldest = node.newer;
      }
      if (node.newer) {
        node.newer.older = node.older;
      }
      if (node.older) {
        node.older.newer = node.newer;
      }
      this.map.delete(key);
      this.dispose(node.value, key);
      return true;
    }
    return false;
  }
}
function noop$2() {
}
const defaultDispose = noop$2;
const _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
  return { deref: () => value };
};
const _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
const _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
  return {
    register: noop$2,
    unregister: noop$2
  };
};
const finalizationBatchSize = 10024;
class WeakCache {
  constructor(max2 = Infinity, dispose = defaultDispose) {
    this.max = max2;
    this.dispose = dispose;
    this.map = new _WeakMap();
    this.newest = null;
    this.oldest = null;
    this.unfinalizedNodes = /* @__PURE__ */ new Set();
    this.finalizationScheduled = false;
    this.size = 0;
    this.finalize = () => {
      const iterator = this.unfinalizedNodes.values();
      for (let i2 = 0; i2 < finalizationBatchSize; i2++) {
        const node = iterator.next().value;
        if (!node)
          break;
        this.unfinalizedNodes.delete(node);
        const key = node.key;
        delete node.key;
        node.keyRef = new _WeakRef(key);
        this.registry.register(key, node, node);
      }
      if (this.unfinalizedNodes.size > 0) {
        queueMicrotask(this.finalize);
      } else {
        this.finalizationScheduled = false;
      }
    };
    this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.scheduleFinalization(node);
    this.map.set(key, node);
    this.size++;
    return node.value;
  }
  clean() {
    while (this.oldest && this.size > this.max) {
      this.deleteNode(this.oldest);
    }
  }
  deleteNode(node) {
    if (node === this.newest) {
      this.newest = node.older;
    }
    if (node === this.oldest) {
      this.oldest = node.newer;
    }
    if (node.newer) {
      node.newer.older = node.older;
    }
    if (node.older) {
      node.older.newer = node.newer;
    }
    this.size--;
    const key = node.key || node.keyRef && node.keyRef.deref();
    this.dispose(node.value, key);
    if (!node.keyRef) {
      this.unfinalizedNodes.delete(node);
    } else {
      this.registry.unregister(node);
    }
    if (key)
      this.map.delete(key);
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      this.deleteNode(node);
      return true;
    }
    return false;
  }
  scheduleFinalization(node) {
    this.unfinalizedNodes.add(node);
    if (!this.finalizationScheduled) {
      this.finalizationScheduled = true;
      queueMicrotask(this.finalize);
    }
  }
}
const lib$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  StrongCache,
  WeakCache
}, Symbol.toStringTag, { value: "Module" }));
var scheduledCleanup$1 = /* @__PURE__ */ new WeakSet();
function schedule$1(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup$1.has(cache2)) {
    scheduledCleanup$1.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup$1.delete(cache2);
    }, 100);
  }
}
var AutoCleanedWeakCache$1 = function(max2, dispose) {
  var cache2 = new WeakCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = WeakCache.prototype.set.call(this, key, value);
    schedule$1(this);
    return ret;
  };
  return cache2;
};
var AutoCleanedStrongCache$1 = function(max2, dispose) {
  var cache2 = new StrongCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = StrongCache.prototype.set.call(this, key, value);
    schedule$1(this);
    return ret;
  };
  return cache2;
};
var cacheSizeSymbol$1 = Symbol.for("apollo.cacheSize");
var cacheSizes$1 = __assign({}, global$1[cacheSizeSymbol$1]);
var globalCaches$1 = {};
function registerGlobalCache$1(name, getSize) {
  globalCaches$1[name] = getSize;
}
var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
function getCurrentCacheSizes() {
  var defaults = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(function(_a3) {
    var k2 = _a3[0], v2 = _a3[1];
    return [
      k2,
      cacheSizes$1[k2] || v2
    ];
  }));
}
function _getApolloClientMemoryInternals() {
  var _a3, _b2, _c2, _d, _e2;
  if (!(globalThis.__DEV__ !== false))
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: __assign({ print: (_a3 = globalCaches$1.print) === null || _a3 === void 0 ? void 0 : _a3.call(globalCaches$1), parser: (_b2 = globalCaches$1.parser) === null || _b2 === void 0 ? void 0 : _b2.call(globalCaches$1), canonicalStringify: (_c2 = globalCaches$1.canonicalStringify) === null || _c2 === void 0 ? void 0 : _c2.call(globalCaches$1), links: linkInfo(this.link), queryManager: {
      getDocumentInfo: this["queryManager"]["transformCache"].size,
      documentTransforms: transformInfo(this["queryManager"].documentTransform)
    } }, (_e2 = (_d = this.cache).getMemoryInternals) === null || _e2 === void 0 ? void 0 : _e2.call(_d))
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  var fragments = this.config.fragments;
  return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
    executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
    executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
    maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
  }, fragmentRegistry: {
    findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
    lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
    transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
  } });
}
function isWrapper(f3) {
  return !!f3 && "dirtyKey" in f3;
}
function getWrapperInformation(f3) {
  return isWrapper(f3) ? f3.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform) {
  return recurseTransformInfo(transform).map(function(cache2) {
    return { cache: cache2 };
  });
}
function recurseTransformInfo(transform) {
  return transform ? __spreadArray(__spreadArray([
    getWrapperInformation(transform === null || transform === void 0 ? void 0 : transform["performWork"])
  ], recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined) : [];
}
function linkInfo(link) {
  var _a3;
  return link ? __spreadArray(__spreadArray([
    (_a3 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a3 === void 0 ? void 0 : _a3.call(link)
  ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
}
var canonicalStringify$1 = Object.assign(function canonicalStringify2(value) {
  return JSON.stringify(value, stableObjectReplacer$1);
}, {
  reset: function() {
    sortingMap$1 = new AutoCleanedStrongCache$1(
      cacheSizes$1.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
if (globalThis.__DEV__ !== false) {
  registerGlobalCache$1("canonicalStringify", function() {
    return sortingMap$1.size;
  });
}
var sortingMap$1;
canonicalStringify$1.reset();
function stableObjectReplacer$1(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder$1))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap$1.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap$1.get(sortedKey) || keys;
        sortingMap$1.set(unsortedKey, sortedKeys);
        sortingMap$1.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder$1(key, i2, keys) {
  return i2 === 0 || keys[i2 - 1] <= key;
}
function makeReference$1(id2) {
  return { __ref: String(id2) };
}
function isReference$1(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode$1(value) {
  return isNonNullObject$1(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue$1(value) {
  return value.kind === "StringValue";
}
function isBooleanValue$1(value) {
  return value.kind === "BooleanValue";
}
function isIntValue$1(value) {
  return value.kind === "IntValue";
}
function isFloatValue$1(value) {
  return value.kind === "FloatValue";
}
function isVariable$1(value) {
  return value.kind === "Variable";
}
function isObjectValue$1(value) {
  return value.kind === "ObjectValue";
}
function isListValue$1(value) {
  return value.kind === "ListValue";
}
function isEnumValue$1(value) {
  return value.kind === "EnumValue";
}
function isNullValue$1(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation$1(argObj, name, value, variables) {
  if (isIntValue$1(value) || isFloatValue$1(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue$1(value) || isStringValue$1(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue$1(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation$1(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable$1(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue$1(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation$1(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue$1(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue$1(value)) {
    argObj[name.value] = null;
  } else {
    throw newInvariantError(84, name.value, value.kind);
  }
}
function storeKeyNameFromField$1(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a3) {
          var name = _a3.name, value = _a3.value;
          return valueToObjectRepresentation$1(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a3) {
      var name = _a3.name, value = _a3.value;
      return valueToObjectRepresentation$1(argObj, name, value, variables);
    });
  }
  return getStoreKeyName$1(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES$1 = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify$1 = canonicalStringify$1;
var getStoreKeyName$1 = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify$1(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = storeKeyNameStringify$1(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES$1.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify$1(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s2) {
    var previous = storeKeyNameStringify$1;
    storeKeyNameStringify$1 = s2;
    return previous;
  }
});
function argumentsObjectFromField$1(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a3) {
      var name = _a3.name, value = _a3.value;
      return valueToObjectRepresentation$1(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField$1(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult$1(result, selectionSet, fragmentMap) {
  var fragments;
  for (var _i2 = 0, _a3 = selectionSet.selections; _i2 < _a3.length; _i2++) {
    var selection = _a3[_i2];
    if (isField$1(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField$1(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  if (fragments) {
    for (var _b2 = 0, fragments_1 = fragments; _b2 < fragments_1.length; _b2++) {
      var selection = fragments_1[_b2];
      var typename = getTypenameFromResult$1(result, getFragmentFromSelection$1(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField$1(selection) {
  return selection.kind === "Field";
}
function isInlineFragment$1(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument$1(doc) {
  invariant$3(doc && doc.kind === "Document", 76);
  var operations = doc.definitions.filter(function(d3) {
    return d3.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(77, definition.kind);
    }
    return definition;
  });
  invariant$3(operations.length <= 1, 78, operations.length);
  return doc;
}
function getOperationDefinition$1(doc) {
  checkDocument$1(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName$1(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions$1(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition$1(doc) {
  var queryDef = getOperationDefinition$1(doc);
  invariant$3(queryDef && queryDef.operation === "query", 79);
  return queryDef;
}
function getFragmentDefinition$1(doc) {
  invariant$3(doc.kind === "Document", 80);
  invariant$3(doc.definitions.length <= 1, 81);
  var fragmentDef = doc.definitions[0];
  invariant$3(fragmentDef.kind === "FragmentDefinition", 82);
  return fragmentDef;
}
function getMainDefinition$1(queryDoc) {
  checkDocument$1(queryDoc);
  var fragmentDefinition;
  for (var _i2 = 0, _a3 = queryDoc.definitions; _i2 < _a3.length; _i2++) {
    var definition = _a3[_i2];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(83);
}
function getDefaultValues$1(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation$1(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
let currentContext = null;
const MISSING_VALUE = {};
let idCounter = 1;
const makeSlotClass = () => class Slot {
  constructor() {
    this.id = [
      "slot",
      idCounter++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let context2 = currentContext; context2; context2 = context2.parent) {
      if (this.id in context2.slots) {
        const value = context2.slots[this.id];
        if (value === MISSING_VALUE)
          break;
        if (context2 !== currentContext) {
          currentContext.slots[this.id] = value;
        }
        return true;
      }
    }
    if (currentContext) {
      currentContext.slots[this.id] = MISSING_VALUE;
    }
    return false;
  }
  getValue() {
    if (this.hasValue()) {
      return currentContext.slots[this.id];
    }
  }
  withValue(value, callback, args, thisArg) {
    const slots = {
      __proto__: null,
      [this.id]: value
    };
    const parent = currentContext;
    currentContext = { parent, slots };
    try {
      return callback.apply(thisArg, args);
    } finally {
      currentContext = parent;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(callback) {
    const context2 = currentContext;
    return function() {
      const saved = currentContext;
      try {
        currentContext = context2;
        return callback.apply(this, arguments);
      } finally {
        currentContext = saved;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(callback, args, thisArg) {
    if (currentContext) {
      const saved = currentContext;
      try {
        currentContext = null;
        return callback.apply(thisArg, args);
      } finally {
        currentContext = saved;
      }
    } else {
      return callback.apply(thisArg, args);
    }
  }
};
function maybe(fn2) {
  try {
    return fn2();
  } catch (ignored) {
  }
}
const globalKey = "@wry/context:Slot";
const host = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  maybe(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  maybe(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
);
const globalHost = host;
const Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[globalKey] || function(Slot2) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot2,
      enumerable: false,
      writable: false,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: true
    });
  } finally {
    return Slot2;
  }
}(makeSlotClass());
const { bind, noContext } = Slot;
function setTimeoutWithContext(callback, delay) {
  return setTimeout(bind(callback), delay);
}
function asyncFromGen(genFn) {
  return function() {
    const gen = genFn.apply(this, arguments);
    const boundNext = bind(gen.next);
    const boundThrow = bind(gen.throw);
    return new Promise((resolve, reject) => {
      function invoke(method, argument) {
        try {
          var result = method.call(gen, argument);
        } catch (error) {
          return reject(error);
        }
        const next = result.done ? resolve : invokeNext;
        if (isPromiseLike$2(result.value)) {
          result.value.then(next, result.done ? reject : invokeThrow);
        } else {
          next(result.value);
        }
      }
      const invokeNext = (value) => invoke(boundNext, value);
      const invokeThrow = (error) => invoke(boundThrow, error);
      invokeNext();
    });
  };
}
function isPromiseLike$2(value) {
  return value && typeof value.then === "function";
}
const parentEntrySlot = new Slot();
function nonReactive(fn2) {
  return parentEntrySlot.withValue(void 0, fn2);
}
const { hasOwnProperty: hasOwnProperty$7 } = Object.prototype;
const arrayFromSet = Array.from || function(set) {
  const array = [];
  set.forEach((item) => array.push(item));
  return array;
};
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}
const emptySetPool = [];
const POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a3, b2) {
  const len = a3.length;
  return (
    // Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b2.length && // The underlying value or exception must be the same.
    a3[len - 1] === b2[len - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
class Entry {
  constructor(fn2) {
    this.fn = fn2;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++Entry.count;
  }
  peek() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(args) {
    assert(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  }
  setDirty() {
    if (this.dirty)
      return;
    this.dirty = true;
    reportDirty(this);
    maybeUnsubscribe(this);
  }
  dispose() {
    this.setDirty();
    forgetChildren(this);
    eachParent(this, (parent, child) => {
      parent.setDirty();
      forgetChild(parent, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  }
  forgetDeps() {
    if (this.deps) {
      arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  }
}
Entry.count = 0;
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a3) {
      }
    }
  } catch (e2) {
    entry.value[1] = e2;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i2 = 0; i2 < parentCount; ++i2) {
      callback(parents[i2], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc2 = parent.dirtyChildren;
  if (dc2) {
    dc2.delete(child);
    if (dc2.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc2);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e2) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}
const EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
  // Fully remove parent Entry from LRU cache and computation graph
};
function dep(options2) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe2 = options2 && options2.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe2 === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe2(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m3 = entryMethodName && hasOwnProperty$7.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m3]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}
let defaultKeyTrie;
function defaultMakeCacheKey(...args) {
  const trie2 = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
  return trie2.lookupArray(args);
}
const caches$1 = /* @__PURE__ */ new Set();
function wrap$1(originalFunction, { max: max2 = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe: subscribe2, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache2 = typeof cacheOption === "function" ? new cacheOption(max2, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache2.get(key);
    if (!entry) {
      cache2.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe2;
      entry.forget = () => cache2.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache2.set(key, entry);
    caches$1.add(cache2);
    if (!parentEntrySlot.hasValue()) {
      caches$1.forEach((cache22) => cache22.clean());
      caches$1.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache2.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max: max2,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe: subscribe2,
    cache: cache2
  });
  function dirtyKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache2.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache2.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}
const lib$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  KeyTrie: Trie,
  Slot,
  asyncFromGen,
  bindContext: bind,
  defaultMakeCacheKey,
  dep,
  noContext,
  nonReactive,
  setTimeout: setTimeoutWithContext,
  wrap: wrap$1
}, Symbol.toStringTag, { value: "Module" }));
function identity$1(document2) {
  return document2;
}
var DocumentTransform$1 = (
  /** @class */
  function() {
    function DocumentTransform2(transform, options2) {
      if (options2 === void 0) {
        options2 = /* @__PURE__ */ Object.create(null);
      }
      this.resultCache = canUseWeakSet$1 ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
      this.transform = transform;
      if (options2.getCacheKey) {
        this.getCacheKey = options2.getCacheKey;
      }
      this.cached = options2.cache !== false;
      this.resetCache();
    }
    DocumentTransform2.prototype.getCacheKey = function(document2) {
      return [document2];
    };
    DocumentTransform2.identity = function() {
      return new DocumentTransform2(identity$1, { cache: false });
    };
    DocumentTransform2.split = function(predicate, left, right) {
      if (right === void 0) {
        right = DocumentTransform2.identity();
      }
      return Object.assign(new DocumentTransform2(
        function(document2) {
          var documentTransform = predicate(document2) ? left : right;
          return documentTransform.transformDocument(document2);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: false }
      ), { left, right });
    };
    DocumentTransform2.prototype.resetCache = function() {
      var _this = this;
      if (this.cached) {
        var stableCacheKeys_1 = new Trie(canUseWeakMap$1);
        this.performWork = wrap$1(DocumentTransform2.prototype.performWork.bind(this), {
          makeCacheKey: function(document2) {
            var cacheKeys = _this.getCacheKey(document2);
            if (cacheKeys) {
              invariant$3(Array.isArray(cacheKeys), 68);
              return stableCacheKeys_1.lookupArray(cacheKeys);
            }
          },
          max: cacheSizes$1["documentTransform.cache"],
          cache: WeakCache
        });
      }
    };
    DocumentTransform2.prototype.performWork = function(document2) {
      checkDocument$1(document2);
      return this.transform(document2);
    };
    DocumentTransform2.prototype.transformDocument = function(document2) {
      if (this.resultCache.has(document2)) {
        return document2;
      }
      var transformedDocument = this.performWork(document2);
      this.resultCache.add(transformedDocument);
      return transformedDocument;
    };
    DocumentTransform2.prototype.concat = function(otherTransform) {
      var _this = this;
      return Object.assign(new DocumentTransform2(
        function(document2) {
          return otherTransform.transformDocument(_this.transformDocument(document2));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: false }
      ), {
        left: this,
        right: otherTransform
      });
    };
    return DocumentTransform2;
  }()
);
var printCache$1;
var print$2 = Object.assign(function(ast2) {
  var result = printCache$1.get(ast2);
  if (!result) {
    result = print$3(ast2);
    printCache$1.set(ast2, result);
  }
  return result;
}, {
  reset: function() {
    printCache$1 = new AutoCleanedWeakCache$1(
      cacheSizes$1.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
print$2.reset();
if (globalThis.__DEV__ !== false) {
  registerGlobalCache$1("print", function() {
    return printCache$1 ? printCache$1.size : 0;
  });
}
var isArray$1 = Array.isArray;
function isNonEmptyArray$1(value) {
  return Array.isArray(value) && value.length > 0;
}
var TYPENAME_FIELD$1 = {
  kind: Kind$1.FIELD,
  name: {
    kind: Kind$1.NAME,
    value: "__typename"
  }
};
function isEmpty$1(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind$1.FRAGMENT_SPREAD && isEmpty$1(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty$1(doc) {
  return isEmpty$1(getOperationDefinition$1(doc) || getFragmentDefinition$1(doc), createFragmentMap$1(getFragmentDefinitions$1(doc))) ? null : doc;
}
function getDirectiveMatcher$1(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach(function(testConfig, test) {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function makeInUseGetterFunction$1(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument$1(directives, doc) {
  checkDocument$1(doc);
  var getInUseByOperationName = makeInUseGetterFunction$1("");
  var getInUseByFragmentName = makeInUseGetterFunction$1("");
  var getInUse = function(ancestors) {
    for (var p3 = 0, ancestor = void 0; p3 < ancestors.length && (ancestor = ancestors[p3]); ++p3) {
      if (isArray$1(ancestor))
        continue;
      if (ancestor.kind === Kind$1.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind$1.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant$3.error(85);
    return null;
  };
  var operationCount = 0;
  for (var i2 = doc.definitions.length - 1; i2 >= 0; --i2) {
    if (doc.definitions[i2].kind === Kind$1.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher$1(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray$1(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
      return config && config.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit$1(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind$1.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind$1.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind$1.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty$1(visit$1(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument$1 = Object.assign(function(doc) {
  return visit$1(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === Kind$1.OPERATION_DEFINITION) {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField$1(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField$1(field) && field.directives && field.directives.some(function(d3) {
          return d3.name.value === "export";
        })) {
          return;
        }
        return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD$1], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD$1;
  }
});
var connectionRemoveConfig$1 = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        globalThis.__DEV__ !== false && invariant$3.warn(86);
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument$1(doc) {
  return removeDirectivesFromDocument$1([connectionRemoveConfig$1], checkDocument$1(doc));
}
function getArgumentMatcher$1(config) {
  return function argumentMatcher(argument) {
    return config.some(function(aConfig) {
      return argument.value && argument.value.kind === Kind$1.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument$1(config, doc) {
  var argMatcher = getArgumentMatcher$1(config);
  return nullIfDocIsEmpty$1(visit$1(doc, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), {
          // Remove matching top level variables definitions.
          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
            return !config.some(function(arg) {
              return arg.name === varDef.variable.name.value;
            });
          }) : []
        });
      }
    },
    Field: {
      enter: function(node) {
        var shouldRemoveField = config.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node.arguments) {
            node.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument$1(config, doc) {
  function enter(node) {
    if (config.some(function(def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty$1(visit$1(doc, {
    FragmentSpread: { enter },
    FragmentDefinition: { enter }
  }));
}
function buildQueryFromSelectionSet$1(document2) {
  var definition = getMainDefinition$1(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit$1(document2, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument$1(document2) {
  checkDocument$1(document2);
  var modifiedDoc = removeDirectivesFromDocument$1([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  return modifiedDoc;
}
function isOperation$1(document2, operation) {
  var _a3;
  return ((_a3 = getOperationDefinition$1(document2)) === null || _a3 === void 0 ? void 0 : _a3.operation) === operation;
}
function isMutationOperation$1(document2) {
  return isOperation$1(document2, "mutation");
}
function isQueryOperation$1(document2) {
  return isOperation$1(document2, "query");
}
function isSubscriptionOperation$1(document2) {
  return isOperation$1(document2, "subscription");
}
var hasOwnProperty$6 = Object.prototype.hasOwnProperty;
function mergeDeep$1() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  return mergeDeepArray$1(sources);
}
function mergeDeepArray$1(sources) {
  var target = sources[0] || {};
  var count2 = sources.length;
  if (count2 > 1) {
    var merger = new DeepMerger$1();
    for (var i2 = 1; i2 < count2; ++i2) {
      target = merger.merge(target, sources[i2]);
    }
  }
  return target;
}
var defaultReconciler$1 = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger$1 = (
  /** @class */
  function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler$1;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject$1;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context2 = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        context2[_i2 - 2] = arguments[_i2];
      }
      if (isNonNullObject$1(source) && isNonNullObject$1(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty$6.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result = _this.reconciler.apply(_this, __spreadArray([
                target,
                source,
                sourceKey
              ], context2, false));
              if (result !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject$1(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }()
);
function concatPagination$1(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    merge: function(existing, incoming) {
      return existing ? __spreadArray(__spreadArray([], existing, true), incoming, true) : incoming;
    }
  };
}
function offsetLimitPagination$1(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    merge: function(existing, incoming, _a3) {
      var args = _a3.args;
      var merged = existing ? existing.slice(0) : [];
      if (incoming) {
        if (args) {
          var _b2 = args.offset, offset2 = _b2 === void 0 ? 0 : _b2;
          for (var i2 = 0; i2 < incoming.length; ++i2) {
            merged[offset2 + i2] = incoming[i2];
          }
        } else {
          merged.push.apply(merged, incoming);
        }
      }
      return merged;
    }
  };
}
function relayStylePagination$1(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    read: function(existing, _a3) {
      var canRead = _a3.canRead, readField = _a3.readField;
      if (!existing)
        return existing;
      var edges = [];
      var firstEdgeCursor = "";
      var lastEdgeCursor = "";
      existing.edges.forEach(function(edge) {
        if (canRead(readField("node", edge))) {
          edges.push(edge);
          if (edge.cursor) {
            firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
            lastEdgeCursor = edge.cursor || lastEdgeCursor;
          }
        }
      });
      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
        firstEdgeCursor = "";
      }
      var _b2 = existing.pageInfo || {}, startCursor = _b2.startCursor, endCursor = _b2.endCursor;
      return __assign(__assign({}, getExtras$1(existing)), { edges, pageInfo: __assign(__assign({}, existing.pageInfo), {
        // If existing.pageInfo.{start,end}Cursor are undefined or "", default
        // to firstEdgeCursor and/or lastEdgeCursor.
        startCursor: startCursor || firstEdgeCursor,
        endCursor: endCursor || lastEdgeCursor
      }) });
    },
    merge: function(existing, incoming, _a3) {
      var args = _a3.args, isReference2 = _a3.isReference, readField = _a3.readField;
      if (!existing) {
        existing = makeEmptyData$1();
      }
      if (!incoming) {
        return existing;
      }
      var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
        if (isReference2(edge = __assign({}, edge))) {
          edge.cursor = readField("cursor", edge);
        }
        return edge;
      }) : [];
      if (incoming.pageInfo) {
        var pageInfo_1 = incoming.pageInfo;
        var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
        var firstEdge = incomingEdges[0];
        var lastEdge = incomingEdges[incomingEdges.length - 1];
        if (firstEdge && startCursor) {
          firstEdge.cursor = startCursor;
        }
        if (lastEdge && endCursor) {
          lastEdge.cursor = endCursor;
        }
        var firstCursor = firstEdge && firstEdge.cursor;
        if (firstCursor && !startCursor) {
          incoming = mergeDeep$1(incoming, {
            pageInfo: {
              startCursor: firstCursor
            }
          });
        }
        var lastCursor = lastEdge && lastEdge.cursor;
        if (lastCursor && !endCursor) {
          incoming = mergeDeep$1(incoming, {
            pageInfo: {
              endCursor: lastCursor
            }
          });
        }
      }
      var prefix = existing.edges;
      var suffix = [];
      if (args && args.after) {
        var index2 = prefix.findIndex(function(edge) {
          return edge.cursor === args.after;
        });
        if (index2 >= 0) {
          prefix = prefix.slice(0, index2 + 1);
        }
      } else if (args && args.before) {
        var index2 = prefix.findIndex(function(edge) {
          return edge.cursor === args.before;
        });
        suffix = index2 < 0 ? prefix : prefix.slice(index2);
        prefix = [];
      } else if (incoming.edges) {
        prefix = [];
      }
      var edges = __spreadArray(__spreadArray(__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
      var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);
      if (incoming.pageInfo) {
        var _b2 = incoming.pageInfo, hasPreviousPage = _b2.hasPreviousPage, hasNextPage = _b2.hasNextPage, startCursor = _b2.startCursor, endCursor = _b2.endCursor, extras2 = __rest(_b2, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
        Object.assign(pageInfo, extras2);
        if (!prefix.length) {
          if (void 0 !== hasPreviousPage)
            pageInfo.hasPreviousPage = hasPreviousPage;
          if (void 0 !== startCursor)
            pageInfo.startCursor = startCursor;
        }
        if (!suffix.length) {
          if (void 0 !== hasNextPage)
            pageInfo.hasNextPage = hasNextPage;
          if (void 0 !== endCursor)
            pageInfo.endCursor = endCursor;
        }
      }
      return __assign(__assign(__assign({}, getExtras$1(existing)), getExtras$1(incoming)), { edges, pageInfo });
    }
  };
}
var getExtras$1 = function(obj) {
  return __rest(obj, notExtras$1);
};
var notExtras$1 = ["edges", "pageInfo"];
function makeEmptyData$1() {
  return {
    edges: [],
    pageInfo: {
      hasPreviousPage: false,
      hasNextPage: true,
      startCursor: "",
      endCursor: ""
    }
  };
}
function _createForOfIteratorHelperLoose(o3, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o3[Symbol.iterator] || o3["@@iterator"];
  if (it2) return (it2 = it2.call(o3)).next.bind(it2);
  if (Array.isArray(o3) || (it2 = _unsupportedIterableToArray(o3)) || allowArrayLike) {
    if (it2) o3 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o3.length) return { done: true };
      return { done: false, value: o3[i2++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o3, minLen) {
  if (!o3) return;
  if (typeof o3 === "string") return _arrayLikeToArray(o3, minLen);
  var n2 = Object.prototype.toString.call(o3).slice(8, -1);
  if (n2 === "Object" && o3.constructor) n2 = o3.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o3);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o3, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
  return hasSymbol(name) ? Symbol[name] : "@@" + name;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null) return void 0;
  if (typeof value !== "function") throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x2) {
  return x2 instanceof Observable;
}
function hostReportError(e2) {
  if (hostReportError.log) {
    hostReportError.log(e2);
  } else {
    setTimeout(function() {
      throw e2;
    });
  }
}
function enqueue(fn2) {
  Promise.resolve().then(function() {
    try {
      fn2();
    } catch (e2) {
      hostReportError(e2);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0) return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e2) {
    hostReportError(e2);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i2 = 0; i2 < queue.length; ++i2) {
    notifySubscription(subscription, queue[i2].type, queue[i2].value);
    if (subscription._state === "closed") break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m3 = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m3) m3.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m3) m3.call(observer, value);
        else throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m3) m3.call(observer);
        break;
    }
  } catch (e2) {
    hostReportError(e2);
  }
  if (subscription._state === "closed") cleanupSubscription(subscription);
  else if (subscription._state === "running") subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed") return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e2) {
      subscriptionObserver.error(e2);
    }
    if (this._state === "initializing") this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2)) throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function") throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe2(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach2(fn2) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn2 !== "function") {
        reject(new TypeError(fn2 + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn2(value, done);
          } catch (e2) {
            reject(e2);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map(fn2) {
    var _this2 = this;
    if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn2(value);
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter(fn2) {
    var _this3 = this;
    if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn2(value)) return;
          } catch (e2) {
            return observer.error(e2);
          }
          observer.next(value);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce(fn2) {
    var _this4 = this;
    if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C2(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue;
          hasValue = true;
          if (!first || hasSeed) {
            try {
              acc = fn2(acc, value);
            } catch (e2) {
              return observer.error(e2);
            }
          } else {
            acc = value;
          }
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          if (!hasValue && !hasSeed) return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat2() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscription;
      var index2 = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v2) {
            observer.next(v2);
          },
          error: function(e2) {
            observer.error(e2);
          },
          complete: function() {
            if (index2 === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C2.from(sources[index2++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn2) {
    var _this6 = this;
    if (typeof fn2 !== "function") throw new TypeError(fn2 + " is not a function");
    var C2 = getSpecies(this);
    return new C2(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn2) {
            try {
              value = fn2(value);
            } catch (e2) {
              return observer.error(e2);
            }
          }
          var inner2 = C2.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e2) {
              observer.error(e2);
            },
            complete: function() {
              var i2 = subscriptions.indexOf(inner2);
              if (i2 >= 0) subscriptions.splice(i2, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner2);
        },
        error: function(e2) {
          observer.error(e2);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0) observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s2) {
          return s2.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from2(x2) {
    var C2 = typeof this === "function" ? this : Observable2;
    if (x2 == null) throw new TypeError(x2 + " is not an object");
    var method = getMethod(x2, SymbolObservable);
    if (method) {
      var observable = method.call(x2);
      if (Object(observable) !== observable) throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C2) return observable;
      return new C2(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x2, SymbolIterator);
      if (method) {
        return new C2(function(observer) {
          enqueue(function() {
            if (observer.closed) return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x2)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed) return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x2)) {
      return new C2(function(observer) {
        enqueue(function() {
          if (observer.closed) return;
          for (var i2 = 0; i2 < x2.length; ++i2) {
            observer.next(x2[i2]);
            if (observer.closed) return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x2 + " is not observable");
  };
  Observable2.of = function of2() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C2 = typeof this === "function" ? this : Observable2;
    return new C2(function(observer) {
      enqueue(function() {
        if (observer.closed) return;
        for (var i2 = 0; i2 < items.length; ++i2) {
          observer.next(items[i2]);
          if (observer.closed) return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}
const module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Observable
}, Symbol.toStringTag, { value: "Module" }));
function symbolObservablePonyfill(root2) {
  var result;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result = Symbol2.observable;
    } else {
      if (typeof Symbol2.for === "function") {
        result = Symbol2.for("https://github.com/benlesh/symbol-observable");
      } else {
        result = Symbol2("https://github.com/benlesh/symbol-observable");
      }
      try {
        Symbol2.observable = result;
      } catch (err) {
      }
    }
  } else {
    result = "@@observable";
  }
  return result;
}
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
symbolObservablePonyfill(root);
var prototype = Observable.prototype;
var fakeObsSymbol = "@@observable";
if (!prototype[fakeObsSymbol]) {
  prototype[fakeObsSymbol] = function() {
    return this;
  };
}
function createFulfilledPromise$1(value) {
  var promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}
function createRejectedPromise$1(reason) {
  var promise = Promise.reject(reason);
  promise.catch(function() {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}
function isStatefulPromise$1(promise) {
  return "status" in promise;
}
function wrapPromiseWithState$1(promise) {
  if (isStatefulPromise$1(promise)) {
    return promise;
  }
  var pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then(function(value) {
    if (pendingPromise.status === "pending") {
      var fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, function(reason) {
    if (pendingPromise.status === "pending") {
      var rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}
var toString$2 = Object.prototype.toString;
function cloneDeep$1(value) {
  return cloneDeepHelper$1(value);
}
function cloneDeepHelper$1(val, seen2) {
  switch (toString$2.call(val)) {
    case "[object Array]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_1 = val.slice(0);
      seen2.set(val, copy_1);
      copy_1.forEach(function(child, i2) {
        copy_1[i2] = cloneDeepHelper$1(child, seen2);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen2.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper$1(val[key], seen2);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze$1(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject$1(obj) && shallowFreeze$1(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject$1(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze$1(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e2) {
      if (e2 instanceof TypeError)
        return null;
      throw e2;
    }
  }
  return obj;
}
function maybeDeepFreeze$1(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze$1(obj);
  }
  return obj;
}
function iterateObserversSafely$1(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap$1(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            return observer.next(result);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
function fixObservableSubclass$1(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol$1 && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
function isPromiseLike$1(value) {
  return value && typeof value.then === "function";
}
var Concast$1 = (
  /** @class */
  function(_super) {
    __extends(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result) {
          if (_this.sub !== null) {
            _this.latest = ["next", result];
            _this.notify("next", result);
            iterateObserversSafely$1(_this.observers, "next", result);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            _this.notify("error", error);
            iterateObserversSafely$1(_this.observers, "error", error);
          }
        },
        complete: function() {
          var _a3 = _this, sub = _a3.sub, _b2 = _a3.sources, sources2 = _b2 === void 0 ? [] : _b2;
          if (sub !== null) {
            var value = sources2.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              _this.notify("complete");
              iterateObserversSafely$1(_this.observers, "complete");
            } else if (isPromiseLike$1(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              }, _this.handlers.error);
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.nextResultListeners = /* @__PURE__ */ new Set();
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.complete();
      };
      _this.promise.catch(function(_2) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike$1(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
      }
    };
    Concast2.prototype.removeObserver = function(observer) {
      if (this.observers.delete(observer) && this.observers.size < 1) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.notify = function(method, arg) {
      var nextResultListeners = this.nextResultListeners;
      if (nextResultListeners.size) {
        this.nextResultListeners = /* @__PURE__ */ new Set();
        nextResultListeners.forEach(function(listener) {
          return listener(method, arg);
        });
      }
    };
    Concast2.prototype.beforeNext = function(callback) {
      var called = false;
      this.nextResultListeners.add(function(method, arg) {
        if (!called) {
          called = true;
          callback(method, arg);
        }
      });
    };
    return Concast2;
  }(Observable)
);
fixObservableSubclass$1(Concast$1);
function isExecutionPatchIncrementalResult$1(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult$1(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult$1(value) {
  return isExecutionPatchIncrementalResult$1(value) || isExecutionPatchInitialResult$1(value);
}
function isApolloPayloadResult$1(value) {
  return isNonNullObject$1(value) && "payload" in value;
}
function mergeIncrementalData$1(prevResult, result) {
  var mergedData = prevResult;
  var merger = new DeepMerger$1();
  if (isExecutionPatchIncrementalResult$1(result) && isNonEmptyArray$1(result.incremental)) {
    result.incremental.forEach(function(_a3) {
      var data = _a3.data, path = _a3.path;
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        var key = path[i2];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}
function graphQLResultHasError$1(result) {
  var errors2 = getGraphQLErrorsFromResult$1(result);
  return isNonEmptyArray$1(errors2);
}
function getGraphQLErrorsFromResult$1(result) {
  var graphQLErrors = isNonEmptyArray$1(result.errors) ? result.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult$1(result) && isNonEmptyArray$1(result.incremental)) {
    result.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}
function compact$1() {
  var objects = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    objects[_i2] = arguments[_i2];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
function mergeOptions$1(defaults, options2) {
  return compact$1(defaults, options2, options2.variables && {
    variables: compact$1(__assign(__assign({}, defaults && defaults.variables), options2.variables))
  });
}
function omitDeep$1(value, key) {
  return __omitDeep$1(value, key);
}
function __omitDeep$1(value, key, known) {
  if (known === void 0) {
    known = /* @__PURE__ */ new Map();
  }
  if (known.has(value)) {
    return known.get(value);
  }
  var modified = false;
  if (Array.isArray(value)) {
    var array_1 = [];
    known.set(value, array_1);
    value.forEach(function(value2, index2) {
      var result = __omitDeep$1(value2, key, known);
      modified || (modified = result !== value2);
      array_1[index2] = result;
    });
    if (modified) {
      return array_1;
    }
  } else if (isPlainObject$2(value)) {
    var obj_1 = Object.create(Object.getPrototypeOf(value));
    known.set(value, obj_1);
    Object.keys(value).forEach(function(k2) {
      if (k2 === key) {
        modified = true;
        return;
      }
      var result = __omitDeep$1(value[k2], key, known);
      modified || (modified = result !== value[k2]);
      obj_1[k2] = result;
    });
    if (modified) {
      return obj_1;
    }
  }
  return value;
}
function stripTypename$1(value) {
  return omitDeep$1(value, "__typename");
}
const utilities$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AutoCleanedStrongCache: AutoCleanedStrongCache$1,
  AutoCleanedWeakCache: AutoCleanedWeakCache$1,
  Concast: Concast$1,
  DEV,
  DeepMerger: DeepMerger$1,
  DocumentTransform: DocumentTransform$1,
  Observable,
  addTypenameToDocument: addTypenameToDocument$1,
  argumentsObjectFromField: argumentsObjectFromField$1,
  asyncMap: asyncMap$1,
  buildQueryFromSelectionSet: buildQueryFromSelectionSet$1,
  cacheSizes: cacheSizes$1,
  canUseAsyncIteratorSymbol: canUseAsyncIteratorSymbol$1,
  canUseDOM: canUseDOM$1,
  canUseLayoutEffect: canUseLayoutEffect$1,
  canUseSymbol: canUseSymbol$1,
  canUseWeakMap: canUseWeakMap$1,
  canUseWeakSet: canUseWeakSet$1,
  canonicalStringify: canonicalStringify$1,
  checkDocument: checkDocument$1,
  cloneDeep: cloneDeep$1,
  compact: compact$1,
  concatPagination: concatPagination$1,
  createFragmentMap: createFragmentMap$1,
  createFulfilledPromise: createFulfilledPromise$1,
  createRejectedPromise: createRejectedPromise$1,
  fixObservableSubclass: fixObservableSubclass$1,
  getDefaultValues: getDefaultValues$1,
  getDirectiveNames: getDirectiveNames$1,
  getFragmentDefinition: getFragmentDefinition$1,
  getFragmentDefinitions: getFragmentDefinitions$1,
  getFragmentFromSelection: getFragmentFromSelection$1,
  getFragmentQueryDocument: getFragmentQueryDocument$1,
  getGraphQLErrorsFromResult: getGraphQLErrorsFromResult$1,
  getInclusionDirectives: getInclusionDirectives$1,
  getMainDefinition: getMainDefinition$1,
  getOperationDefinition: getOperationDefinition$1,
  getOperationName: getOperationName$1,
  getQueryDefinition: getQueryDefinition$1,
  getStoreKeyName: getStoreKeyName$1,
  getTypenameFromResult: getTypenameFromResult$1,
  graphQLResultHasError: graphQLResultHasError$1,
  hasAllDirectives: hasAllDirectives$1,
  hasAnyDirectives: hasAnyDirectives$1,
  hasClientExports: hasClientExports$1,
  hasDirectives: hasDirectives$1,
  isApolloPayloadResult: isApolloPayloadResult$1,
  isArray: isArray$1,
  isDocumentNode: isDocumentNode$1,
  isExecutionPatchIncrementalResult: isExecutionPatchIncrementalResult$1,
  isExecutionPatchInitialResult: isExecutionPatchInitialResult$1,
  isExecutionPatchResult: isExecutionPatchResult$1,
  isField: isField$1,
  isInlineFragment: isInlineFragment$1,
  isMutationOperation: isMutationOperation$1,
  isNonEmptyArray: isNonEmptyArray$1,
  isNonNullObject: isNonNullObject$1,
  isPlainObject: isPlainObject$2,
  isQueryOperation: isQueryOperation$1,
  isReference: isReference$1,
  isStatefulPromise: isStatefulPromise$1,
  isSubscriptionOperation: isSubscriptionOperation$1,
  iterateObserversSafely: iterateObserversSafely$1,
  makeReference: makeReference$1,
  makeUniqueId: makeUniqueId$1,
  maybe: maybe$1,
  maybeDeepFreeze: maybeDeepFreeze$1,
  mergeDeep: mergeDeep$1,
  mergeDeepArray: mergeDeepArray$1,
  mergeIncrementalData: mergeIncrementalData$1,
  mergeOptions: mergeOptions$1,
  offsetLimitPagination: offsetLimitPagination$1,
  omitDeep: omitDeep$1,
  print: print$2,
  relayStylePagination: relayStylePagination$1,
  removeArgumentsFromDocument: removeArgumentsFromDocument$1,
  removeClientSetsFromDocument: removeClientSetsFromDocument$1,
  removeConnectionDirectiveFromDocument: removeConnectionDirectiveFromDocument$1,
  removeDirectivesFromDocument: removeDirectivesFromDocument$1,
  removeFragmentSpreadFromDocument: removeFragmentSpreadFromDocument$1,
  resultKeyNameFromField: resultKeyNameFromField$1,
  shouldInclude: shouldInclude$1,
  storeKeyNameFromField: storeKeyNameFromField$1,
  stringifyForDisplay: stringifyForDisplay$1,
  stripTypename: stripTypename$1,
  valueToObjectRepresentation: valueToObjectRepresentation$1,
  wrapPromiseWithState: wrapPromiseWithState$1
}, Symbol.toStringTag, { value: "Module" }));
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
function toPromise(observable) {
  var completed = false;
  return new Promise(function(resolve, reject) {
    observable.subscribe({
      next: function(data) {
        if (completed) {
          globalThis.__DEV__ !== false && invariant$3.warn(42);
        } else {
          completed = true;
          resolve(data);
        }
      },
      error: reject
    });
  });
}
function fromPromise(promise) {
  return new Observable(function(observer) {
    promise.then(function(value) {
      observer.next(value);
      observer.complete();
    }).catch(observer.error.bind(observer));
  });
}
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i2 = 0, _a3 = Object.keys(operation); _i2 < _a3.length; _i2++) {
    var key = _a3[_i2];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(43, key);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context2 = __assign({}, starting);
  var setContext2 = function(next) {
    if (typeof next === "function") {
      context2 = __assign(__assign({}, context2), next(context2));
    } else {
      context2 = __assign(__assign({}, context2), next);
    }
  };
  var getContext = function() {
    return __assign({}, context2);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext2
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName$1(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function filterOperationVariables(variables, query) {
  var result = __assign({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit$1(query, {
    Variable: function(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach(function(name) {
    delete result[name];
  });
  return result;
}
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createOperation,
  filterOperationVariables,
  fromError,
  fromPromise,
  throwServerError,
  toPromise,
  transformOperation,
  validateOperation
}, Symbol.toStringTag, { value: "Module" }));
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var ApolloLink = (
  /** @class */
  function() {
    function ApolloLink2(request) {
      if (request)
        this.request = request;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links) {
      if (links.length === 0)
        return ApolloLink2.empty();
      return links.map(toLink).reduce(function(x2, y2) {
        return x2.concat(y2);
      });
    };
    ApolloLink2.split = function(test, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      var ret;
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        ret = new ApolloLink2(function(operation) {
          return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
      return Object.assign(ret, { left: leftLink, right: rightLink });
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        globalThis.__DEV__ !== false && invariant$3.warn(35, firstLink);
        return firstLink;
      }
      var nextLink = toLink(second);
      var ret;
      if (isTerminating(nextLink)) {
        ret = new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
      return Object.assign(ret, { left: firstLink, right: nextLink });
    };
    ApolloLink2.prototype.split = function(test, left, right) {
      return this.concat(ApolloLink2.split(test, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next) {
      return ApolloLink2.concat(this, next);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw newInvariantError(36);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn2) {
      this.onError = fn2;
      return this;
    };
    return ApolloLink2;
  }()
);
var empty = ApolloLink.empty;
var from = ApolloLink.from;
var split = ApolloLink.split;
var concat = ApolloLink.concat;
var execute = ApolloLink.execute;
const core$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApolloLink,
  concat,
  empty,
  execute,
  from,
  split
}, Symbol.toStringTag, { value: "Module" }));
function asyncIterator(source) {
  var _a3;
  var iterator = source[Symbol.asyncIterator]();
  return _a3 = {
    next: function() {
      return iterator.next();
    }
  }, _a3[Symbol.asyncIterator] = function() {
    return this;
  }, _a3;
}
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data.length)
        return resolve({ value: data.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol$1) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol$1) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol$1) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol$1 && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result) {
  if (result.extensions) {
    return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var errors2 = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
  if (err.networkError)
    errors2.push(err.networkError);
  return errors2.map(function(err2) {
    return isNonNullObject$1(err2) && err2.message || "Error message not found.";
  }).join("\n");
};
var ApolloError = (
  /** @class */
  function(_super) {
    __extends(ApolloError2, _super);
    function ApolloError2(_a3) {
      var graphQLErrors = _a3.graphQLErrors, protocolErrors = _a3.protocolErrors, clientErrors = _a3.clientErrors, networkError = _a3.networkError, errorMessage = _a3.errorMessage, extraInfo = _a3.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.name = "ApolloError";
      _this.graphQLErrors = graphQLErrors || [];
      _this.protocolErrors = protocolErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.cause = __spreadArray(__spreadArray(__spreadArray([
        networkError
      ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e2) {
        return !!e2;
      }) || null;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error)
);
const errors$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApolloError,
  PROTOCOL_ERRORS_SYMBOL,
  graphQLResultHasProtocolErrors,
  isApolloError
}, Symbol.toStringTag, { value: "Module" }));
var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, nextValue) {
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a3, value, done, chunk, searchFrom, bi2, message, i2, headers, contentType_1, body, result, next;
    var _b2, _c2;
    var _d;
    return __generator(this, function(_e2) {
      switch (_e2.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _e2.label = 1;
        case 1:
          if (!running) return [3, 3];
          return [4, iterator.next()];
        case 2:
          _a3 = _e2.sent(), value = _a3.value, done = _a3.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer.length - boundary.length + 1;
          running = !done;
          buffer += chunk;
          bi2 = buffer.indexOf(boundary, searchFrom);
          while (bi2 > -1) {
            message = void 0;
            _b2 = [
              buffer.slice(0, bi2),
              buffer.slice(bi2 + boundary.length)
            ], message = _b2[0], buffer = _b2[1];
            i2 = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i2));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i2);
            if (body) {
              result = parseJsonBody(response, body);
              if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                if (isApolloPayloadResult$1(result)) {
                  next = {};
                  if ("payload" in result) {
                    if (Object.keys(result).length === 1 && result.payload === null) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    next = __assign({}, result.payload);
                  }
                  if ("errors" in result) {
                    next = __assign(__assign({}, next), { extensions: __assign(__assign({}, "extensions" in next ? next.extensions : null), (_c2 = {}, _c2[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c2)) });
                  }
                  nextValue(next);
                } else {
                  nextValue(result);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi2 = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i2 = line.indexOf(":");
    if (i2 > -1) {
      var name_1 = line.slice(0, i2).trim().toLowerCase();
      var value = line.slice(i2 + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result) {
      if (!Array.isArray(result) && !hasOwnProperty$5.call(result, "data") && !hasOwnProperty$5.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter = function(p3, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p3);
  } catch (e2) {
    var parseError = newInvariantError(39, label, e2.message);
    parseError.parseError = e2;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions$1 = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions$1
};
var defaultPrinter = function(ast2, printer2) {
  return printer2(ast2);
};
function selectHttpOptionsAndBody(operation, fallbackConfig) {
  var configs = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    configs[_i2 - 2] = arguments[_i2];
  }
  configs.unshift(fallbackConfig);
  return selectHttpOptionsAndBodyInternal.apply(void 0, __spreadArray([
    operation,
    defaultPrinter
  ], configs, false));
}
function selectHttpOptionsAndBodyInternal(operation, printer2) {
  var configs = [];
  for (var _i2 = 2; _i2 < arguments.length; _i2++) {
    configs[_i2 - 2] = arguments[_i2];
  }
  var options2 = {};
  var http2 = {};
  configs.forEach(function(config) {
    options2 = __assign(__assign(__assign({}, options2), config.options), { headers: __assign(__assign({}, options2.headers), config.headers) });
    if (config.credentials) {
      options2.credentials = config.credentials;
    }
    http2 = __assign(__assign({}, http2), config.http);
  });
  if (options2.headers) {
    options2.headers = removeDuplicateHeaders(options2.headers, http2.preserveHeaderCase);
  }
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http2.includeExtensions)
    body.extensions = extensions;
  if (http2.includeQuery)
    body.query = printer2(query, print$2);
  return {
    options: options2,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = /* @__PURE__ */ Object.create(null);
    Object.keys(Object(headers)).forEach(function(name) {
      normalizedHeaders_1[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders_1;
  }
  var headerData = /* @__PURE__ */ Object.create(null);
  Object.keys(Object(headers)).forEach(function(name) {
    headerData[name.toLowerCase()] = {
      originalName: name,
      value: headers[name]
    };
  });
  var normalizedHeaders = /* @__PURE__ */ Object.create(null);
  Object.keys(headerData).forEach(function(name) {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw newInvariantError(37);
  }
};
var createSignalIfSupported = function() {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  var controller = new AbortController();
  var signal = controller.signal;
  return { controller, signal };
};
var selectURI = function(operation, fallbackURI) {
  var context2 = operation.getContext();
  var contextURI = context2.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe$1(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a3 = linkOptions.uri, uri = _a3 === void 0 ? "/graphql" : _a3, preferredFetch = linkOptions.fetch, _b2 = linkOptions.print, print2 = _b2 === void 0 ? defaultPrinter : _b2, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c2 = linkOptions.includeUnusedVariables, includeUnusedVariables = _c2 === void 0 ? false : _c2, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (globalThis.__DEV__ !== false) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context2 = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context2.clientAwareness) {
      var _a22 = context2.clientAwareness, name_1 = _a22.name, version2 = _a22.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context2.headers);
    var contextConfig = {
      http: context2.http,
      options: context2.fetchOptions,
      credentials: context2.credentials,
      headers: contextHeaders
    };
    if (hasDirectives$1(["client"], operation.query)) {
      var transformedQuery = removeClientSetsFromDocument$1(operation.query);
      if (!transformedQuery) {
        return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      }
      operation.query = transformedQuery;
    }
    var _b22 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options2 = _b22.options, body = _b22.body;
    if (body.variables && !includeUnusedVariables) {
      body.variables = filterOperationVariables(body.variables, operation.query);
    }
    var controller;
    if (!options2.signal && typeof AbortController !== "undefined") {
      controller = new AbortController();
      options2.signal = controller.signal;
    }
    var definitionIsMutation = function(d3) {
      return d3.kind === "OperationDefinition" && d3.operation === "mutation";
    };
    var definitionIsSubscription = function(d3) {
      return d3.kind === "OperationDefinition" && d3.operation === "subscription";
    };
    var isSubscription2 = definitionIsSubscription(getMainDefinition$1(operation.query));
    var hasDefer = hasDirectives$1(["defer"], operation.query);
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options2.method = "GET";
    }
    if (hasDefer || isSubscription2) {
      options2.headers = options2.headers || {};
      var acceptHeader = "multipart/mixed;";
      if (isSubscription2 && hasDefer) {
        globalThis.__DEV__ !== false && invariant$3.warn(38);
      }
      if (isSubscription2) {
        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
      } else if (hasDefer) {
        acceptHeader += "deferSpec=20220824,application/json";
      }
      options2.headers.accept = acceptHeader;
    }
    if (options2.method === "GET") {
      var _c22 = rewriteURIForGET(chosenURI, body), newURI = _c22.newURI, parseError = _c22.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options2.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe$1(function() {
        return fetch;
      }) || backupFetch;
      var observerNext = observer.next.bind(observer);
      currentFetch(chosenURI, options2).then(function(response) {
        var _a32;
        operation.setContext({ response });
        var ctype = (_a32 = response.headers) === null || _a32 === void 0 ? void 0 : _a32.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observerNext);
        } else {
          return parseAndCheckHttpResponse(operation)(response).then(observerNext);
        }
      }).then(function() {
        controller = void 0;
        observer.complete();
      }).catch(function(err) {
        controller = void 0;
        handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = (
  /** @class */
  function(_super) {
    __extends(HttpLink2, _super);
    function HttpLink2(options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var _this = _super.call(this, createHttpLink(options2).request) || this;
      _this.options = options2;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink)
);
const http = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HttpLink,
  checkFetcher,
  createHttpLink,
  createSignalIfSupported,
  defaultPrinter,
  fallbackHttpConfig,
  parseAndCheckHttpResponse,
  rewriteURIForGET,
  selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter
}, Symbol.toStringTag, { value: "Module" }));
const { toString: toString$1, hasOwnProperty: hasOwnProperty$4 } = Object.prototype;
const fnToStr = Function.prototype.toString;
const previousComparisons = /* @__PURE__ */ new Map();
function equal$2(a3, b2) {
  try {
    return check(a3, b2);
  } finally {
    previousComparisons.clear();
  }
}
function check(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  const aTag = toString$1.call(a3);
  const bTag = toString$1.call(b2);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a3.length !== b2.length)
        return false;
    case "[object Object]": {
      if (previouslyCompared(a3, b2))
        return true;
      const aKeys = definedKeys(a3);
      const bKeys = definedKeys(b2);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k2 = 0; k2 < keyCount; ++k2) {
        if (!hasOwnProperty$4.call(b2, aKeys[k2])) {
          return false;
        }
      }
      for (let k2 = 0; k2 < keyCount; ++k2) {
        const key = aKeys[k2];
        if (!check(a3[key], b2[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a3.name === b2.name && a3.message === b2.message;
    case "[object Number]":
      if (a3 !== a3)
        return b2 !== b2;
    case "[object Boolean]":
    case "[object Date]":
      return +a3 === +b2;
    case "[object RegExp]":
    case "[object String]":
      return a3 == `${b2}`;
    case "[object Map]":
    case "[object Set]": {
      if (a3.size !== b2.size)
        return false;
      if (previouslyCompared(a3, b2))
        return true;
      const aIterator = a3.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b2.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b2.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a3 = new Uint8Array(a3);
      b2 = new Uint8Array(b2);
    case "[object DataView]": {
      let len = a3.byteLength;
      if (len === b2.byteLength) {
        while (len-- && a3[len] === b2[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a3);
      if (aCode !== fnToStr.call(b2)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
const nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a3, b2) {
  let bSet = previousComparisons.get(a3);
  if (bSet) {
    if (bSet.has(b2))
      return true;
  } else {
    previousComparisons.set(a3, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b2);
  return false;
}
const lib$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: equal$2,
  equal: equal$2
}, Symbol.toStringTag, { value: "Module" }));
function equalByQuery(query, _a3, _b2, variables) {
  var aData = _a3.data, aRest = __rest(_a3, ["data"]);
  var bData = _b2.data, bRest = __rest(_b2, ["data"]);
  return equal$2(aRest, bRest) && equalBySelectionSet(getMainDefinition$1(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap$1(getFragmentDefinitions$1(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context2) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude$1(selection, context2.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField$1(selection)) {
      var resultKey = resultKeyNameFromField$1(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return equal$2(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i2 = 0; i2 < length_1; ++i2) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i2], bResultChild[i2], context2)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context2);
    } else {
      var fragment = getFragmentFromSelection$1(selection, context2.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context2
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}
var ApolloCache = (
  /** @class */
  function() {
    function ApolloCache2() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = wrap$1(getFragmentQueryDocument$1, {
        max: cacheSizes$1["cache.fragmentQueryDocuments"] || 1e3,
        cache: WeakCache
      });
    }
    ApolloCache2.prototype.batch = function(options2) {
      var _this = this;
      var optimisticId = typeof options2.optimistic === "string" ? options2.optimistic : options2.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options2.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
      this.performTransaction(transaction, optimisticId);
    };
    ApolloCache2.prototype.transformDocument = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.transformForLink = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.identify = function(object) {
      return;
    };
    ApolloCache2.prototype.gc = function() {
      return [];
    };
    ApolloCache2.prototype.modify = function(options2) {
      return false;
    };
    ApolloCache2.prototype.readQuery = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options2.optimistic;
      }
      return this.read(__assign(__assign({}, options2), { rootId: options2.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache2.prototype.watchFragment = function(options2) {
      var _this = this;
      var fragment = options2.fragment, fragmentName = options2.fragmentName, from2 = options2.from, _a3 = options2.optimistic, optimistic = _a3 === void 0 ? true : _a3, otherOptions = __rest(options2, ["fragment", "fragmentName", "from", "optimistic"]);
      var query = this.getFragmentDoc(fragment, fragmentName);
      var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
      var latestDiff;
      return new Observable(function(observer) {
        return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff2) {
          if (
            // Always ensure we deliver the first result
            latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff2.result })
          ) {
            return;
          }
          var result = {
            data: diff2.result,
            complete: !!diff2.complete
          };
          if (diff2.missing) {
            result.missing = mergeDeepArray$1(diff2.missing.map(function(error) {
              return error.missing;
            }));
          }
          latestDiff = diff2;
          observer.next(result);
        } }));
      });
    };
    ApolloCache2.prototype.readFragment = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options2.optimistic;
      }
      return this.read(__assign(__assign({}, options2), { query: this.getFragmentDoc(options2.fragment, options2.fragmentName), rootId: options2.id, optimistic }));
    };
    ApolloCache2.prototype.writeQuery = function(_a3) {
      var id2 = _a3.id, data = _a3.data, options2 = __rest(_a3, ["id", "data"]);
      return this.write(Object.assign(options2, {
        dataId: id2 || "ROOT_QUERY",
        result: data
      }));
    };
    ApolloCache2.prototype.writeFragment = function(_a3) {
      var id2 = _a3.id, data = _a3.data, fragment = _a3.fragment, fragmentName = _a3.fragmentName, options2 = __rest(_a3, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options2, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id2,
        result: data
      }));
    };
    ApolloCache2.prototype.updateQuery = function(options2, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options2);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeQuery(__assign(__assign({}, options2), { data }));
          return data;
        }
      });
    };
    ApolloCache2.prototype.updateFragment = function(options2, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options2);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeFragment(__assign(__assign({}, options2), { data }));
          return data;
        }
      });
    };
    return ApolloCache2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
}
var Cache;
/* @__PURE__ */ (function(Cache2) {
})(Cache || (Cache = {}));
var MissingFieldError = (
  /** @class */
  function(_super) {
    __extends(MissingFieldError2, _super);
    function MissingFieldError2(message, path, query, variables) {
      var _a3;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i2 = _this.path.length - 1; i2 >= 0; --i2) {
          _this.missing = (_a3 = {}, _a3[_this.path[i2]] = _this.missing, _a3);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError2.prototype;
      return _this;
    }
    return MissingFieldError2;
  }(Error)
);
var hasOwn = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a3, context2) {
  var __typename = _a3.__typename, id2 = _a3.id, _id = _a3._id;
  if (typeof __typename === "string") {
    if (context2) {
      context2.keyObject = !isNullish(id2) ? { id: id2 } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id2) && !isNullish(_id)) {
      id2 = _id;
    }
    if (!isNullish(id2)) {
      return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: false
};
function normalizeConfig(config) {
  return compact$1(defaultConfig, config);
}
function shouldCanonizeResults(config) {
  var value = config.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference$1(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject$1(result)) {
    return isArray$1(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField$1(field) && shouldInclude$1(field, variables)) {
        var key = resultKeyNameFromField$1(field);
        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject$1(value) && !isReference$1(value) && !isArray$1(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger$1();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap$1(getFragmentDefinitions$1(document2));
  return {
    fragmentMap,
    lookupFragment: function(name) {
      var def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = (
  /** @class */
  function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return maybeDeepFreeze$1(isReference$1(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return isReference$1(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return makeReference$1(objOrIdOrRef);
        }
        if (isReference$1(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id2 = _this.policies.identify(objOrIdOrRef)[0];
        if (id2) {
          var ref = makeReference$1(id2);
          if (mergeIntoStore) {
            _this.merge(id2, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return __assign({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (isReference$1(older))
        older = older.__ref;
      if (isReference$1(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      invariant$3(typeof dataId === "string", 1);
      var merged = new DeepMerger$1(storeObjectReconciler).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE,
          INVALIDATE,
          isReference: isReference$1,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || makeReference$1(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze$1(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && invariant$3.warn(2, ref);
                      return true;
                    }
                  };
                  if (isReference$1(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i2 = 0, newValue_1 = newValue; _i2 < newValue_1.length; _i2++) {
                      var value = newValue_1[_i2];
                      if (isReference$1(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id2 = _this.policies.identify(value)[0];
                          if (id2) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && invariant$3.warn(3, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a3;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a3 = {}, _a3[storeFieldName] = delModifier, _a3) : delModifier);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options2, limit) {
      var evicted = false;
      if (options2.id) {
        if (hasOwn.call(this.data, options2.id)) {
          evicted = this.delete(options2.id, options2.fieldName, options2.args);
        }
        if (this instanceof Layer && this !== limit) {
          evicted = this.parent.evict(options2, limit) || evicted;
        }
        if (options2.fieldName || evicted) {
          this.group.dirty(options2.id, options2.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id2) {
        if (!hasOwn.call(_this.policies.rootTypenamesById, id2)) {
          extraRootIds.push(id2);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count2 = --this.rootIds[rootId];
        if (!count2)
          delete this.rootIds[rootId];
        return count2;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot = this.toObject();
      ids.forEach(function(id2) {
        if (hasOwn.call(snapshot, id2)) {
          Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
          delete snapshot[id2];
        }
      });
      var idsToRemove = Object.keys(snapshot);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id2) {
          return root_1.delete(id2);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root2 = this.data[dataId];
        if (!root2)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root2]);
        workSet_1.forEach(function(obj) {
          if (isReference$1(obj)) {
            found_1[obj.__ref] = true;
          }
          if (isNonNullObject$1(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (isNonNullObject$1(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }()
);
var CacheGroup = (
  /** @class */
  function() {
    function CacheGroup2(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup2.prototype.resetCaching = function() {
      this.d = this.caching ? dep() : null;
      this.keyMaker = new Trie(canUseWeakMap$1);
    };
    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey(dataId, storeFieldName),
          // When storeFieldName === "__exists", that means the entity identified
          // by dataId has either disappeared from the cache or was newly added,
          // so the result caching system would do well to "forget everything it
          // knows" about that object. To achieve that kind of invalidation, we
          // not only dirty the associated result cache entry, but also remove it
          // completely from the dependency graph. For the optimism implementation
          // details, see https://github.com/benjamn/optimism/pull/195.
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup2;
  }()
);
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root = (
    /** @class */
    function(_super) {
      __extends(Root2, _super);
      function Root2(_a3) {
        var policies = _a3.policies, _b2 = _a3.resultCaching, resultCaching = _b2 === void 0 ? true : _b2, seed = _a3.seed;
        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
        _this.stump = new Stump(_this);
        _this.storageTrie = new Trie(canUseWeakMap$1);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root2.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root2.prototype.removeLayer = function() {
        return this;
      };
      Root2.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root2;
    }(EntityStore2)
  );
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = (
  /** @class */
  function(_super) {
    __extends(Layer2, _super);
    function Layer2(id2, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id2;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer2.prototype.addLayer = function(layerId, replay) {
      return new Layer2(layerId, this, replay, this.group);
    };
    Layer2.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal$2(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer2.prototype.toObject = function() {
      return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer2.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer2.prototype.getStorage = function() {
      var p3 = this.parent;
      while (p3.parent)
        p3 = p3.parent;
      return p3.getStorage.apply(
        p3,
        // @ts-expect-error
        arguments
      );
    };
    return Layer2;
  }(EntityStore)
);
var Stump = (
  /** @class */
  function(_super) {
    __extends(Stump2, _super);
    function Stump2(root2) {
      return _super.call(this, "EntityStore.Stump", root2, function() {
      }, new CacheGroup(root2.group.caching, root2.group)) || this;
    }
    Stump2.prototype.removeLayer = function() {
      return this;
    };
    Stump2.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump2;
  }(Layer)
);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal$2(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject$1(value)) {
    return isArray$1(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = (
  /** @class */
  function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet$1 ? WeakSet : Set)();
      this.pool = new Trie(canUseWeakMap$1);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject$1(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject$1(value)) {
        var copy = shallowCopy(value);
        this.passes.set(copy, value);
        return copy;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject$1(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i2) {
                obj_1[key] = array_1[firstValueIndex_1 + i2];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon2;
  }()
);
function execSelectionSetKeyArgs(options2) {
  return [
    options2.selectionSet,
    options2.objectOrReference,
    options2.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options2.context.canonizeResults
  ];
}
var StoreReader = (
  /** @class */
  function() {
    function StoreReader2(config) {
      var _this = this;
      this.knownResults = new (canUseWeakMap$1 ? WeakMap : Map)();
      this.config = compact$1(config, {
        addTypename: config.addTypename !== false,
        canonizeResults: shouldCanonizeResults(config)
      });
      this.canon = config.canon || new ObjectCanon();
      this.executeSelectionSet = wrap$1(function(options2) {
        var _a3;
        var canonizeResults = options2.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs(options2);
        peekArgs[3] = !canonizeResults;
        var other = (_a3 = _this.executeSelectionSet).peek.apply(_a3, peekArgs);
        if (other) {
          if (canonizeResults) {
            return __assign(__assign({}, other), {
              // If we previously read this result without canonizing it, we can
              // reuse that result simply by canonizing it now.
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options2);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes$1["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: execSelectionSetKeyArgs,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
          if (supportsResultCaching(context2.store)) {
            return context2.store.makeCacheKey(selectionSet, isReference$1(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = wrap$1(function(options2) {
        maybeDependOnExistenceOfEntity(options2.context.store, options2.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options2);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes$1["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(_a3) {
          var field = _a3.field, array = _a3.array, context2 = _a3.context;
          if (supportsResultCaching(context2.store)) {
            return context2.store.makeCacheKey(field, array, context2.varString);
          }
        }
      });
    }
    StoreReader2.prototype.resetCanon = function() {
      this.canon = new ObjectCanon();
    };
    StoreReader2.prototype.diffQueryAgainstStore = function(_a3) {
      var store = _a3.store, query = _a3.query, _b2 = _a3.rootId, rootId = _b2 === void 0 ? "ROOT_QUERY" : _b2, variables = _a3.variables, _c2 = _a3.returnPartialData, returnPartialData = _c2 === void 0 ? true : _c2, _d = _a3.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = __assign(__assign({}, getDefaultValues$1(getQueryDefinition$1(query))), variables);
      var rootRef = makeReference$1(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: getMainDefinition$1(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: __assign({ store, query, policies, variables, varString: canonicalStringify$1(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context2) {
      if (supportsResultCaching(context2.store) && this.knownResults.get(result) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context2,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(result)
        );
        if (latest && result === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader2.prototype.execSelectionSetImpl = function(_a3) {
      var _this = this;
      var selectionSet = _a3.selectionSet, objectOrReference = _a3.objectOrReference, enclosingRef = _a3.enclosingRef, context2 = _a3.context;
      if (isReference$1(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context2.variables, policies = context2.policies, store = context2.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new DeepMerger$1();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result2, resultName) {
        var _a22;
        if (result2.missing) {
          missing = missingMerger.merge(missing, (_a22 = {}, _a22[resultName] = result2.missing, _a22));
        }
        return result2.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a22, _b2;
        if (!shouldInclude$1(selection, variables))
          return;
        if (isField$1(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context2.variables,
            from: objectOrReference
          }, context2);
          var resultName = resultKeyNameFromField$1(selection);
          if (fieldValue === void 0) {
            if (!addTypenameToDocument$1.added(selection)) {
              missing = missingMerger.merge(missing, (_a22 = {}, _a22[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference$1(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a22));
            }
          } else if (isArray$1(fieldValue)) {
            if (fieldValue.length > 0) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context: context2
              }), resultName);
            }
          } else if (!selection.selectionSet) {
            if (context2.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: isReference$1(fieldValue) ? fieldValue : enclosingRef,
              context: context2
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b2 = {}, _b2[resultName] = fieldValue, _b2));
          }
        } else {
          var fragment = getFragmentFromSelection$1(selection, context2.lookupFragment);
          if (!fragment && selection.kind === Kind$1.FRAGMENT_SPREAD) {
            throw newInvariantError(9, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result = mergeDeepArray$1(objectsToMerge);
      var finalResult = { result, missing };
      var frozen = context2.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze$1(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a3) {
      var _this = this;
      var field = _a3.field, array = _a3.array, enclosingRef = _a3.enclosingRef, context2 = _a3.context;
      var missing;
      var missingMerger = new DeepMerger$1();
      function handleMissing(childResult, i2) {
        var _a22;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a22 = {}, _a22[i2] = childResult.missing, _a22));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context2.store.canRead);
      }
      array = array.map(function(item, i2) {
        if (item === null) {
          return null;
        }
        if (isArray$1(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context: context2
          }), i2);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: isReference$1(item) ? item : enclosingRef,
            context: context2
          }), i2);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue(context2.store, field, item);
        }
        return item;
      });
      return {
        result: context2.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader2;
  }()
);
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_2, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject$1(value)) {
        invariant$3(
          !isReference$1(value),
          10,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches2 = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach(function(cache22) {
          getCacheInfo(cache22).dep.dirty(rv);
          broadcast(cache22);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches2.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches2.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context2) {
    var extract = function(from2, key) {
      return context2.readField(key, from2);
    };
    var keyObject = context2.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context2.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context2.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant$3(extracted !== void 0, 4, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context2.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a3) {
    var field = _a3.field, variables = _a3.variables, fieldName = _a3.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray$1(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d3 = field.directives.find(function(d22) {
            return d22.name.value === directiveName_1;
          });
          var directiveArgs = d3 && argumentsObjectFromField$1(d3, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger$1();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a3;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        toMerge = (_a3 = {}, _a3[path[i2]] = toMerge, _a3);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s2, i2) {
      if (isArray$1(s2)) {
        getSpecifierPaths(s2).forEach(function(p3) {
          return paths_1.push(currentPath_1.concat(p3));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s2);
        if (!isArray$1(spec[i2 + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize$1(path.reduce(function reducer(obj, key) {
    return isArray$1(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object));
}
function normalize$1(value) {
  if (isNonNullObject$1(value)) {
    if (isArray$1(value)) {
      return value.map(normalize$1);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField$1(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context2) {
  return context2.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a3) {
  var mergeObjects = _a3.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_2, incoming) {
  return incoming;
};
var Policies = (
  /** @class */
  function() {
    function Policies2(config) {
      this.config = config;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config.possibleTypes) {
        this.addPossibleTypes(config.possibleTypes);
      }
      if (config.typePolicies) {
        this.addTypePolicies(config.typePolicies);
      }
    }
    Policies2.prototype.identify = function(object, partialContext) {
      var _a3;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a3 = partialContext.storeObject) === null || _a3 === void 0 ? void 0 : _a3.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context2 = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options2 = normalizeReadFieldOptions(arguments, storeObject);
        return policies.readField(options2, {
          store: policies.cache["data"],
          variables: options2.variables
        });
      } });
      var id2;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      while (keyFn) {
        var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context2);
        if (isArray$1(specifierOrId)) {
          keyFn = keyFieldsFnFromSpecifier(specifierOrId);
        } else {
          id2 = specifierOrId;
          break;
        }
      }
      id2 = id2 ? String(id2) : void 0;
      return context2.keyObject ? [id2, context2.keyObject] : [id2];
    };
    Policies2.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a3 = typePolicies[typename], queryType = _a3.queryType, mutationType = _a3.mutationType, subscriptionType = _a3.subscriptionType, incoming = __rest(_a3, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies2.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge2) {
        existing2.merge = typeof merge2 === "function" ? merge2 : merge2 === true ? mergeTrueFn : merge2 === false ? mergeFalseFn : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = // Pass false to disable normalization for this typename.
      keyFields === false ? nullKeyFieldsFn : isArray$1(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge2 = incoming2.merge;
            existing2.keyFn = // Pass false to disable argument-based differentiation of
            // field identities.
            keyArgs === false ? simpleKeyArgsFn : isArray$1(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read === "function") {
              existing2.read = read;
            }
            setMerge(existing2, merge2);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
          }
        });
      }
    };
    Policies2.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        invariant$3(!old || old === which, 5, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies2.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match = subtype.match(TypeOrFieldNameRegExp);
          if (!match || match[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies2.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a3 = _this.getTypePolicy(supertype), fields = _a3.fields, rest = __rest(_a3, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i2 = 0; i2 < workQueue_1.length; ++i2) {
          var supertypeSet = workQueue_1[i2];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && invariant$3.warn(6, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          i2 === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match = typename.match(regExp);
              if (match && match[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies2.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context2 = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context2);
          if (isArray$1(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? storeKeyNameFromField$1(fieldSpec.field, fieldSpec.variables) : getStoreKeyName$1(fieldName, argsFromFieldSpecifier(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies2.prototype.readField = function(options2, context2) {
      var objectOrReference = options2.from;
      if (!objectOrReference)
        return;
      var nameOrField = options2.field || options2.fieldName;
      if (!nameOrField)
        return;
      if (options2.typename === void 0) {
        var typename = context2.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options2.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options2);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options2.typename, fieldName, false);
      var read = policy && policy.read;
      if (read) {
        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options2, context2, context2.store.getStorage(isReference$1(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot.withValue(this.cache, read, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies2.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge2 = policy && policy.merge;
      if (!merge2 && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge2 = policy && policy.merge;
      }
      return merge2;
    };
    Policies2.prototype.runMergeFunction = function(existing, incoming, _a3, context2, storage) {
      var field = _a3.field, typename = _a3.typename, merge2 = _a3.merge;
      if (merge2 === mergeTrueFn) {
        return makeMergeObjectsFunction(context2.store)(existing, incoming);
      }
      if (merge2 === mergeFalseFn) {
        return incoming;
      }
      if (context2.overwrite) {
        existing = void 0;
      }
      return merge2(existing, incoming, makeFieldFunctionOptions(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context2.variables
        },
        context2,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies2;
  }()
);
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context2, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context2.variables;
  var _a3 = context2.store, toReference = _a3.toReference, canRead = _a3.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference: isReference$1,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context2);
    },
    mergeObjects: makeMergeObjectsFunction(context2.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options2;
  if (typeof fieldNameOrOptions === "string") {
    options2 = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options2 = __assign({}, fieldNameOrOptions);
    if (!hasOwn.call(options2, "from")) {
      options2.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options2.from === void 0) {
    globalThis.__DEV__ !== false && invariant$3.warn(7, stringifyForDisplay$1(Array.from(readFieldArgs)));
  }
  if (void 0 === options2.variables) {
    options2.variables = variables;
  }
  return options2;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray$1(existing) || isArray$1(incoming)) {
      throw newInvariantError(8);
    }
    if (isNonNullObject$1(existing) && isNonNullObject$1(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference$1(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference$1(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign(__assign({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context2, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context2.flavors.get(key);
  if (!flavored) {
    context2.flavors.set(key, flavored = context2.clientOnly === clientOnly && context2.deferred === deferred ? context2 : __assign(__assign({}, context2), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = (
  /** @class */
  function() {
    function StoreWriter2(cache2, reader, fragments) {
      this.cache = cache2;
      this.reader = reader;
      this.fragments = fragments;
    }
    StoreWriter2.prototype.writeToStore = function(store, _a3) {
      var _this = this;
      var query = _a3.query, result = _a3.result, dataId = _a3.dataId, variables = _a3.variables, overwrite = _a3.overwrite;
      var operationDefinition = getOperationDefinition$1(query);
      var merger = makeProcessedFieldsMerger();
      variables = __assign(__assign({}, getDefaultValues$1(operationDefinition)), variables);
      var context2 = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: canonicalStringify$1(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: context2
      });
      if (!isReference$1(ref)) {
        throw newInvariantError(11, result);
      }
      context2.incomingById.forEach(function(_a22, dataId2) {
        var storeObject = _a22.storeObject, mergeTree = _a22.mergeTree, fieldNodeSet = _a22.fieldNodeSet;
        var entityRef = makeReference$1(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context2);
          if (isReference$1(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context2.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context2.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter2.prototype.processSelectionSet = function(_a3) {
      var _this = this;
      var dataId = _a3.dataId, result = _a3.result, selectionSet = _a3.selectionSet, context2 = _a3.context, mergeTree = _a3.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult$1(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options2 = normalizeReadFieldOptions(arguments, incoming, context2.variables);
        if (isReference$1(options2.from)) {
          var info = context2.incomingById.get(options2.from.__ref);
          if (info) {
            var result_1 = policies.readField(__assign(__assign({}, options2), { from: info.storeObject }), context2);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options2, context2);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        context2,
        typename
      ).forEach(function(context22, field) {
        var _a22;
        var resultFieldKey = resultKeyNameFromField$1(field);
        var value = result[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context22.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            field.selectionSet ? getContextFlavor(context22, false, false) : context22,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (isReference$1(incomingValue) || storeValueIsStoreObject(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge2 = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge2) {
            childTree.info = {
              // TODO Check compatibility against any existing childTree.field?
              field,
              typename,
              merge: merge2
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incoming = context22.merge(incoming, (_a22 = {}, _a22[storeFieldName] = incomingValue, _a22));
        } else if (globalThis.__DEV__ !== false && !context22.clientOnly && !context22.deferred && !addTypenameToDocument$1.added(field) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && invariant$3.error(12, resultKeyNameFromField$1(field), result);
        }
      });
      try {
        var _b2 = policies.identify(result, {
          typename,
          selectionSet,
          fragmentMap: context2.fragmentMap,
          storeObject: incoming,
          readField
        }), id2 = _b2[0], keyObject = _b2[1];
        dataId = dataId || id2;
        if (keyObject) {
          incoming = context2.merge(incoming, keyObject);
        }
      } catch (e2) {
        if (!dataId)
          throw e2;
      }
      if ("string" === typeof dataId) {
        var dataRef = makeReference$1(dataId);
        var sets = context2.written[dataId] || (context2.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context2)) {
          return dataRef;
        }
        var previous_1 = context2.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context2.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context2.incomingById.set(dataId, {
            storeObject: incoming,
            // Save a reference to mergeTree only if it is not empty, because
            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
            // reused for entirely different parts of the result tree.
            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter2.prototype.processFieldValue = function(value, field, context2, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? cloneDeep$1(value) : value;
      }
      if (isArray$1(value)) {
        return value.map(function(item, i2) {
          var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree(mergeTree, i2));
          maybeRecycleChildMergeTree(mergeTree, i2);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context: context2,
        mergeTree
      });
    };
    StoreWriter2.prototype.flattenFields = function(selectionSet, result, context2, typename) {
      if (typename === void 0) {
        typename = getTypenameFromResult$1(result, selectionSet, context2.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new Trie(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!shouldInclude$1(selection, context2.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (
            // Since the presence of @client or @defer on this field can only
            // cause clientOnly or deferred to become true, we can skip the
            // forEach loop if both clientOnly and deferred are already true.
            !(clientOnly && deferred) && isNonEmptyArray$1(selection.directives)
          ) {
            selection.directives.forEach(function(dir) {
              var name = dir.name.value;
              if (name === "client")
                clientOnly = true;
              if (name === "defer") {
                var args = argumentsObjectFromField$1(dir, context2.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (isField$1(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor(context2, clientOnly, deferred));
          } else {
            var fragment = getFragmentFromSelection$1(selection, context2.lookupFragment);
            if (!fragment && selection.kind === Kind$1.FRAGMENT_SPREAD) {
              throw newInvariantError(13, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
              flatten(fragment.selectionSet, getContextFlavor(context2, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context2);
      return fieldMap;
    };
    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
      var _a3;
      var _this = this;
      if (mergeTree.map.size && !isReference$1(incoming)) {
        var e_1 = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !isArray$1(incoming) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (isReference$1(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
        );
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [isReference$1(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name) {
          return isArray$1(from2) ? typeof name === "number" ? from2[name] : void 0 : context2.store.getFieldValue(from2, String(name));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            invariant$3(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = isArray$1(i_1) ? i_1.slice(0) : __assign({}, i_1);
          changedFields_1.forEach(function(value, name) {
            incoming[name] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a3 = context2.store).getStorage.apply(_a3, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter2;
  }()
);
var emptyMergeTreePool = [];
function getChildMergeTree(_a3, name) {
  var map = _a3.map;
  if (!map.has(name)) {
    map.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a3, name) {
  var map = _a3.map;
  var childTree = map.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference$1(existing))
    return;
  if (equal$2(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray$1(existing) && !isArray$1(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant$3.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
}
var InMemoryCache = (
  /** @class */
  function(_super) {
    __extends(InMemoryCache2, _super);
    function InMemoryCache2(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new DocumentTransform$1(addTypenameToDocument$1);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar;
      _this.txCount = 0;
      _this.config = normalizeConfig(config);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache2.prototype.init = function() {
      var rootStore = this.data = new EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = wrap$1(function(c2, options2) {
        return _this.broadcastWatch(c2, options2);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes$1["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(c2) {
          var store = c2.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching(store)) {
            var optimistic = c2.optimistic, id2 = c2.id, variables = c2.variables;
            return store.makeCacheKey(
              c2.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              c2.callback,
              canonicalStringify$1({ optimistic, id: id2, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache2.prototype.restore = function(data) {
      this.init();
      if (data)
        this.data.replace(data);
      return this;
    };
    InMemoryCache2.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache2.prototype.read = function(options2) {
      var _a3 = options2.returnPartialData, returnPartialData = _a3 === void 0 ? false : _a3;
      try {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e2) {
        if (e2 instanceof MissingFieldError) {
          return null;
        }
        throw e2;
      }
    };
    InMemoryCache2.prototype.write = function(options2) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options2);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.modify = function(options2) {
      if (hasOwn.call(options2, "id") && !options2.id) {
        return false;
      }
      var store = options2.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options2.id || "ROOT_QUERY", options2.fields);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.diff = function(options2) {
      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, rootId: options2.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache2.prototype.watch = function(watch) {
      var _this = this;
      if (!this.watches.size) {
        recallCache(this);
      }
      this.watches.add(watch);
      if (watch.immediate) {
        this.maybeBroadcastWatch(watch);
      }
      return function() {
        if (_this.watches.delete(watch) && !_this.watches.size) {
          forgetCache(_this);
        }
        _this.maybeBroadcastWatch.forget(watch);
      };
    };
    InMemoryCache2.prototype.gc = function(options2) {
      var _a3;
      canonicalStringify$1.reset();
      print$2.reset();
      this.addTypenameTransform.resetCache();
      (_a3 = this.config.fragments) === null || _a3 === void 0 ? void 0 : _a3.resetCaches();
      var ids = this.optimisticData.gc();
      if (options2 && !this.txCount) {
        if (options2.resetResultCache) {
          this.resetResultCache(options2.resetResultIdentities);
        } else if (options2.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache2.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache2.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache2.prototype.identify = function(object) {
      if (isReference$1(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e2) {
        globalThis.__DEV__ !== false && invariant$3.warn(e2);
      }
    };
    InMemoryCache2.prototype.evict = function(options2) {
      if (!options2.id) {
        if (hasOwn.call(options2, "id")) {
          return false;
        }
        options2 = __assign(__assign({}, options2), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options2, this.data);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.reset = function(options2) {
      var _this = this;
      this.init();
      canonicalStringify$1.reset();
      if (options2 && options2.discardWatches) {
        this.watches.forEach(function(watch) {
          return _this.maybeBroadcastWatch.forget(watch);
        });
        this.watches.clear();
        forgetCache(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache2.prototype.batch = function(options2) {
      var _this = this;
      var update = options2.update, _a3 = options2.optimistic, optimistic = _a3 === void 0 ? true : _a3, removeOptimistic = options2.removeOptimistic, onWatchUpdated = options2.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a22 = _this, data = _a22.data, optimisticData = _a22.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(__assign(__assign({}, options2), { onWatchUpdated: function(watch) {
          alreadyDirty.add(watch);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(__assign(__assign({}, options2), { onWatchUpdated: function(watch, diff2) {
          var result = onWatchUpdated.call(this, watch, diff2);
          if (result !== false) {
            alreadyDirty.delete(watch);
          }
          return result;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch) {
            return _this.maybeBroadcastWatch.dirty(watch);
          });
        }
      } else {
        this.broadcastWatches(options2);
      }
      return updateResult;
    };
    InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache2.prototype.transformDocument = function(document2) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
    };
    InMemoryCache2.prototype.broadcastWatches = function(options2) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c2) {
          return _this.maybeBroadcastWatch(c2, options2);
        });
      }
    };
    InMemoryCache2.prototype.addFragmentsToDocument = function(document2) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document2) : document2;
    };
    InMemoryCache2.prototype.addTypenameToDocument = function(document2) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document2);
      }
      return document2;
    };
    InMemoryCache2.prototype.broadcastWatch = function(c2, options2) {
      var lastDiff = c2.lastDiff;
      var diff2 = this.diff(c2);
      if (options2) {
        if (c2.optimistic && typeof options2.optimistic === "string") {
          diff2.fromOptimisticTransaction = true;
        }
        if (options2.onWatchUpdated && options2.onWatchUpdated.call(this, c2, diff2, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal$2(lastDiff.result, diff2.result)) {
        c2.callback(c2.lastDiff = diff2, lastDiff);
      }
    };
    return InMemoryCache2;
  }(ApolloCache)
);
if (globalThis.__DEV__ !== false) {
  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
}
function createFragmentRegistry() {
  var fragments = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    fragments[_i2] = arguments[_i2];
  }
  return new (FragmentRegistry.bind.apply(FragmentRegistry, __spreadArray([void 0], fragments, false)))();
}
var FragmentRegistry = (
  /** @class */
  function() {
    function FragmentRegistry2() {
      var fragments = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        fragments[_i2] = arguments[_i2];
      }
      this.registry = /* @__PURE__ */ Object.create(null);
      this.resetCaches();
      if (fragments.length) {
        this.register.apply(this, fragments);
      }
    }
    FragmentRegistry2.prototype.register = function() {
      var _this = this;
      var fragments = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        fragments[_i2] = arguments[_i2];
      }
      var definitions = /* @__PURE__ */ new Map();
      fragments.forEach(function(doc) {
        getFragmentDefinitions$1(doc).forEach(function(node) {
          definitions.set(node.name.value, node);
        });
      });
      definitions.forEach(function(node, name) {
        if (node !== _this.registry[name]) {
          _this.registry[name] = node;
          _this.invalidate(name);
        }
      });
      return this;
    };
    FragmentRegistry2.prototype.invalidate = function(name) {
    };
    FragmentRegistry2.prototype.resetCaches = function() {
      var proto = FragmentRegistry2.prototype;
      this.invalidate = (this.lookup = wrap$1(proto.lookup.bind(this), {
        makeCacheKey: function(arg) {
          return arg;
        },
        max: cacheSizes$1["fragmentRegistry.lookup"] || 1e3
      })).dirty;
      this.transform = wrap$1(proto.transform.bind(this), {
        cache: WeakCache,
        max: cacheSizes$1["fragmentRegistry.transform"] || 2e3
      });
      this.findFragmentSpreads = wrap$1(proto.findFragmentSpreads.bind(this), {
        cache: WeakCache,
        max: cacheSizes$1["fragmentRegistry.findFragmentSpreads"] || 4e3
      });
    };
    FragmentRegistry2.prototype.lookup = function(fragmentName) {
      return this.registry[fragmentName] || null;
    };
    FragmentRegistry2.prototype.transform = function(document2) {
      var _this = this;
      var defined = /* @__PURE__ */ new Map();
      getFragmentDefinitions$1(document2).forEach(function(def) {
        defined.set(def.name.value, def);
      });
      var unbound = /* @__PURE__ */ new Set();
      var enqueue2 = function(spreadName) {
        if (!defined.has(spreadName)) {
          unbound.add(spreadName);
        }
      };
      var enqueueChildSpreads = function(node) {
        return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
      };
      enqueueChildSpreads(document2);
      var missing = [];
      var map = /* @__PURE__ */ Object.create(null);
      unbound.forEach(function(fragmentName) {
        var knownFragmentDef = defined.get(fragmentName);
        if (knownFragmentDef) {
          enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
        } else {
          missing.push(fragmentName);
          var def = _this.lookup(fragmentName);
          if (def) {
            enqueueChildSpreads(map[fragmentName] = def);
          }
        }
      });
      if (missing.length) {
        var defsToAppend_1 = [];
        missing.forEach(function(name) {
          var def = map[name];
          if (def) {
            defsToAppend_1.push(def);
          }
        });
        if (defsToAppend_1.length) {
          document2 = __assign(__assign({}, document2), { definitions: document2.definitions.concat(defsToAppend_1) });
        }
      }
      return document2;
    };
    FragmentRegistry2.prototype.findFragmentSpreads = function(root2) {
      var spreads = /* @__PURE__ */ Object.create(null);
      visit$1(root2, {
        FragmentSpread: function(node) {
          spreads[node.name.value] = node;
        }
      });
      return spreads;
    };
    return FragmentRegistry2;
  }()
);
const cache$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApolloCache,
  get Cache() {
    return Cache;
  },
  get EntityStore() {
    return EntityStore;
  },
  InMemoryCache,
  MissingFieldError,
  Policies,
  cacheSlot,
  canonicalStringify: canonicalStringify$1,
  createFragmentRegistry,
  defaultDataIdFromObject,
  fieldNameFromStoreName,
  isReference: isReference$1,
  makeReference: makeReference$1,
  makeVar
}, Symbol.toStringTag, { value: "Module" }));
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
function isNetworkRequestSettled(networkStatus) {
  return networkStatus === 7 || networkStatus === 8;
}
var assign = Object.assign, hasOwnProperty$3 = Object.hasOwnProperty;
var ObservableQuery = (
  /** @class */
  function(_super) {
    __extends(ObservableQuery2, _super);
    function ObservableQuery2(_a3) {
      var queryManager = _a3.queryManager, queryInfo = _a3.queryInfo, options2 = _a3.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a22) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(last.result);
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor(options2.fetchPolicy);
      _this.isTornDown = false;
      _this.subscribeToMore = _this.subscribeToMore.bind(_this);
      var _b2 = queryManager.defaultOptions.watchQuery, _c2 = _b2 === void 0 ? {} : _b2, _d = _c2.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e2 = options2.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options2.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign(__assign({}, options2), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition$1(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result) {
            resolve(result);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a3 = this.options.fetchPolicy, fetchPolicy = _a3 === void 0 ? "cache-first" : _a3;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
      ) ;
      else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff2 = this.queryInfo.getDiff();
        if (diff2.complete || this.options.returnPartialData) {
          result.data = diff2.result;
        }
        if (equal$2(result.data, {})) {
          result.data = void 0;
        }
        if (diff2.complete) {
          delete result.partial;
          if (diff2.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result.networkStatus = NetworkStatus.ready;
            result.loading = false;
          }
        } else {
          result.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff2.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
          logMissingFieldErrors(diff2.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result);
      }
      return result;
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery(this.query, this.last.result, newResult, this.variables) : !equal$2(this.last.result, newResult);
      return resultIsDifferent || variables && !equal$2(this.last.variables, variables);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal$2(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a3;
      var reobserveOptions = {
        // Always disable polling for refetches.
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty$3.call(variables, "variables")) {
        var queryDef = getQueryDefinition$1(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v2) {
          return v2.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && invariant$3.warn(
            20,
            variables,
            ((_a3 = queryDef.name) === null || _a3 === void 0 ? void 0 : _a3.value) || queryDef
          );
        }
      }
      if (variables && !equal$2(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        _this.queryManager.cache.batch({
          update: function(cache2) {
            var updateQuery = fetchMoreOptions.updateQuery;
            if (updateQuery) {
              cache2.updateQuery({
                query: _this.query,
                variables: _this.variables,
                returnPartialData: true,
                optimistic: false
              }, function(previous) {
                return updateQuery(previous, {
                  fetchMoreResult: fetchMoreResult.data,
                  variables: combinedOptions.variables
                });
              });
            } else {
              cache2.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: function(watch) {
            updatedQuerySet.add(watch.query);
          }
        });
        return fetchMoreResult;
      }).finally(function() {
        if (!updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options2) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options2.document,
        variables: options2.variables,
        context: options2.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options2.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a3) {
              var variables = _a3.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options2.onError) {
            options2.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && invariant$3.error(21, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = compact$1(this.options, newOptions || {});
      assign(this.options, mergedOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal$2(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options2) {
      if (options2.nextFetchPolicy) {
        var _a3 = options2.fetchPolicy, fetchPolicy = _a3 === void 0 ? "cache-first" : _a3, _b2 = options2.initialFetchPolicy, initialFetchPolicy = _b2 === void 0 ? fetchPolicy : _b2;
        if (fetchPolicy === "standby") ;
        else if (typeof options2.nextFetchPolicy === "function") {
          options2.fetchPolicy = options2.nextFetchPolicy(fetchPolicy, {
            reason,
            options: options2,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options2.fetchPolicy = initialFetchPolicy;
        } else {
          options2.fetchPolicy = options2.nextFetchPolicy;
        }
      }
      return options2.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options2, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options2, newNetworkStatus, query);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a3 = this, pollingInfo = _a3.pollingInfo, pollInterval = _a3.options.pollInterval;
      if (!pollInterval || !this.hasObservers()) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      invariant$3(pollInterval, 22);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        var _a22, _b2;
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b2 = (_a22 = _this.options).skipPollAttempt) === null || _b2 === void 0 ? void 0 : _b2.call(_a22))) {
            _this.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal$2(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep$1(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        newNetworkStatus === NetworkStatus.poll
      );
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact$1(this.options, newOptions || {});
      var options2 = useDisposableConcast ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        mergedOptions
      ) : assign(this.options, mergedOptions);
      var query = this.transformDocument(options2.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal$2(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
        options2.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
        (options2.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
        // so in that case `applyNextFetchPolicy` must be called.
        typeof options2.nextFetchPolicy === "function")) {
          this.applyNextFetchPolicy("variables-changed", options2);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options2.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options2.variables && __assign({}, options2.variables);
      var _a3 = this.fetch(options2, newNetworkStatus, query), concast = _a3.concast, fromLink = _a3.fromLink;
      var observer = {
        next: function(result) {
          if (equal$2(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportResult(result, variables);
          }
        },
        error: function(error) {
          if (equal$2(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportError(error, variables);
          }
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
    };
    ObservableQuery2.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var last = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last;
      return subscription;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentResult(false),
        this.variables
      );
    };
    ObservableQuery2.prototype.reportResult = function(result, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result, variables);
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      if (lastError || isDifferent) {
        iterateObserversSafely$1(this.observers, "next", result);
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely$1(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery2.prototype.transformDocument = function(document2) {
      return this.queryManager.transform(document2);
    };
    return ObservableQuery2;
  }(Observable)
);
fixObservableSubclass$1(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a3 = obsQuery.options, fetchPolicy = _a3.fetchPolicy, nextFetchPolicy = _a3.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context2) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context2);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant$3.error(23, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant$3.debug(24, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}
var destructiveMethodCounts = new (canUseWeakMap$1 ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = (
  /** @class */
  function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache2 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache2)) {
        destructiveMethodCounts.set(cache2, 0);
        wrapDestructiveCacheMethod(cache2, "evict");
        wrapDestructiveCacheMethod(cache2, "modify");
        wrapDestructiveCacheMethod(cache2, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal$2(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal$2(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.dirty = false;
    };
    QueryInfo2.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    };
    QueryInfo2.prototype.getDiff = function() {
      var options2 = this.getDiffOptions();
      if (this.lastDiff && equal$2(options2, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff2 = this.cache.diff(options2);
      this.updateLastDiff(diff2, options2);
      return diff2;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff2, options2) {
      this.lastDiff = diff2 ? {
        diff: diff2,
        options: options2 || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a3;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a3 = this.observableQuery) === null || _a3 === void 0 ? void 0 : _a3.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff2) {
      var _this = this;
      var _a3;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      if (diff2 && !diff2.complete && ((_a3 = this.observableQuery) === null || _a3 === void 0 ? void 0 : _a3.getLastError())) {
        return;
      }
      this.updateLastDiff(diff2);
      if (!this.dirty && !equal$2(oldDiff && oldDiff.result, diff2 && diff2.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff2 = _this.getDiff();
          if (diff2.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
        return _this.setDiff(diff2);
      } });
      if (!this.lastWatch || !equal$2(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal$2(variables, lastWrite.variables) && equal$2(result.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result, document2, options2, cacheWriteBehavior) {
      var _this = this;
      var merger = new DeepMerger$1();
      var graphQLErrors = isNonEmptyArray$1(result.errors) ? result.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result && isNonEmptyArray$1(result.incremental)) {
        var mergedData = mergeIncrementalData$1(this.getDiff().result, result);
        result.data = mergedData;
      } else if ("hasNext" in result && result.hasNext) {
        var diff2 = this.getDiff();
        result.data = merger.merge(diff2.result, result.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options2.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options2.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result, options2.errorPolicy)) {
          this.cache.performTransaction(function(cache2) {
            if (_this.shouldWrite(result, options2.variables)) {
              cache2.writeQuery({
                query: document2,
                data: result.data,
                variables: options2.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result,
                variables: options2.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options2.variables);
            var diff22 = cache2.diff(diffOptions);
            if (!_this.stopped && equal$2(_this.variables, options2.variables)) {
              _this.updateWatch(options2.variables);
            }
            _this.updateLastDiff(diff22, diffOptions);
            if (diff22.complete) {
              result.data = diff22.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }()
);
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError$1(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var IGNORE = /* @__PURE__ */ Object.create(null);
var QueryManager = (
  /** @class */
  function() {
    function QueryManager2(options2) {
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new AutoCleanedWeakCache$1(
        cacheSizes$1["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      );
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = new Trie(false);
      var defaultDocumentTransform = new DocumentTransform$1(
        function(document2) {
          return _this.cache.transformDocument(document2);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: false }
      );
      this.cache = options2.cache;
      this.link = options2.link;
      this.defaultOptions = options2.defaultOptions;
      this.queryDeduplication = options2.queryDeduplication;
      this.clientAwareness = options2.clientAwareness;
      this.localState = options2.localState;
      this.ssrMode = options2.ssrMode;
      this.assumeImmutableResults = options2.assumeImmutableResults;
      var documentTransform = options2.documentTransform;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      this.defaultContext = options2.defaultContext || /* @__PURE__ */ Object.create(null);
      if (this.onBroadcast = options2.onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(newInvariantError(25));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a3) {
      return __awaiter(this, arguments, void 0, function(_b2) {
        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
        var _c2, _d;
        var mutation = _b2.mutation, variables = _b2.variables, optimisticResponse = _b2.optimisticResponse, updateQueries = _b2.updateQueries, _e2 = _b2.refetchQueries, refetchQueries = _e2 === void 0 ? [] : _e2, _f = _b2.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b2.update, onQueryUpdated = _b2.onQueryUpdated, _g = _b2.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c2 = this.defaultOptions.mutate) === null || _c2 === void 0 ? void 0 : _c2.fetchPolicy) || "network-only" : _g, _h = _b2.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b2.keepRootFields, context2 = _b2.context;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              invariant$3(mutation, 26);
              invariant$3(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2) return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context2)];
            case 1:
              variables = _j.sent();
              _j.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context: context2,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap$1(self2.getObservableFromLink(mutation, __assign(__assign({}, context2), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result) {
                  if (graphQLResultHasError$1(result) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: getGraphQLErrorsFromResult$1(result)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign({}, result);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError$1(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context: context2,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: isOptimistic ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(storeResult);
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (isOptimistic) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
      var _this = this;
      if (cache2 === void 0) {
        cache2 = this.cache;
      }
      var result = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
        if (!isExecutionPatchIncrementalResult$1(result)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (isExecutionPatchIncrementalResult$1(result) && isNonEmptyArray$1(result.incremental)) {
          var diff2 = cache2.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff2.result) {
            mergedData = mergeIncrementalData$1(diff2.result, result);
          }
          if (typeof mergedData !== "undefined") {
            result.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a3, queryId) {
            var observableQuery = _a3.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty$2.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b2 = _this.queries.get(queryId), document2 = _b2.document, variables = _b2.variables;
            var _c2 = cache2.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c2.result, complete = _c2.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result,
                queryName: document2 && getOperationName$1(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache22) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache22.write(write);
              });
            }
            var update = mutation.update;
            var isFinalResult = !isExecutionPatchResult$1(result) || isExecutionPatchIncrementalResult$1(result) && !result.hasNext;
            if (update) {
              if (!skipCache) {
                var diff22 = cache22.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff22.complete) {
                  result = __assign(__assign({}, result), { data: diff22.result });
                  if ("incremental" in result) {
                    delete result.incremental;
                  }
                  if ("hasNext" in result) {
                    delete result.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache22, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache22.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a3) {
                  var fieldName = _a3.fieldName, DELETE2 = _a3.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: false,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: mutation.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result2) {
          return results_1.push(result2);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result;
          });
        }
      }
      return Promise.resolve(result);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
      if (data === IGNORE) {
        return false;
      }
      this.cache.recordOptimisticTransaction(function(cache2) {
        try {
          _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache2);
        } catch (error) {
          globalThis.__DEV__ !== false && invariant$3.error(error);
        }
      }, mutation.mutationId);
      return true;
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options2, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options2, networkStatus).concast.promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document2) {
      return this.documentTransform.transformDocument(document2);
    };
    QueryManager2.prototype.getDocumentInfo = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var cacheEntry = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: hasClientExports$1(document2),
          hasForcedResolvers: this.localState.shouldForceResolvers(document2),
          hasNonreactiveDirective: hasDirectives$1(["nonreactive"], document2),
          clientQuery: this.localState.clientQuery(document2),
          serverQuery: removeDirectivesFromDocument$1([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" }
          ], document2),
          defaultVars: getDefaultValues$1(getOperationDefinition$1(document2)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: __assign(__assign({}, document2), { definitions: document2.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign(__assign({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document2, cacheEntry);
      }
      return transformCache.get(document2);
    };
    QueryManager2.prototype.getVariables = function(document2, variables) {
      return __assign(__assign({}, this.getDocumentInfo(document2).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options2) {
      var query = this.transform(options2.query);
      options2 = __assign(__assign({}, options2), { variables: this.getVariables(query, options2.variables) });
      if (typeof options2.notifyOnNetworkStatusChange === "undefined") {
        options2.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options: options2
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options2, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      invariant$3(options2.query, 28);
      invariant$3(options2.query.kind === "Document", 29);
      invariant$3(!options2.returnPartialData, 30);
      invariant$3(!options2.pollInterval, 31);
      return this.fetchQuery(queryId, __assign(__assign({}, options2), { query: this.transform(options2.query) })).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options2) {
      if (options2 === void 0) {
        options2 = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(newInvariantError(32));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options2);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (isDocumentNode$1(desc)) {
            queryNamesAndDocs.set(_this.transform(desc), false);
          } else if (isNonNullObject$1(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a3, queryId) {
        var oq = _a3.observableQuery, document2 = _a3.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document2)
              queryNamesAndDocs.set(document2, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options2) {
          var queryId = makeUniqueId$1("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options2.query,
            variables: options2.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign(__assign({}, options2), { fetchPolicy: "network-only" })
          });
          invariant$3(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            globalThis.__DEV__ !== false && invariant$3.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(_a3) {
      var _this = this;
      var query = _a3.query, fetchPolicy = _a3.fetchPolicy, _b2 = _a3.errorPolicy, errorPolicy = _b2 === void 0 ? "none" : _b2, variables = _a3.variables, _c2 = _a3.context, context2 = _c2 === void 0 ? {} : _c2, _d = _a3.extensions, extensions = _d === void 0 ? {} : _d;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context2, variables2, extensions).map(function(result) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result, errorPolicy)) {
              _this.cache.write({
                query,
                result: result.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = graphQLResultHasError$1(result);
          var hasProtocolErrors = graphQLResultHasProtocolErrors(result);
          if (hasErrors || hasProtocolErrors) {
            var errors2 = {};
            if (hasErrors) {
              errors2.graphQLErrors = result.errors;
            }
            if (hasProtocolErrors) {
              errors2.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new ApolloError(errors2);
            }
          }
          if (errorPolicy === "ignore") {
            delete result.errors;
          }
          return result;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context2, variables, extensions, deduplication) {
      var _this = this;
      var _a3;
      if (deduplication === void 0) {
        deduplication = (_a3 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a3 !== void 0 ? _a3 : this.queryDeduplication;
      }
      var observable;
      var _b2 = this.getDocumentInfo(query), serverQuery = _b2.serverQuery, clientQuery = _b2.clientQuery;
      if (serverQuery) {
        var _c2 = this, inFlightLinkObservables_1 = _c2.inFlightLinkObservables, link = _c2.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName$1(serverQuery) || void 0,
          context: this.prepareContext(__assign(__assign({}, context2), { forceFetch: !deduplication })),
          extensions
        };
        context2 = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = print$2(serverQuery);
          var varJson_1 = canonicalStringify$1(variables);
          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
          observable = entry.observable;
          if (!observable) {
            var concast = new Concast$1([
              execute(link, operation)
            ]);
            observable = entry.observable = concast;
            concast.beforeNext(function() {
              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
            });
          }
        } else {
          observable = new Concast$1([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast$1([Observable.of({ data: {} })]);
        context2 = this.prepareContext(context2);
      }
      if (clientQuery) {
        observable = asyncMap$1(observable, function(result) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result,
            context: context2,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options2) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options2.query);
      return asyncMap$1(this.getObservableFromLink(linkDocument, options2.context, options2.variables), function(result) {
        var graphQLErrors = getGraphQLErrorsFromResult$1(result);
        var hasErrors = graphQLErrors.length > 0;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && options2.errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result, linkDocument, options2, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && options2.errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options2, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options2.query;
      }
      var variables = this.getVariables(query, options2.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a3 = options2.fetchPolicy, fetchPolicy = _a3 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a3, _b2 = options2.errorPolicy, errorPolicy = _b2 === void 0 ? defaults && defaults.errorPolicy || "none" : _b2, _c2 = options2.returnPartialData, returnPartialData = _c2 === void 0 ? false : _c2, _d = options2.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options2.context, context2 = _e2 === void 0 ? {} : _e2;
      var normalized = Object.assign({}, options2, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context: context2
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
        ) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options2);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new Concast$1(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new Concast$1(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager2.prototype.refetchQueries = function(_a3) {
      var _this = this;
      var updateCache = _a3.updateCache, include = _a3.include, _b2 = _a3.optimistic, optimistic = _b2 === void 0 ? false : _b2, _c2 = _a3.removeOptimistic, removeOptimistic = _c2 === void 0 ? optimistic ? makeUniqueId$1("refetchQueries") : void 0 : _c2, onQueryUpdated = _a3.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          // Since you can perform any combination of cache reads and/or writes in
          // the cache.batch update function, its optimistic option can be either
          // a boolean or a string, representing three distinct modes of
          // operation:
          //
          // * false: read/write only the root layer
          // * true: read/write the topmost layer
          // * string: read/write a fresh optimistic layer with that ID string
          //
          // When typeof optimistic === "string", a new optimistic layer will be
          // temporarily created within cache.batch with that string as its ID. If
          // we then pass that same string as the removeOptimistic option, we can
          // make cache.batch immediately remove the optimistic layer after
          // running the updateCache function, triggering only one broadcast.
          //
          // However, the refetchQueries method accepts only true or false for its
          // optimistic option (not string). We interpret true to mean a temporary
          // optimistic layer should be created, to allow efficiently rolling back
          // the effect of the updateCache function, which involves passing a
          // string instead of true as the optimistic option to cache.batch, when
          // refetchQueries receives optimistic: true.
          //
          // In other words, we are deliberately not supporting the use case of
          // writing to an *existing* optimistic layer (using the refetchQueries
          // updateCache function), since that would potentially interfere with
          // other optimistic updates in progress. Instead, you can read/write
          // only the root layer by passing optimistic: false to refetchQueries,
          // or you can read/write a brand new optimistic layer that will be
          // automatically removed by passing optimistic: true.
          optimistic: optimistic && removeOptimistic || false,
          // The removeOptimistic option can also be provided by itself, even if
          // optimistic === false, to remove some previously-added optimistic
          // layer safely and efficiently, like we do in markMutationResult.
          //
          // If an explicit removeOptimistic string is provided with optimistic:
          // true, the removeOptimistic string will determine the ID of the
          // temporary optimistic layer, in case that ever matters.
          removeOptimistic,
          onWatchUpdated: function(watch, diff2, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result = onQueryUpdated(oq, diff2, lastDiff);
                if (result === true) {
                  result = oq.refetch();
                }
                if (result !== false) {
                  results.set(oq, result);
                }
                return result;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a22, queryId) {
          var oq = _a22.oq, lastDiff = _a22.lastDiff, diff2 = _a22.diff;
          var result;
          if (onQueryUpdated) {
            if (!diff2) {
              var info = oq["queryInfo"];
              info.reset();
              diff2 = info.getDiff();
            }
            result = onQueryUpdated(oq, diff2, lastDiff);
          }
          if (!onQueryUpdated || result === true) {
            result = oq.refetch();
          }
          if (result !== false) {
            results.set(oq, result);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a3, networkStatus) {
      var _this = this;
      var query = _a3.query, variables = _a3.variables, fetchPolicy = _a3.fetchPolicy, refetchWritePolicy = _a3.refetchWritePolicy, errorPolicy = _a3.errorPolicy, returnPartialData = _a3.returnPartialData, context2 = _a3.context, notifyOnNetworkStatusChange = _a3.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff22, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data = diff22.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal$2(data, {})) {
          logMissingFieldErrors(diff22.missing);
        }
        var fromData = function(data2) {
          return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff22.complete ? null : { partial: true }));
        };
        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context: context2,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff22.missing)) {
          return fromData(void 0);
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context: context2,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff2 = readCache();
          if (diff2.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff2, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff2), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff2 = readCache();
          if (diff2.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff2), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              // Note that queryInfo.getDiff() for no-cache queries does not call
              // cache.diff, but instead returns a { complete: false } stub result
              // when there is no queryInfo.diff already defined.
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context2) {
      if (context2 === void 0) {
        context2 = {};
      }
      var newContext = this.localState.prepareContext(context2);
      return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }()
);
var LocalState = (
  /** @class */
  function() {
    function LocalState2(_a3) {
      var cache2 = _a3.cache, client = _a3.client, resolvers = _a3.resolvers, fragmentMatcher = _a3.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache2;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep$1(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep$1(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a3) {
      return __awaiter(this, arguments, void 0, function(_b2) {
        var document2 = _b2.document, remoteResult = _b2.remoteResult, context2 = _b2.context, variables = _b2.variables, _c2 = _b2.onlyRunForcedResolvers, onlyRunForcedResolvers = _c2 === void 0 ? false : _c2;
        return __generator(this, function(_d) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign(__assign({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document2) {
      if (hasDirectives$1(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document2) {
      return removeClientSetsFromDocument$1(document2);
    };
    LocalState2.prototype.prepareContext = function(context2) {
      var cache2 = this.cache;
      return __assign(__assign({}, context2), {
        cache: cache2,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(obj) {
          return cache2.identify(obj);
        }
      });
    };
    LocalState2.prototype.addExportedVariables = function(document_1) {
      return __awaiter(this, arguments, void 0, function(document2, variables, context2) {
        if (variables === void 0) {
          variables = {};
        }
        if (context2 === void 0) {
          context2 = {};
        }
        return __generator(this, function(_a3) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
              return __assign(__assign({}, variables), data.exportedVariables);
            })];
          }
          return [2, __assign({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      visit$1(document2, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK$1;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet$1(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
      return __awaiter(this, arguments, void 0, function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a3, cache2, client, execContext, isClientFieldDescendant;
        if (context2 === void 0) {
          context2 = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return __generator(this, function(_b2) {
          mainDefinition = getMainDefinition$1(document2);
          fragments = getFragmentDefinitions$1(document2);
          fragmentMap = createFragmentMap$1(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a3 = this, cache2 = _a3.cache, client = _a3.client;
          execContext = {
            fragmentMap,
            context: __assign(__assign({}, context2), { cache: cache2, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
            return {
              result,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var fragmentMap, context2, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator(this, function(_a3) {
          fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator(this, function(_a22) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!shouldInclude$1(selection, variables)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (isField$1(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a32;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a32 = {}, _a32[resultKeyNameFromField$1(selection)] = fieldResult, _a32));
                    }
                  })];
                }
                if (isInlineFragment$1(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  invariant$3(fragment, 18, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray$1(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator(this, function(_a3) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField$1(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  // In case the resolve function accesses reactive variables,
                  // set cacheSlot to the current cache instance.
                  cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    argumentsObjectFromField$1(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result) {
            var _a22, _b2;
            if (result === void 0) {
              result = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result;
            }
            if (result == null) {
              return result;
            }
            var isClientField = (_b2 = (_a22 = field.directives) === null || _a22 === void 0 ? void 0 : _a22.some(function(d3) {
              return d3.name.value === "client";
            })) !== null && _b2 !== void 0 ? _b2 : false;
            if (Array.isArray(result)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
      var _this = this;
      return Promise.all(result.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node) {
        return !Array.isArray(node);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          visit$1(definitionNode, {
            Directive: function(node, _2, __, ___, ancestors) {
              if (node.name.value === "client") {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _2, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              invariant$3(fragment, 19, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node) {
                  if (isSingleASTNode(node) && isSelectionNode(node)) {
                    matches_1.add(node);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState2;
  }()
);
var hasSuggestedDevtools = false;
var ApolloClient = (
  /** @class */
  function() {
    function ApolloClient2(options2) {
      var _this = this;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options2.cache) {
        throw newInvariantError(15);
      }
      var uri = options2.uri, credentials = options2.credentials, headers = options2.headers, cache2 = options2.cache, documentTransform = options2.documentTransform, _a3 = options2.ssrMode, ssrMode = _a3 === void 0 ? false : _a3, _b2 = options2.ssrForceFetchDelay, ssrForceFetchDelay = _b2 === void 0 ? 0 : _b2, connectToDevTools = options2.connectToDevTools, _c2 = options2.queryDeduplication, queryDeduplication = _c2 === void 0 ? true : _c2, defaultOptions2 = options2.defaultOptions, defaultContext = options2.defaultContext, _d = options2.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache2.assumeImmutableResults : _d, resolvers = options2.resolvers, typeDefs = options2.typeDefs, fragmentMatcher = options2.fragmentMatcher, clientAwarenessName = options2.name, clientAwarenessVersion = options2.version, devtools = options2.devtools;
      var link = options2.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache2;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
      if (this.devtoolsConfig.enabled === void 0) {
        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
      }
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.watchFragment = this.watchFragment.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version$1;
      this.localState = new LocalState({
        cache: cache2,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext,
        documentTransform,
        queryDeduplication,
        ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (this.devtoolsConfig.enabled)
        this.connectToDevTools();
    }
    ApolloClient2.prototype.connectToDevTools = function() {
      if (typeof window === "undefined") {
        return;
      }
      var windowWithDevTools = window;
      var devtoolsSymbol = Symbol.for("apollo.devtools");
      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
      windowWithDevTools.__APOLLO_CLIENT__ = this;
      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools = true;
        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
          setTimeout(function() {
            if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
              var nav = window.navigator;
              var ua2 = nav && nav.userAgent;
              var url = void 0;
              if (typeof ua2 === "string") {
                if (ua2.indexOf("Chrome/") > -1) {
                  url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                } else if (ua2.indexOf("Firefox/") > -1) {
                  url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                }
              }
              if (url) {
                globalThis.__DEV__ !== false && invariant$3.log("Download the Apollo DevTools for a better development experience: %s", url);
              }
            }
          }, 1e4);
        }
      }
    };
    Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options2) {
      if (this.defaultOptions.watchQuery) {
        options2 = mergeOptions$1(this.defaultOptions.watchQuery, options2);
      }
      if (this.disableNetworkFetches && (options2.fetchPolicy === "network-only" || options2.fetchPolicy === "cache-and-network")) {
        options2 = __assign(__assign({}, options2), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options2);
    };
    ApolloClient2.prototype.query = function(options2) {
      if (this.defaultOptions.query) {
        options2 = mergeOptions$1(this.defaultOptions.query, options2);
      }
      invariant$3(options2.fetchPolicy !== "cache-and-network", 16);
      if (this.disableNetworkFetches && options2.fetchPolicy === "network-only") {
        options2 = __assign(__assign({}, options2), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options2);
    };
    ApolloClient2.prototype.mutate = function(options2) {
      if (this.defaultOptions.mutate) {
        options2 = mergeOptions$1(this.defaultOptions.mutate, options2);
      }
      return this.queryManager.mutate(options2);
    };
    ApolloClient2.prototype.subscribe = function(options2) {
      return this.queryManager.startGraphQLSubscription(options2);
    };
    ApolloClient2.prototype.readQuery = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options2, optimistic);
    };
    ApolloClient2.prototype.watchFragment = function(options2) {
      return this.cache.watchFragment(options2);
    };
    ApolloClient2.prototype.readFragment = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options2, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options2) {
      var ref = this.cache.writeQuery(options2);
      if (options2.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.writeFragment = function(options2) {
      var ref = this.cache.writeFragment(options2);
      if (options2.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb2) {
      this.devToolsHookCb = cb2;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn2) {
          return fn2();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn2) {
          return fn2();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb2) {
      var _this = this;
      this.resetStoreCallbacks.push(cb2);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb2) {
      var _this = this;
      this.clearStoreCallbacks.push(cb2);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options2) {
      var map = this.queryManager.refetchQueries(options2);
      var queries = [];
      var results = [];
      map.forEach(function(result2, obsQuery) {
        queries.push(obsQuery);
        results.push(result2);
      });
      var result = Promise.all(results);
      result.queries = queries;
      result.results = results;
      result.catch(function(error) {
        globalThis.__DEV__ !== false && invariant$3.debug(17, error);
      });
      return result;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: false,
      configurable: true
    });
    return ApolloClient2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
}
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize(string) {
  return string.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast2) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast2.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast2), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    args[_i2 - 1] = arguments[_i2];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i2) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i2 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
const lib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: gql,
  disableExperimentalFragmentVariables,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  get gql() {
    return gql;
  },
  resetCaches
}, Symbol.toStringTag, { value: "Module" }));
setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
const core$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApolloCache,
  ApolloClient,
  ApolloError,
  ApolloLink,
  get Cache() {
    return Cache;
  },
  DocumentTransform: DocumentTransform$1,
  HttpLink,
  InMemoryCache,
  MissingFieldError,
  get NetworkStatus() {
    return NetworkStatus;
  },
  Observable,
  ObservableQuery,
  checkFetcher,
  concat,
  createHttpLink,
  createSignalIfSupported,
  defaultDataIdFromObject,
  defaultPrinter,
  disableExperimentalFragmentVariables,
  disableFragmentWarnings,
  empty,
  enableExperimentalFragmentVariables,
  execute,
  fallbackHttpConfig,
  from,
  fromError,
  fromPromise,
  get gql() {
    return gql;
  },
  isApolloError,
  isNetworkRequestSettled,
  isReference: isReference$1,
  makeReference: makeReference$1,
  makeVar,
  mergeOptions: mergeOptions$1,
  parseAndCheckHttpResponse,
  resetCaches,
  rewriteURIForGET,
  selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal,
  selectURI,
  serializeFetchParameter,
  setLogVerbosity: setVerbosity,
  split,
  throwServerError,
  toPromise
}, Symbol.toStringTag, { value: "Module" }));
var rehackt = { exports: {} };
(function(module2) {
  module2.exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = void 0;
  module2.exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
  module2.exports.__SERVER_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = void 0;
  Object.assign(module2.exports, reactExports);
})(rehackt);
var rehacktExports = rehackt.exports;
const index$2 = /* @__PURE__ */ getDefaultExportFromCjs(rehacktExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: index$2
}, [rehacktExports]);
var contextKey = canUseSymbol$1 ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  invariant$3("createContext" in React$1, 45);
  var context2 = rehacktExports.createContext[contextKey];
  if (!context2) {
    Object.defineProperty(rehacktExports.createContext, contextKey, {
      value: context2 = rehacktExports.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context2.displayName = "ApolloContext";
  }
  return context2;
}
var resetApolloContext = getApolloContext;
var ApolloConsumer = function(props) {
  var ApolloContext = getApolloContext();
  return rehacktExports.createElement(ApolloContext.Consumer, null, function(context2) {
    invariant$3(context2 && context2.client, 44);
    return props.children(context2.client);
  });
};
var ApolloProvider = function(_a3) {
  var client = _a3.client, children = _a3.children;
  var ApolloContext = getApolloContext();
  var parentContext = rehacktExports.useContext(ApolloContext);
  var context2 = rehacktExports.useMemo(function() {
    return __assign(__assign({}, parentContext), { client: client || parentContext.client });
  }, [parentContext, client]);
  invariant$3(context2.client, 46);
  return rehacktExports.createElement(ApolloContext.Provider, { value: context2 }, children);
};
const context$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ApolloConsumer,
  ApolloProvider,
  getApolloContext,
  resetApolloContext
}, Symbol.toStringTag, { value: "Module" }));
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache$2;
function operationName(type) {
  var name;
  switch (type) {
    case DocumentType.Query:
      name = "Query";
      break;
    case DocumentType.Mutation:
      name = "Mutation";
      break;
    case DocumentType.Subscription:
      name = "Subscription";
      break;
  }
  return name;
}
function parser$1(document2) {
  if (!cache$2) {
    cache$2 = new AutoCleanedWeakCache$1(
      cacheSizes$1.parser || 1e3
      /* defaultCacheSizes.parser */
    );
  }
  var cached = cache$2.get(document2);
  if (cached)
    return cached;
  var variables, type, name;
  invariant$3(!!document2 && !!document2.kind, 61, document2);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i2 = 0, _a3 = document2.definitions; _i2 < _a3.length; _i2++) {
    var x2 = _a3[_i2];
    if (x2.kind === "FragmentDefinition") {
      fragments.push(x2);
      continue;
    }
    if (x2.kind === "OperationDefinition") {
      switch (x2.operation) {
        case "query":
          queries.push(x2);
          break;
        case "mutation":
          mutations.push(x2);
          break;
        case "subscription":
          subscriptions.push(x2);
          break;
      }
    }
  }
  invariant$3(!fragments.length || queries.length || mutations.length || subscriptions.length, 62);
  invariant$3(
    queries.length + mutations.length + subscriptions.length <= 1,
    63,
    document2,
    queries.length,
    subscriptions.length,
    mutations.length
  );
  type = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  invariant$3(definitions.length === 1, 64, document2, definitions.length);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name = definition.name.value;
  } else {
    name = "data";
  }
  var payload = { name, type, variables };
  cache$2.set(document2, payload);
  return payload;
}
parser$1.resetCache = function() {
  cache$2 = void 0;
};
if (globalThis.__DEV__ !== false) {
  registerGlobalCache$1("parser", function() {
    return cache$2 ? cache$2.size : 0;
  });
}
function verifyDocumentType(document2, type) {
  var operation = parser$1(document2);
  var requiredOperationName = operationName(type);
  var usedOperationName = operationName(operation.type);
  invariant$3(
    operation.type === type,
    65,
    requiredOperationName,
    requiredOperationName,
    usedOperationName
  );
}
const parser$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get DocumentType() {
    return DocumentType;
  },
  operationName,
  parser: parser$1,
  verifyDocumentType
}, Symbol.toStringTag, { value: "Module" }));
var QUERY_REFERENCE_SYMBOL = Symbol();
var PROMISE_SYMBOL = Symbol();
function wrapQueryRef(internalQueryRef) {
  var _a3;
  var ref = (_a3 = {
    toPromise: function() {
      return getWrappedPromise(ref).then(function() {
        return ref;
      });
    }
  }, _a3[QUERY_REFERENCE_SYMBOL] = internalQueryRef, _a3[PROMISE_SYMBOL] = internalQueryRef.promise, _a3);
  return ref;
}
function assertWrappedQueryRef(queryRef) {
  invariant$3(!queryRef || QUERY_REFERENCE_SYMBOL in queryRef, 60);
}
function getWrappedPromise(queryRef) {
  var internalQueryRef = unwrapQueryRef(queryRef);
  return internalQueryRef.promise.status === "fulfilled" ? internalQueryRef.promise : queryRef[PROMISE_SYMBOL];
}
function unwrapQueryRef(queryRef) {
  return queryRef[QUERY_REFERENCE_SYMBOL];
}
function updateWrappedQueryRef(queryRef, promise) {
  queryRef[PROMISE_SYMBOL] = promise;
}
var OBSERVED_CHANGED_OPTIONS = [
  "canonizeResults",
  "context",
  "errorPolicy",
  "fetchPolicy",
  "refetchWritePolicy",
  "returnPartialData"
];
var InternalQueryReference = (
  /** @class */
  function() {
    function InternalQueryReference2(observable, options2) {
      var _this = this;
      this.key = {};
      this.listeners = /* @__PURE__ */ new Set();
      this.references = 0;
      this.softReferences = 0;
      this.handleNext = this.handleNext.bind(this);
      this.handleError = this.handleError.bind(this);
      this.dispose = this.dispose.bind(this);
      this.observable = observable;
      if (options2.onDispose) {
        this.onDispose = options2.onDispose;
      }
      this.setResult();
      this.subscribeToQuery();
      var startDisposeTimer = function() {
        var _a3;
        if (!_this.references) {
          _this.autoDisposeTimeoutId = setTimeout(_this.dispose, (_a3 = options2.autoDisposeTimeoutMs) !== null && _a3 !== void 0 ? _a3 : 3e4);
        }
      };
      this.promise.then(startDisposeTimer, startDisposeTimer);
    }
    Object.defineProperty(InternalQueryReference2.prototype, "disposed", {
      get: function() {
        return this.subscription.closed;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(InternalQueryReference2.prototype, "watchQueryOptions", {
      get: function() {
        return this.observable.options;
      },
      enumerable: false,
      configurable: true
    });
    InternalQueryReference2.prototype.reinitialize = function() {
      var observable = this.observable;
      var originalFetchPolicy = this.watchQueryOptions.fetchPolicy;
      var avoidNetworkRequests = originalFetchPolicy === "no-cache" || originalFetchPolicy === "standby";
      try {
        if (avoidNetworkRequests) {
          observable.silentSetOptions({ fetchPolicy: "standby" });
        } else {
          observable.resetLastResults();
          observable.silentSetOptions({ fetchPolicy: "cache-first" });
        }
        this.subscribeToQuery();
        if (avoidNetworkRequests) {
          return;
        }
        observable.resetDiff();
        this.setResult();
      } finally {
        observable.silentSetOptions({ fetchPolicy: originalFetchPolicy });
      }
    };
    InternalQueryReference2.prototype.retain = function() {
      var _this = this;
      this.references++;
      clearTimeout(this.autoDisposeTimeoutId);
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.references--;
        setTimeout(function() {
          if (!_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.softRetain = function() {
      var _this = this;
      this.softReferences++;
      var disposed = false;
      return function() {
        if (disposed) {
          return;
        }
        disposed = true;
        _this.softReferences--;
        setTimeout(function() {
          if (!_this.softReferences && !_this.references) {
            _this.dispose();
          }
        });
      };
    };
    InternalQueryReference2.prototype.didChangeOptions = function(watchQueryOptions) {
      var _this = this;
      return OBSERVED_CHANGED_OPTIONS.some(function(option) {
        return option in watchQueryOptions && !equal$2(_this.watchQueryOptions[option], watchQueryOptions[option]);
      });
    };
    InternalQueryReference2.prototype.applyOptions = function(watchQueryOptions) {
      var _a3 = this.watchQueryOptions, currentFetchPolicy = _a3.fetchPolicy, currentCanonizeResults = _a3.canonizeResults;
      if (currentFetchPolicy === "standby" && currentFetchPolicy !== watchQueryOptions.fetchPolicy) {
        this.initiateFetch(this.observable.reobserve(watchQueryOptions));
      } else {
        this.observable.silentSetOptions(watchQueryOptions);
        if (currentCanonizeResults !== watchQueryOptions.canonizeResults) {
          this.result = __assign(__assign({}, this.result), this.observable.getCurrentResult());
          this.promise = createFulfilledPromise$1(this.result);
        }
      }
      return this.promise;
    };
    InternalQueryReference2.prototype.listen = function(listener) {
      var _this = this;
      this.listeners.add(listener);
      return function() {
        _this.listeners.delete(listener);
      };
    };
    InternalQueryReference2.prototype.refetch = function(variables) {
      return this.initiateFetch(this.observable.refetch(variables));
    };
    InternalQueryReference2.prototype.fetchMore = function(options2) {
      return this.initiateFetch(this.observable.fetchMore(options2));
    };
    InternalQueryReference2.prototype.dispose = function() {
      this.subscription.unsubscribe();
      this.onDispose();
    };
    InternalQueryReference2.prototype.onDispose = function() {
    };
    InternalQueryReference2.prototype.handleNext = function(result) {
      var _a3;
      switch (this.promise.status) {
        case "pending": {
          if (result.data === void 0) {
            result.data = this.result.data;
          }
          this.result = result;
          (_a3 = this.resolve) === null || _a3 === void 0 ? void 0 : _a3.call(this, result);
          break;
        }
        default: {
          if (result.data === this.result.data && result.networkStatus === this.result.networkStatus) {
            return;
          }
          if (result.data === void 0) {
            result.data = this.result.data;
          }
          this.result = result;
          this.promise = createFulfilledPromise$1(result);
          this.deliver(this.promise);
          break;
        }
      }
    };
    InternalQueryReference2.prototype.handleError = function(error) {
      var _a3;
      this.subscription.unsubscribe();
      this.subscription = this.observable.resubscribeAfterError(this.handleNext, this.handleError);
      switch (this.promise.status) {
        case "pending": {
          (_a3 = this.reject) === null || _a3 === void 0 ? void 0 : _a3.call(this, error);
          break;
        }
        default: {
          this.promise = createRejectedPromise$1(error);
          this.deliver(this.promise);
        }
      }
    };
    InternalQueryReference2.prototype.deliver = function(promise) {
      this.listeners.forEach(function(listener) {
        return listener(promise);
      });
    };
    InternalQueryReference2.prototype.initiateFetch = function(returnedPromise) {
      var _this = this;
      this.promise = this.createPendingPromise();
      this.promise.catch(function() {
      });
      returnedPromise.then(function() {
        setTimeout(function() {
          var _a3;
          if (_this.promise.status === "pending") {
            _this.result = _this.observable.getCurrentResult();
            (_a3 = _this.resolve) === null || _a3 === void 0 ? void 0 : _a3.call(_this, _this.result);
          }
        });
      }).catch(function() {
      });
      return returnedPromise;
    };
    InternalQueryReference2.prototype.subscribeToQuery = function() {
      var _this = this;
      this.subscription = this.observable.filter(function(result) {
        return !equal$2(result.data, {}) && !equal$2(result, _this.result);
      }).subscribe(this.handleNext, this.handleError);
    };
    InternalQueryReference2.prototype.setResult = function() {
      var result = this.observable.getCurrentResult(false);
      if (equal$2(result, this.result)) {
        return;
      }
      this.result = result;
      this.promise = result.data && (!result.partial || this.watchQueryOptions.returnPartialData) ? createFulfilledPromise$1(result) : this.createPendingPromise();
    };
    InternalQueryReference2.prototype.createPendingPromise = function() {
      var _this = this;
      return wrapPromiseWithState$1(new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      }));
    };
    return InternalQueryReference2;
  }()
);
var SuspenseCache = (
  /** @class */
  function() {
    function SuspenseCache2(options2) {
      if (options2 === void 0) {
        options2 = /* @__PURE__ */ Object.create(null);
      }
      this.queryRefs = new Trie(canUseWeakMap$1);
      this.options = options2;
    }
    SuspenseCache2.prototype.getQueryRef = function(cacheKey, createObservable) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      if (!ref.current) {
        ref.current = new InternalQueryReference(createObservable(), {
          autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,
          onDispose: function() {
            delete ref.current;
          }
        });
      }
      return ref.current;
    };
    SuspenseCache2.prototype.add = function(cacheKey, queryRef) {
      var ref = this.queryRefs.lookupArray(cacheKey);
      ref.current = queryRef;
    };
    return SuspenseCache2;
  }()
);
var suspenseCacheSymbol = Symbol.for("apollo.suspenseCache");
function getSuspenseCache(client) {
  var _a3;
  if (!client[suspenseCacheSymbol]) {
    client[suspenseCacheSymbol] = new SuspenseCache((_a3 = client.defaultOptions.react) === null || _a3 === void 0 ? void 0 : _a3.suspense);
  }
  return client[suspenseCacheSymbol];
}
const internal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InternalQueryReference,
  assertWrappedQueryRef,
  getSuspenseCache,
  getWrappedPromise,
  unwrapQueryRef,
  updateWrappedQueryRef,
  wrapQueryRef
}, Symbol.toStringTag, { value: "Module" }));
var cache$1 = {};
const require$$1 = /* @__PURE__ */ getAugmentedNamespace(globals$3);
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(lib$2);
const require$$2$1 = /* @__PURE__ */ getAugmentedNamespace(utilities$4);
const require$$4$1 = /* @__PURE__ */ getAugmentedNamespace(lib$3);
const require$$4 = /* @__PURE__ */ getAugmentedNamespace(lib$1);
const require$$8$1 = /* @__PURE__ */ getAugmentedNamespace(lib$4);
const require$$9$1 = /* @__PURE__ */ getAugmentedNamespace(graphql$1);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var globals2 = require$$1;
  var tslib2 = require$$0;
  var optimism2 = require$$5;
  var utilities2 = require$$2$1;
  var caches2 = require$$4$1;
  var equal2 = require$$4;
  var trie2 = require$$8$1;
  var graphql2 = require$$9$1;
  function _interopDefaultLegacy2(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
  }
  var equal__default2 = /* @__PURE__ */ _interopDefaultLegacy2(equal2);
  var getInMemoryCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals2 : void 0;
  var getApolloCacheMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals2 : void 0;
  function _getApolloCacheMemoryInternals2() {
    return {
      cache: {
        fragmentQueryDocuments: getWrapperInformation2(this["getFragmentDoc"])
      }
    };
  }
  function _getInMemoryCacheMemoryInternals2() {
    var fragments = this.config.fragments;
    return tslib2.__assign(tslib2.__assign({}, _getApolloCacheMemoryInternals2.apply(this)), { addTypenameDocumentTransform: transformInfo2(this["addTypenameTransform"]), inMemoryCache: {
      executeSelectionSet: getWrapperInformation2(this["storeReader"]["executeSelectionSet"]),
      executeSubSelectedArray: getWrapperInformation2(this["storeReader"]["executeSubSelectedArray"]),
      maybeBroadcastWatch: getWrapperInformation2(this["maybeBroadcastWatch"])
    }, fragmentRegistry: {
      findFragmentSpreads: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
      lookup: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
      transform: getWrapperInformation2(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
    } });
  }
  function isWrapper2(f3) {
    return !!f3 && "dirtyKey" in f3;
  }
  function getWrapperInformation2(f3) {
    return isWrapper2(f3) ? f3.size : void 0;
  }
  function isDefined2(value) {
    return value != null;
  }
  function transformInfo2(transform) {
    return recurseTransformInfo2(transform).map(function(cache2) {
      return { cache: cache2 };
    });
  }
  function recurseTransformInfo2(transform) {
    return transform ? tslib2.__spreadArray(tslib2.__spreadArray([
      getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
    ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
  }
  function equalByQuery2(query, _a3, _b2, variables) {
    var aData = _a3.data, aRest = tslib2.__rest(_a3, ["data"]);
    var bData = _b2.data, bRest = tslib2.__rest(_b2, ["data"]);
    return equal__default2(aRest, bRest) && equalBySelectionSet2(utilities2.getMainDefinition(query).selectionSet, aData, bData, {
      fragmentMap: utilities2.createFragmentMap(utilities2.getFragmentDefinitions(query)),
      variables
    });
  }
  function equalBySelectionSet2(selectionSet, aResult, bResult, context2) {
    if (aResult === bResult) {
      return true;
    }
    var seenSelections = /* @__PURE__ */ new Set();
    return selectionSet.selections.every(function(selection) {
      if (seenSelections.has(selection))
        return true;
      seenSelections.add(selection);
      if (!utilities2.shouldInclude(selection, context2.variables))
        return true;
      if (selectionHasNonreactiveDirective2(selection))
        return true;
      if (utilities2.isField(selection)) {
        var resultKey = utilities2.resultKeyNameFromField(selection);
        var aResultChild = aResult && aResult[resultKey];
        var bResultChild = bResult && bResult[resultKey];
        var childSelectionSet = selection.selectionSet;
        if (!childSelectionSet) {
          return equal__default2(aResultChild, bResultChild);
        }
        var aChildIsArray = Array.isArray(aResultChild);
        var bChildIsArray = Array.isArray(bResultChild);
        if (aChildIsArray !== bChildIsArray)
          return false;
        if (aChildIsArray && bChildIsArray) {
          var length_1 = aResultChild.length;
          if (bResultChild.length !== length_1) {
            return false;
          }
          for (var i2 = 0; i2 < length_1; ++i2) {
            if (!equalBySelectionSet2(childSelectionSet, aResultChild[i2], bResultChild[i2], context2)) {
              return false;
            }
          }
          return true;
        }
        return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context2);
      } else {
        var fragment = utilities2.getFragmentFromSelection(selection, context2.fragmentMap);
        if (fragment) {
          if (selectionHasNonreactiveDirective2(fragment))
            return true;
          return equalBySelectionSet2(
            fragment.selectionSet,
            aResult,
            bResult,
            context2
          );
        }
      }
    });
  }
  function selectionHasNonreactiveDirective2(selection) {
    return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
  }
  function directiveIsNonreactive2(dir) {
    return dir.name.value === "nonreactive";
  }
  var ApolloCache2 = function() {
    function ApolloCache3() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = optimism2.wrap(utilities2.getFragmentQueryDocument, {
        max: utilities2.cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
        cache: caches2.WeakCache
      });
    }
    ApolloCache3.prototype.batch = function(options2) {
      var _this = this;
      var optimisticId = typeof options2.optimistic === "string" ? options2.optimistic : options2.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options2.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache3.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
      this.performTransaction(transaction, optimisticId);
    };
    ApolloCache3.prototype.transformDocument = function(document2) {
      return document2;
    };
    ApolloCache3.prototype.transformForLink = function(document2) {
      return document2;
    };
    ApolloCache3.prototype.identify = function(object) {
      return;
    };
    ApolloCache3.prototype.gc = function() {
      return [];
    };
    ApolloCache3.prototype.modify = function(options2) {
      return false;
    };
    ApolloCache3.prototype.readQuery = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options2.optimistic;
      }
      return this.read(tslib2.__assign(tslib2.__assign({}, options2), { rootId: options2.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache3.prototype.watchFragment = function(options2) {
      var _this = this;
      var fragment = options2.fragment, fragmentName = options2.fragmentName, from2 = options2.from, _a3 = options2.optimistic, optimistic = _a3 === void 0 ? true : _a3, otherOptions = tslib2.__rest(options2, ["fragment", "fragmentName", "from", "optimistic"]);
      var query = this.getFragmentDoc(fragment, fragmentName);
      var diffOptions = tslib2.__assign(tslib2.__assign({}, otherOptions), { returnPartialData: true, id: typeof from2 === "string" ? from2 : this.identify(from2), query, optimistic });
      var latestDiff;
      return new utilities2.Observable(function(observer) {
        return _this.watch(tslib2.__assign(tslib2.__assign({}, diffOptions), { immediate: true, callback: function(diff2) {
          if (latestDiff && equalByQuery2(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data: diff2.result })) {
            return;
          }
          var result = {
            data: diff2.result,
            complete: !!diff2.complete
          };
          if (diff2.missing) {
            result.missing = utilities2.mergeDeepArray(diff2.missing.map(function(error) {
              return error.missing;
            }));
          }
          latestDiff = diff2;
          observer.next(result);
        } }));
      });
    };
    ApolloCache3.prototype.readFragment = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options2.optimistic;
      }
      return this.read(tslib2.__assign(tslib2.__assign({}, options2), { query: this.getFragmentDoc(options2.fragment, options2.fragmentName), rootId: options2.id, optimistic }));
    };
    ApolloCache3.prototype.writeQuery = function(_a3) {
      var id2 = _a3.id, data = _a3.data, options2 = tslib2.__rest(_a3, ["id", "data"]);
      return this.write(Object.assign(options2, {
        dataId: id2 || "ROOT_QUERY",
        result: data
      }));
    };
    ApolloCache3.prototype.writeFragment = function(_a3) {
      var id2 = _a3.id, data = _a3.data, fragment = _a3.fragment, fragmentName = _a3.fragmentName, options2 = tslib2.__rest(_a3, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options2, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id2,
        result: data
      }));
    };
    ApolloCache3.prototype.updateQuery = function(options2, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options2);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeQuery(tslib2.__assign(tslib2.__assign({}, options2), { data }));
          return data;
        }
      });
    };
    ApolloCache3.prototype.updateFragment = function(options2, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options2);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeFragment(tslib2.__assign(tslib2.__assign({}, options2), { data }));
          return data;
        }
      });
    };
    return ApolloCache3;
  }();
  if (globalThis.__DEV__ !== false) {
    ApolloCache2.prototype.getMemoryInternals = getApolloCacheMemoryInternals2;
  }
  exports.Cache = void 0;
  /* @__PURE__ */ (function(Cache2) {
  })(exports.Cache || (exports.Cache = {}));
  var MissingFieldError2 = function(_super) {
    tslib2.__extends(MissingFieldError3, _super);
    function MissingFieldError3(message, path, query, variables) {
      var _a3;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i2 = _this.path.length - 1; i2 >= 0; --i2) {
          _this.missing = (_a3 = {}, _a3[_this.path[i2]] = _this.missing, _a3);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError3.prototype;
      return _this;
    }
    return MissingFieldError3;
  }(Error);
  var hasOwn2 = Object.prototype.hasOwnProperty;
  function isNullish2(value) {
    return value === null || value === void 0;
  }
  function defaultDataIdFromObject2(_a3, context2) {
    var __typename = _a3.__typename, id2 = _a3.id, _id = _a3._id;
    if (typeof __typename === "string") {
      if (context2) {
        context2.keyObject = !isNullish2(id2) ? { id: id2 } : !isNullish2(_id) ? { _id } : void 0;
      }
      if (isNullish2(id2) && !isNullish2(_id)) {
        id2 = _id;
      }
      if (!isNullish2(id2)) {
        return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
      }
    }
  }
  var defaultConfig2 = {
    dataIdFromObject: defaultDataIdFromObject2,
    addTypename: true,
    resultCaching: true,
    canonizeResults: false
  };
  function normalizeConfig2(config) {
    return utilities2.compact(defaultConfig2, config);
  }
  function shouldCanonizeResults2(config) {
    var value = config.canonizeResults;
    return value === void 0 ? defaultConfig2.canonizeResults : value;
  }
  function getTypenameFromStoreObject2(store, objectOrReference) {
    return utilities2.isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
  }
  var TypeOrFieldNameRegExp2 = /^[_a-z][_0-9a-z]*/i;
  function fieldNameFromStoreName2(storeFieldName) {
    var match = storeFieldName.match(TypeOrFieldNameRegExp2);
    return match ? match[0] : storeFieldName;
  }
  function selectionSetMatchesResult2(selectionSet, result, variables) {
    if (utilities2.isNonNullObject(result)) {
      return utilities2.isArray(result) ? result.every(function(item) {
        return selectionSetMatchesResult2(selectionSet, item, variables);
      }) : selectionSet.selections.every(function(field) {
        if (utilities2.isField(field) && utilities2.shouldInclude(field, variables)) {
          var key = utilities2.resultKeyNameFromField(field);
          return hasOwn2.call(result, key) && (!field.selectionSet || selectionSetMatchesResult2(field.selectionSet, result[key], variables));
        }
        return true;
      });
    }
    return false;
  }
  function storeValueIsStoreObject2(value) {
    return utilities2.isNonNullObject(value) && !utilities2.isReference(value) && !utilities2.isArray(value);
  }
  function makeProcessedFieldsMerger2() {
    return new utilities2.DeepMerger();
  }
  function extractFragmentContext2(document2, fragments) {
    var fragmentMap = utilities2.createFragmentMap(utilities2.getFragmentDefinitions(document2));
    return {
      fragmentMap,
      lookupFragment: function(name) {
        var def = fragmentMap[name];
        if (!def && fragments) {
          def = fragments.lookup(name);
        }
        return def || null;
      }
    };
  }
  var DELETE2 = /* @__PURE__ */ Object.create(null);
  var delModifier2 = function() {
    return DELETE2;
  };
  var INVALIDATE2 = /* @__PURE__ */ Object.create(null);
  exports.EntityStore = function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return utilities2.maybeDeepFreeze(utilities2.isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return utilities2.isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return utilities2.makeReference(objOrIdOrRef);
        }
        if (utilities2.isReference(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id2 = _this.policies.identify(objOrIdOrRef)[0];
        if (id2) {
          var ref = utilities2.makeReference(id2);
          if (mergeIntoStore) {
            _this.merge(id2, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return tslib2.__assign({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn2.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn2.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn2.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer2) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn2.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer2) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (utilities2.isReference(older))
        older = older.__ref;
      if (utilities2.isReference(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      globals2.invariant(typeof dataId === "string", 1);
      var merged = new utilities2.DeepMerger(storeObjectReconciler2).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName2(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer2)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE: DELETE2,
          INVALIDATE: INVALIDATE2,
          isReference: utilities2.isReference,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || utilities2.makeReference(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName2(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier2 ? DELETE2 : modify(utilities2.maybeDeepFreeze(fieldValue), tslib2.__assign(tslib2.__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE2) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE2)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && globals2.invariant.warn(2, ref);
                      return true;
                    }
                  };
                  if (utilities2.isReference(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i2 = 0, newValue_1 = newValue; _i2 < newValue_1.length; _i2++) {
                      var value = newValue_1[_i2];
                      if (utilities2.isReference(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id2 = _this.policies.identify(value)[0];
                          if (id2) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && globals2.invariant.warn(3, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer2) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a3;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a3 = {}, _a3[storeFieldName] = delModifier2, _a3) : delModifier2);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options2, limit) {
      var evicted = false;
      if (options2.id) {
        if (hasOwn2.call(this.data, options2.id)) {
          evicted = this.delete(options2.id, options2.fieldName, options2.args);
        }
        if (this instanceof Layer2 && this !== limit) {
          evicted = this.parent.evict(options2, limit) || evicted;
        }
        if (options2.fieldName || evicted) {
          this.group.dirty(options2.id, options2.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id2) {
        if (!hasOwn2.call(_this.policies.rootTypenamesById, id2)) {
          extraRootIds.push(id2);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn2.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = tslib2.__rest(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count2 = --this.rootIds[rootId];
        if (!count2)
          delete this.rootIds[rootId];
        return count2;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer2) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot = this.toObject();
      ids.forEach(function(id2) {
        if (hasOwn2.call(snapshot, id2)) {
          Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
          delete snapshot[id2];
        }
      });
      var idsToRemove = Object.keys(snapshot);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer2)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id2) {
          return root_1.delete(id2);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn2.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root2 = this.data[dataId];
        if (!root2)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root2]);
        workSet_1.forEach(function(obj) {
          if (utilities2.isReference(obj)) {
            found_1[obj.__ref] = true;
          }
          if (utilities2.isNonNullObject(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (utilities2.isNonNullObject(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }();
  var CacheGroup2 = function() {
    function CacheGroup3(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup3.prototype.resetCaching = function() {
      this.d = this.caching ? optimism2.dep() : null;
      this.keyMaker = new trie2.Trie(utilities2.canUseWeakMap);
    };
    CacheGroup3.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey2(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName2(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey2(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup3.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey2(dataId, storeFieldName),
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup3;
  }();
  function makeDepKey2(dataId, storeFieldName) {
    return storeFieldName + "#" + dataId;
  }
  function maybeDependOnExistenceOfEntity2(store, entityId) {
    if (supportsResultCaching2(store)) {
      store.group.depend(entityId, "__exists");
    }
  }
  (function(EntityStore2) {
    var Root = function(_super) {
      tslib2.__extends(Root2, _super);
      function Root2(_a3) {
        var policies = _a3.policies, _b2 = _a3.resultCaching, resultCaching = _b2 === void 0 ? true : _b2, seed = _a3.seed;
        var _this = _super.call(this, policies, new CacheGroup2(resultCaching)) || this;
        _this.stump = new Stump2(_this);
        _this.storageTrie = new trie2.Trie(utilities2.canUseWeakMap);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root2.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root2.prototype.removeLayer = function() {
        return this;
      };
      Root2.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root2;
    }(EntityStore2);
    EntityStore2.Root = Root;
  })(exports.EntityStore || (exports.EntityStore = {}));
  var Layer2 = function(_super) {
    tslib2.__extends(Layer3, _super);
    function Layer3(id2, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id2;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer3.prototype.addLayer = function(layerId, replay) {
      return new Layer3(layerId, this, replay, this.group);
    };
    Layer3.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal2.equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer3.prototype.toObject = function() {
      return tslib2.__assign(tslib2.__assign({}, this.parent.toObject()), this.data);
    };
    Layer3.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn2.call(this.data, dataId) ? tslib2.__assign(tslib2.__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer3.prototype.getStorage = function() {
      var p3 = this.parent;
      while (p3.parent)
        p3 = p3.parent;
      return p3.getStorage.apply(
        p3,
        arguments
      );
    };
    return Layer3;
  }(exports.EntityStore);
  var Stump2 = function(_super) {
    tslib2.__extends(Stump3, _super);
    function Stump3(root2) {
      return _super.call(this, "EntityStore.Stump", root2, function() {
      }, new CacheGroup2(root2.group.caching, root2.group)) || this;
    }
    Stump3.prototype.removeLayer = function() {
      return this;
    };
    Stump3.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump3;
  }(Layer2);
  function storeObjectReconciler2(existingObject, incomingObject, property) {
    var existingValue = existingObject[property];
    var incomingValue = incomingObject[property];
    return equal2.equal(existingValue, incomingValue) ? existingValue : incomingValue;
  }
  function supportsResultCaching2(store) {
    return !!(store instanceof exports.EntityStore && store.group.caching);
  }
  function shallowCopy2(value) {
    if (utilities2.isNonNullObject(value)) {
      return utilities2.isArray(value) ? value.slice(0) : tslib2.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
    }
    return value;
  }
  var ObjectCanon2 = function() {
    function ObjectCanon3() {
      this.known = new (utilities2.canUseWeakSet ? WeakSet : Set)();
      this.pool = new trie2.Trie(utilities2.canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon3.prototype.isKnown = function(value) {
      return utilities2.isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon3.prototype.pass = function(value) {
      if (utilities2.isNonNullObject(value)) {
        var copy = shallowCopy2(value);
        this.passes.set(copy, value);
        return copy;
      }
      return value;
    };
    ObjectCanon3.prototype.admit = function(value) {
      var _this = this;
      if (utilities2.isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i2) {
                obj_1[key] = array_1[firstValueIndex_1 + i2];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon3.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon3;
  }();
  function execSelectionSetKeyArgs2(options2) {
    return [
      options2.selectionSet,
      options2.objectOrReference,
      options2.context,
      options2.context.canonizeResults
    ];
  }
  var StoreReader2 = function() {
    function StoreReader3(config) {
      var _this = this;
      this.knownResults = new (utilities2.canUseWeakMap ? WeakMap : Map)();
      this.config = utilities2.compact(config, {
        addTypename: config.addTypename !== false,
        canonizeResults: shouldCanonizeResults2(config)
      });
      this.canon = config.canon || new ObjectCanon2();
      this.executeSelectionSet = optimism2.wrap(function(options2) {
        var _a3;
        var canonizeResults = options2.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs2(options2);
        peekArgs[3] = !canonizeResults;
        var other = (_a3 = _this.executeSelectionSet).peek.apply(_a3, peekArgs);
        if (other) {
          if (canonizeResults) {
            return tslib2.__assign(tslib2.__assign({}, other), {
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity2(options2.context.store, options2.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options2);
      }, {
        max: this.config.resultCacheMaxSize || utilities2.cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: execSelectionSetKeyArgs2,
        makeCacheKey: function(selectionSet, parent, context2, canonizeResults) {
          if (supportsResultCaching2(context2.store)) {
            return context2.store.makeCacheKey(selectionSet, utilities2.isReference(parent) ? parent.__ref : parent, context2.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = optimism2.wrap(function(options2) {
        maybeDependOnExistenceOfEntity2(options2.context.store, options2.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options2);
      }, {
        max: this.config.resultCacheMaxSize || utilities2.cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(_a3) {
          var field = _a3.field, array = _a3.array, context2 = _a3.context;
          if (supportsResultCaching2(context2.store)) {
            return context2.store.makeCacheKey(field, array, context2.varString);
          }
        }
      });
    }
    StoreReader3.prototype.resetCanon = function() {
      this.canon = new ObjectCanon2();
    };
    StoreReader3.prototype.diffQueryAgainstStore = function(_a3) {
      var store = _a3.store, query = _a3.query, _b2 = _a3.rootId, rootId = _b2 === void 0 ? "ROOT_QUERY" : _b2, variables = _a3.variables, _c2 = _a3.returnPartialData, returnPartialData = _c2 === void 0 ? true : _c2, _d = _a3.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = tslib2.__assign(tslib2.__assign({}, utilities2.getDefaultValues(utilities2.getQueryDefinition(query))), variables);
      var rootRef = utilities2.makeReference(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: utilities2.getMainDefinition(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: tslib2.__assign({ store, query, policies, variables, varString: utilities2.canonicalStringify(variables), canonizeResults }, extractFragmentContext2(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError2(firstMissing2(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader3.prototype.isFresh = function(result, parent, selectionSet, context2) {
      if (supportsResultCaching2(context2.store) && this.knownResults.get(result) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context2,
          this.canon.isKnown(result)
        );
        if (latest && result === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader3.prototype.execSelectionSetImpl = function(_a3) {
      var _this = this;
      var selectionSet = _a3.selectionSet, objectOrReference = _a3.objectOrReference, enclosingRef = _a3.enclosingRef, context2 = _a3.context;
      if (utilities2.isReference(objectOrReference) && !context2.policies.rootTypenamesById[objectOrReference.__ref] && !context2.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context2.variables, policies = context2.policies, store = context2.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new utilities2.DeepMerger();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result2, resultName) {
        var _a4;
        if (result2.missing) {
          missing = missingMerger.merge(missing, (_a4 = {}, _a4[resultName] = result2.missing, _a4));
        }
        return result2.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a4, _b2;
        if (!utilities2.shouldInclude(selection, variables))
          return;
        if (utilities2.isField(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context2.variables,
            from: objectOrReference
          }, context2);
          var resultName = utilities2.resultKeyNameFromField(selection);
          if (fieldValue === void 0) {
            if (!utilities2.addTypenameToDocument.added(selection)) {
              missing = missingMerger.merge(missing, (_a4 = {}, _a4[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(utilities2.isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a4));
            }
          } else if (utilities2.isArray(fieldValue)) {
            if (fieldValue.length > 0) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context: context2
              }), resultName);
            }
          } else if (!selection.selectionSet) {
            if (context2.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: utilities2.isReference(fieldValue) ? fieldValue : enclosingRef,
              context: context2
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b2 = {}, _b2[resultName] = fieldValue, _b2));
          }
        } else {
          var fragment = utilities2.getFragmentFromSelection(selection, context2.lookupFragment);
          if (!fragment && selection.kind === graphql2.Kind.FRAGMENT_SPREAD) {
            throw globals2.newInvariantError(9, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result = utilities2.mergeDeepArray(objectsToMerge);
      var finalResult = { result, missing };
      var frozen = context2.canonizeResults ? this.canon.admit(finalResult) : utilities2.maybeDeepFreeze(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader3.prototype.execSubSelectedArrayImpl = function(_a3) {
      var _this = this;
      var field = _a3.field, array = _a3.array, enclosingRef = _a3.enclosingRef, context2 = _a3.context;
      var missing;
      var missingMerger = new utilities2.DeepMerger();
      function handleMissing(childResult, i2) {
        var _a4;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a4 = {}, _a4[i2] = childResult.missing, _a4));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context2.store.canRead);
      }
      array = array.map(function(item, i2) {
        if (item === null) {
          return null;
        }
        if (utilities2.isArray(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context: context2
          }), i2);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: utilities2.isReference(item) ? item : enclosingRef,
            context: context2
          }), i2);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue2(context2.store, field, item);
        }
        return item;
      });
      return {
        result: context2.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader3;
  }();
  function firstMissing2(tree) {
    try {
      JSON.stringify(tree, function(_2, value) {
        if (typeof value === "string")
          throw value;
        return value;
      });
    } catch (result) {
      return result;
    }
  }
  function assertSelectionSetForIdValue2(store, field, fieldValue) {
    if (!field.selectionSet) {
      var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
      workSet_1.forEach(function(value) {
        if (utilities2.isNonNullObject(value)) {
          globals2.invariant(
            !utilities2.isReference(value),
            10,
            getTypenameFromStoreObject2(store, value),
            field.name.value
          );
          Object.values(value).forEach(workSet_1.add, workSet_1);
        }
      });
    }
  }
  var cacheSlot2 = new optimism2.Slot();
  var cacheInfoMap2 = /* @__PURE__ */ new WeakMap();
  function getCacheInfo2(cache2) {
    var info = cacheInfoMap2.get(cache2);
    if (!info) {
      cacheInfoMap2.set(cache2, info = {
        vars: /* @__PURE__ */ new Set(),
        dep: optimism2.dep()
      });
    }
    return info;
  }
  function forgetCache2(cache2) {
    getCacheInfo2(cache2).vars.forEach(function(rv) {
      return rv.forgetCache(cache2);
    });
  }
  function recallCache2(cache2) {
    getCacheInfo2(cache2).vars.forEach(function(rv) {
      return rv.attachCache(cache2);
    });
  }
  function makeVar2(value) {
    var caches3 = /* @__PURE__ */ new Set();
    var listeners = /* @__PURE__ */ new Set();
    var rv = function(newValue) {
      if (arguments.length > 0) {
        if (value !== newValue) {
          value = newValue;
          caches3.forEach(function(cache3) {
            getCacheInfo2(cache3).dep.dirty(rv);
            broadcast2(cache3);
          });
          var oldListeners = Array.from(listeners);
          listeners.clear();
          oldListeners.forEach(function(listener) {
            return listener(value);
          });
        }
      } else {
        var cache2 = cacheSlot2.getValue();
        if (cache2) {
          attach(cache2);
          getCacheInfo2(cache2).dep(rv);
        }
      }
      return value;
    };
    rv.onNextChange = function(listener) {
      listeners.add(listener);
      return function() {
        listeners.delete(listener);
      };
    };
    var attach = rv.attachCache = function(cache2) {
      caches3.add(cache2);
      getCacheInfo2(cache2).vars.add(rv);
      return rv;
    };
    rv.forgetCache = function(cache2) {
      return caches3.delete(cache2);
    };
    return rv;
  }
  function broadcast2(cache2) {
    if (cache2.broadcastWatches) {
      cache2.broadcastWatches();
    }
  }
  var specifierInfoCache2 = /* @__PURE__ */ Object.create(null);
  function lookupSpecifierInfo2(spec) {
    var cacheKey = JSON.stringify(spec);
    return specifierInfoCache2[cacheKey] || (specifierInfoCache2[cacheKey] = /* @__PURE__ */ Object.create(null));
  }
  function keyFieldsFnFromSpecifier2(specifier) {
    var info = lookupSpecifierInfo2(specifier);
    return info.keyFieldsFn || (info.keyFieldsFn = function(object, context2) {
      var extract = function(from2, key) {
        return context2.readField(key, from2);
      };
      var keyObject = context2.keyObject = collectSpecifierPaths2(specifier, function(schemaKeyPath) {
        var extracted = extractKeyPath2(
          context2.storeObject,
          schemaKeyPath,
          extract
        );
        if (extracted === void 0 && object !== context2.storeObject && hasOwn2.call(object, schemaKeyPath[0])) {
          extracted = extractKeyPath2(object, schemaKeyPath, extractKey2);
        }
        globals2.invariant(extracted !== void 0, 4, schemaKeyPath.join("."), object);
        return extracted;
      });
      return "".concat(context2.typename, ":").concat(JSON.stringify(keyObject));
    });
  }
  function keyArgsFnFromSpecifier2(specifier) {
    var info = lookupSpecifierInfo2(specifier);
    return info.keyArgsFn || (info.keyArgsFn = function(args, _a3) {
      var field = _a3.field, variables = _a3.variables, fieldName = _a3.fieldName;
      var collected = collectSpecifierPaths2(specifier, function(keyPath) {
        var firstKey = keyPath[0];
        var firstChar = firstKey.charAt(0);
        if (firstChar === "@") {
          if (field && utilities2.isNonEmptyArray(field.directives)) {
            var directiveName_1 = firstKey.slice(1);
            var d3 = field.directives.find(function(d4) {
              return d4.name.value === directiveName_1;
            });
            var directiveArgs = d3 && utilities2.argumentsObjectFromField(d3, variables);
            return directiveArgs && extractKeyPath2(
              directiveArgs,
              keyPath.slice(1)
            );
          }
          return;
        }
        if (firstChar === "$") {
          var variableName = firstKey.slice(1);
          if (variables && hasOwn2.call(variables, variableName)) {
            var varKeyPath = keyPath.slice(0);
            varKeyPath[0] = variableName;
            return extractKeyPath2(variables, varKeyPath);
          }
          return;
        }
        if (args) {
          return extractKeyPath2(args, keyPath);
        }
      });
      var suffix = JSON.stringify(collected);
      if (args || suffix !== "{}") {
        fieldName += ":" + suffix;
      }
      return fieldName;
    });
  }
  function collectSpecifierPaths2(specifier, extractor) {
    var merger = new utilities2.DeepMerger();
    return getSpecifierPaths2(specifier).reduce(function(collected, path) {
      var _a3;
      var toMerge = extractor(path);
      if (toMerge !== void 0) {
        for (var i2 = path.length - 1; i2 >= 0; --i2) {
          toMerge = (_a3 = {}, _a3[path[i2]] = toMerge, _a3);
        }
        collected = merger.merge(collected, toMerge);
      }
      return collected;
    }, /* @__PURE__ */ Object.create(null));
  }
  function getSpecifierPaths2(spec) {
    var info = lookupSpecifierInfo2(spec);
    if (!info.paths) {
      var paths_1 = info.paths = [];
      var currentPath_1 = [];
      spec.forEach(function(s2, i2) {
        if (utilities2.isArray(s2)) {
          getSpecifierPaths2(s2).forEach(function(p3) {
            return paths_1.push(currentPath_1.concat(p3));
          });
          currentPath_1.length = 0;
        } else {
          currentPath_1.push(s2);
          if (!utilities2.isArray(spec[i2 + 1])) {
            paths_1.push(currentPath_1.slice(0));
            currentPath_1.length = 0;
          }
        }
      });
    }
    return info.paths;
  }
  function extractKey2(object, key) {
    return object[key];
  }
  function extractKeyPath2(object, path, extract) {
    extract = extract || extractKey2;
    return normalize2(path.reduce(function reducer(obj, key) {
      return utilities2.isArray(obj) ? obj.map(function(child) {
        return reducer(child, key);
      }) : obj && extract(obj, key);
    }, object));
  }
  function normalize2(value) {
    if (utilities2.isNonNullObject(value)) {
      if (utilities2.isArray(value)) {
        return value.map(normalize2);
      }
      return collectSpecifierPaths2(Object.keys(value).sort(), function(path) {
        return extractKeyPath2(value, path);
      });
    }
    return value;
  }
  function argsFromFieldSpecifier2(spec) {
    return spec.args !== void 0 ? spec.args : spec.field ? utilities2.argumentsObjectFromField(spec.field, spec.variables) : null;
  }
  var nullKeyFieldsFn2 = function() {
    return void 0;
  };
  var simpleKeyArgsFn2 = function(_args, context2) {
    return context2.fieldName;
  };
  var mergeTrueFn2 = function(existing, incoming, _a3) {
    var mergeObjects = _a3.mergeObjects;
    return mergeObjects(existing, incoming);
  };
  var mergeFalseFn2 = function(_2, incoming) {
    return incoming;
  };
  var Policies2 = function() {
    function Policies3(config) {
      this.config = config;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = tslib2.__assign({ dataIdFromObject: defaultDataIdFromObject2 }, config);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config.possibleTypes) {
        this.addPossibleTypes(config.possibleTypes);
      }
      if (config.typePolicies) {
        this.addTypePolicies(config.typePolicies);
      }
    }
    Policies3.prototype.identify = function(object, partialContext) {
      var _a3;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a3 = partialContext.storeObject) === null || _a3 === void 0 ? void 0 : _a3.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context2 = tslib2.__assign(tslib2.__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options2 = normalizeReadFieldOptions2(arguments, storeObject);
        return policies.readField(options2, {
          store: policies.cache["data"],
          variables: options2.variables
        });
      } });
      var id2;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      while (keyFn) {
        var specifierOrId = keyFn(tslib2.__assign(tslib2.__assign({}, object), storeObject), context2);
        if (utilities2.isArray(specifierOrId)) {
          keyFn = keyFieldsFnFromSpecifier2(specifierOrId);
        } else {
          id2 = specifierOrId;
          break;
        }
      }
      id2 = id2 ? String(id2) : void 0;
      return context2.keyObject ? [id2, context2.keyObject] : [id2];
    };
    Policies3.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a3 = typePolicies[typename], queryType = _a3.queryType, mutationType = _a3.mutationType, subscriptionType = _a3.subscriptionType, incoming = tslib2.__rest(_a3, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn2.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies3.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge2) {
        existing2.merge = typeof merge2 === "function" ? merge2 : merge2 === true ? mergeTrueFn2 : merge2 === false ? mergeFalseFn2 : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = keyFields === false ? nullKeyFieldsFn2 : utilities2.isArray(keyFields) ? keyFieldsFnFromSpecifier2(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge2 = incoming2.merge;
            existing2.keyFn = keyArgs === false ? simpleKeyArgsFn2 : utilities2.isArray(keyArgs) ? keyArgsFnFromSpecifier2(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read === "function") {
              existing2.read = read;
            }
            setMerge(existing2, merge2);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn2;
          }
        });
      }
    };
    Policies3.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        globals2.invariant(!old || old === which, 5, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies3.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match = subtype.match(TypeOrFieldNameRegExp2);
          if (!match || match[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies3.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn2.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a3 = _this.getTypePolicy(supertype), fields = _a3.fields, rest = tslib2.__rest(_a3, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies3.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies3.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies3.prototype.fragmentMatches = function(fragment, typename, result, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i2 = 0; i2 < workQueue_1.length; ++i2) {
          var supertypeSet = workQueue_1[i2];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && globals2.invariant.warn(6, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && i2 === workQueue_1.length - 1 && selectionSetMatchesResult2(fragment.selectionSet, result, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match = typename.match(regExp);
              if (match && match[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies3.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies3.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context2 = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier2(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context2);
          if (utilities2.isArray(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier2(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? utilities2.storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : utilities2.getStoreKeyName(fieldName, argsFromFieldSpecifier2(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName2(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies3.prototype.readField = function(options2, context2) {
      var objectOrReference = options2.from;
      if (!objectOrReference)
        return;
      var nameOrField = options2.field || options2.fieldName;
      if (!nameOrField)
        return;
      if (options2.typename === void 0) {
        var typename = context2.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options2.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options2);
      var fieldName = fieldNameFromStoreName2(storeFieldName);
      var existing = context2.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options2.typename, fieldName, false);
      var read = policy && policy.read;
      if (read) {
        var readOptions = makeFieldFunctionOptions2(this, objectOrReference, options2, context2, context2.store.getStorage(utilities2.isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot2.withValue(this.cache, read, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies3.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies3.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge2 = policy && policy.merge;
      if (!merge2 && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge2 = policy && policy.merge;
      }
      return merge2;
    };
    Policies3.prototype.runMergeFunction = function(existing, incoming, _a3, context2, storage) {
      var field = _a3.field, typename = _a3.typename, merge2 = _a3.merge;
      if (merge2 === mergeTrueFn2) {
        return makeMergeObjectsFunction2(context2.store)(existing, incoming);
      }
      if (merge2 === mergeFalseFn2) {
        return incoming;
      }
      if (context2.overwrite) {
        existing = void 0;
      }
      return merge2(existing, incoming, makeFieldFunctionOptions2(
        this,
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context2.variables
        },
        context2,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies3;
  }();
  function makeFieldFunctionOptions2(policies, objectOrReference, fieldSpec, context2, storage) {
    var storeFieldName = policies.getStoreFieldName(fieldSpec);
    var fieldName = fieldNameFromStoreName2(storeFieldName);
    var variables = fieldSpec.variables || context2.variables;
    var _a3 = context2.store, toReference = _a3.toReference, canRead = _a3.canRead;
    return {
      args: argsFromFieldSpecifier2(fieldSpec),
      field: fieldSpec.field || null,
      fieldName,
      storeFieldName,
      variables,
      isReference: utilities2.isReference,
      toReference,
      storage,
      cache: policies.cache,
      canRead,
      readField: function() {
        return policies.readField(normalizeReadFieldOptions2(arguments, objectOrReference, variables), context2);
      },
      mergeObjects: makeMergeObjectsFunction2(context2.store)
    };
  }
  function normalizeReadFieldOptions2(readFieldArgs, objectOrReference, variables) {
    var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
    var options2;
    if (typeof fieldNameOrOptions === "string") {
      options2 = {
        fieldName: fieldNameOrOptions,
        from: argc > 1 ? from2 : objectOrReference
      };
    } else {
      options2 = tslib2.__assign({}, fieldNameOrOptions);
      if (!hasOwn2.call(options2, "from")) {
        options2.from = objectOrReference;
      }
    }
    if (globalThis.__DEV__ !== false && options2.from === void 0) {
      globalThis.__DEV__ !== false && globals2.invariant.warn(7, utilities2.stringifyForDisplay(Array.from(readFieldArgs)));
    }
    if (void 0 === options2.variables) {
      options2.variables = variables;
    }
    return options2;
  }
  function makeMergeObjectsFunction2(store) {
    return function mergeObjects(existing, incoming) {
      if (utilities2.isArray(existing) || utilities2.isArray(incoming)) {
        throw globals2.newInvariantError(8);
      }
      if (utilities2.isNonNullObject(existing) && utilities2.isNonNullObject(incoming)) {
        var eType = store.getFieldValue(existing, "__typename");
        var iType = store.getFieldValue(incoming, "__typename");
        var typesDiffer = eType && iType && eType !== iType;
        if (typesDiffer) {
          return incoming;
        }
        if (utilities2.isReference(existing) && storeValueIsStoreObject2(incoming)) {
          store.merge(existing.__ref, incoming);
          return existing;
        }
        if (storeValueIsStoreObject2(existing) && utilities2.isReference(incoming)) {
          store.merge(existing, incoming.__ref);
          return incoming;
        }
        if (storeValueIsStoreObject2(existing) && storeValueIsStoreObject2(incoming)) {
          return tslib2.__assign(tslib2.__assign({}, existing), incoming);
        }
      }
      return incoming;
    };
  }
  function getContextFlavor2(context2, clientOnly, deferred) {
    var key = "".concat(clientOnly).concat(deferred);
    var flavored = context2.flavors.get(key);
    if (!flavored) {
      context2.flavors.set(key, flavored = context2.clientOnly === clientOnly && context2.deferred === deferred ? context2 : tslib2.__assign(tslib2.__assign({}, context2), { clientOnly, deferred }));
    }
    return flavored;
  }
  var StoreWriter2 = function() {
    function StoreWriter3(cache2, reader, fragments) {
      this.cache = cache2;
      this.reader = reader;
      this.fragments = fragments;
    }
    StoreWriter3.prototype.writeToStore = function(store, _a3) {
      var _this = this;
      var query = _a3.query, result = _a3.result, dataId = _a3.dataId, variables = _a3.variables, overwrite = _a3.overwrite;
      var operationDefinition = utilities2.getOperationDefinition(query);
      var merger = makeProcessedFieldsMerger2();
      variables = tslib2.__assign(tslib2.__assign({}, utilities2.getDefaultValues(operationDefinition)), variables);
      var context2 = tslib2.__assign(tslib2.__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: utilities2.canonicalStringify(variables) }, extractFragmentContext2(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context: context2
      });
      if (!utilities2.isReference(ref)) {
        throw globals2.newInvariantError(11, result);
      }
      context2.incomingById.forEach(function(_a4, dataId2) {
        var storeObject = _a4.storeObject, mergeTree = _a4.mergeTree, fieldNodeSet = _a4.fieldNodeSet;
        var entityRef = utilities2.makeReference(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context2);
          if (utilities2.isReference(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context2.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName2(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss2(entityRef, storeObject, storeFieldName, context2.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter3.prototype.processSelectionSet = function(_a3) {
      var _this = this;
      var dataId = _a3.dataId, result = _a3.result, selectionSet = _a3.selectionSet, context2 = _a3.context, mergeTree = _a3.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || utilities2.getTypenameFromResult(result, selectionSet, context2.fragmentMap) || dataId && context2.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options2 = normalizeReadFieldOptions2(arguments, incoming, context2.variables);
        if (utilities2.isReference(options2.from)) {
          var info = context2.incomingById.get(options2.from.__ref);
          if (info) {
            var result_1 = policies.readField(tslib2.__assign(tslib2.__assign({}, options2), { from: info.storeObject }), context2);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options2, context2);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result,
        context2,
        typename
      ).forEach(function(context3, field) {
        var _a4;
        var resultFieldKey = utilities2.resultKeyNameFromField(field);
        var value = result[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context3.variables
          });
          var childTree = getChildMergeTree2(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            field.selectionSet ? getContextFlavor2(context3, false, false) : context3,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (utilities2.isReference(incomingValue) || storeValueIsStoreObject2(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge2 = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge2) {
            childTree.info = {
              field,
              typename,
              merge: merge2
            };
          } else {
            maybeRecycleChildMergeTree2(mergeTree, storeFieldName);
          }
          incoming = context3.merge(incoming, (_a4 = {}, _a4[storeFieldName] = incomingValue, _a4));
        } else if (globalThis.__DEV__ !== false && !context3.clientOnly && !context3.deferred && !utilities2.addTypenameToDocument.added(field) && !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && globals2.invariant.error(12, utilities2.resultKeyNameFromField(field), result);
        }
      });
      try {
        var _b2 = policies.identify(result, {
          typename,
          selectionSet,
          fragmentMap: context2.fragmentMap,
          storeObject: incoming,
          readField
        }), id2 = _b2[0], keyObject = _b2[1];
        dataId = dataId || id2;
        if (keyObject) {
          incoming = context2.merge(incoming, keyObject);
        }
      } catch (e2) {
        if (!dataId)
          throw e2;
      }
      if ("string" === typeof dataId) {
        var dataRef = utilities2.makeReference(dataId);
        var sets = context2.written[dataId] || (context2.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context2)) {
          return dataRef;
        }
        var previous_1 = context2.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context2.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees2(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context2.incomingById.set(dataId, {
            storeObject: incoming,
            mergeTree: mergeTreeIsEmpty2(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter3.prototype.processFieldValue = function(value, field, context2, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? utilities2.cloneDeep(value) : value;
      }
      if (utilities2.isArray(value)) {
        return value.map(function(item, i2) {
          var value2 = _this.processFieldValue(item, field, context2, getChildMergeTree2(mergeTree, i2));
          maybeRecycleChildMergeTree2(mergeTree, i2);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context: context2,
        mergeTree
      });
    };
    StoreWriter3.prototype.flattenFields = function(selectionSet, result, context2, typename) {
      if (typename === void 0) {
        typename = utilities2.getTypenameFromResult(result, selectionSet, context2.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new trie2.Trie(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!utilities2.shouldInclude(selection, context2.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (!(clientOnly && deferred) && utilities2.isNonEmptyArray(selection.directives)) {
            selection.directives.forEach(function(dir) {
              var name = dir.name.value;
              if (name === "client")
                clientOnly = true;
              if (name === "defer") {
                var args = utilities2.argumentsObjectFromField(dir, context2.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (utilities2.isField(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor2(context2, clientOnly, deferred));
          } else {
            var fragment = utilities2.getFragmentFromSelection(selection, context2.lookupFragment);
            if (!fragment && selection.kind === graphql2.Kind.FRAGMENT_SPREAD) {
              throw globals2.newInvariantError(13, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result, context2.variables)) {
              flatten(fragment.selectionSet, getContextFlavor2(context2, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context2);
      return fieldMap;
    };
    StoreWriter3.prototype.applyMerges = function(mergeTree, existing, incoming, context2, getStorageArgs) {
      var _a3;
      var _this = this;
      if (mergeTree.map.size && !utilities2.isReference(incoming)) {
        var e_1 = !utilities2.isArray(incoming) && (utilities2.isReference(existing) || storeValueIsStoreObject2(existing)) ? existing : void 0;
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [utilities2.isReference(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name) {
          return utilities2.isArray(from2) ? typeof name === "number" ? from2[name] : void 0 : context2.store.getFieldValue(from2, String(name));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context2, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            globals2.invariant(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = utilities2.isArray(i_1) ? i_1.slice(0) : tslib2.__assign({}, i_1);
          changedFields_1.forEach(function(value, name) {
            incoming[name] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context2, getStorageArgs && (_a3 = context2.store).getStorage.apply(_a3, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter3;
  }();
  var emptyMergeTreePool2 = [];
  function getChildMergeTree2(_a3, name) {
    var map = _a3.map;
    if (!map.has(name)) {
      map.set(name, emptyMergeTreePool2.pop() || { map: /* @__PURE__ */ new Map() });
    }
    return map.get(name);
  }
  function mergeMergeTrees2(left, right) {
    if (left === right || !right || mergeTreeIsEmpty2(right))
      return left;
    if (!left || mergeTreeIsEmpty2(left))
      return right;
    var info = left.info && right.info ? tslib2.__assign(tslib2.__assign({}, left.info), right.info) : left.info || right.info;
    var needToMergeMaps = left.map.size && right.map.size;
    var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
    var merged = { info, map };
    if (needToMergeMaps) {
      var remainingRightKeys_1 = new Set(right.map.keys());
      left.map.forEach(function(leftTree, key) {
        merged.map.set(key, mergeMergeTrees2(leftTree, right.map.get(key)));
        remainingRightKeys_1.delete(key);
      });
      remainingRightKeys_1.forEach(function(key) {
        merged.map.set(key, mergeMergeTrees2(right.map.get(key), left.map.get(key)));
      });
    }
    return merged;
  }
  function mergeTreeIsEmpty2(tree) {
    return !tree || !(tree.info || tree.map.size);
  }
  function maybeRecycleChildMergeTree2(_a3, name) {
    var map = _a3.map;
    var childTree = map.get(name);
    if (childTree && mergeTreeIsEmpty2(childTree)) {
      emptyMergeTreePool2.push(childTree);
      map.delete(name);
    }
  }
  var warnings2 = /* @__PURE__ */ new Set();
  function warnAboutDataLoss2(existingRef, incomingObj, storeFieldName, store) {
    var getChild = function(objOrRef) {
      var child = store.getFieldValue(objOrRef, storeFieldName);
      return typeof child === "object" && child;
    };
    var existing = getChild(existingRef);
    if (!existing)
      return;
    var incoming = getChild(incomingObj);
    if (!incoming)
      return;
    if (utilities2.isReference(existing))
      return;
    if (equal2.equal(existing, incoming))
      return;
    if (Object.keys(existing).every(function(key) {
      return store.getFieldValue(incoming, key) !== void 0;
    })) {
      return;
    }
    var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
    var fieldName = fieldNameFromStoreName2(storeFieldName);
    var typeDotName = "".concat(parentType, ".").concat(fieldName);
    if (warnings2.has(typeDotName))
      return;
    warnings2.add(typeDotName);
    var childTypenames = [];
    if (!utilities2.isArray(existing) && !utilities2.isArray(incoming)) {
      [existing, incoming].forEach(function(child) {
        var typename = store.getFieldValue(child, "__typename");
        if (typeof typename === "string" && !childTypenames.includes(typename)) {
          childTypenames.push(typename);
        }
      });
    }
    globalThis.__DEV__ !== false && globals2.invariant.warn(14, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, tslib2.__assign({}, existing), tslib2.__assign({}, incoming));
  }
  var InMemoryCache2 = function(_super) {
    tslib2.__extends(InMemoryCache3, _super);
    function InMemoryCache3(config) {
      if (config === void 0) {
        config = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new utilities2.DocumentTransform(utilities2.addTypenameToDocument);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar2;
      _this.txCount = 0;
      _this.config = normalizeConfig2(config);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies2({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache3.prototype.init = function() {
      var rootStore = this.data = new exports.EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache3.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter2(this, this.storeReader = new StoreReader2({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults2(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = optimism2.wrap(function(c2, options2) {
        return _this.broadcastWatch(c2, options2);
      }, {
        max: this.config.resultCacheMaxSize || utilities2.cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(c2) {
          var store = c2.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching2(store)) {
            var optimistic = c2.optimistic, id2 = c2.id, variables = c2.variables;
            return store.makeCacheKey(
              c2.query,
              c2.callback,
              utilities2.canonicalStringify({ optimistic, id: id2, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache3.prototype.restore = function(data) {
      this.init();
      if (data)
        this.data.replace(data);
      return this;
    };
    InMemoryCache3.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache3.prototype.read = function(options2) {
      var _a3 = options2.returnPartialData, returnPartialData = _a3 === void 0 ? false : _a3;
      try {
        return this.storeReader.diffQueryAgainstStore(tslib2.__assign(tslib2.__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e2) {
        if (e2 instanceof MissingFieldError2) {
          return null;
        }
        throw e2;
      }
    };
    InMemoryCache3.prototype.write = function(options2) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options2);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache3.prototype.modify = function(options2) {
      if (hasOwn2.call(options2, "id") && !options2.id) {
        return false;
      }
      var store = options2.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options2.id || "ROOT_QUERY", options2.fields);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache3.prototype.diff = function(options2) {
      return this.storeReader.diffQueryAgainstStore(tslib2.__assign(tslib2.__assign({}, options2), { store: options2.optimistic ? this.optimisticData : this.data, rootId: options2.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache3.prototype.watch = function(watch) {
      var _this = this;
      if (!this.watches.size) {
        recallCache2(this);
      }
      this.watches.add(watch);
      if (watch.immediate) {
        this.maybeBroadcastWatch(watch);
      }
      return function() {
        if (_this.watches.delete(watch) && !_this.watches.size) {
          forgetCache2(_this);
        }
        _this.maybeBroadcastWatch.forget(watch);
      };
    };
    InMemoryCache3.prototype.gc = function(options2) {
      var _a3;
      utilities2.canonicalStringify.reset();
      utilities2.print.reset();
      this.addTypenameTransform.resetCache();
      (_a3 = this.config.fragments) === null || _a3 === void 0 ? void 0 : _a3.resetCaches();
      var ids = this.optimisticData.gc();
      if (options2 && !this.txCount) {
        if (options2.resetResultCache) {
          this.resetResultCache(options2.resetResultIdentities);
        } else if (options2.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache3.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache3.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache3.prototype.identify = function(object) {
      if (utilities2.isReference(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e2) {
        globalThis.__DEV__ !== false && globals2.invariant.warn(e2);
      }
    };
    InMemoryCache3.prototype.evict = function(options2) {
      if (!options2.id) {
        if (hasOwn2.call(options2, "id")) {
          return false;
        }
        options2 = tslib2.__assign(tslib2.__assign({}, options2), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options2, this.data);
      } finally {
        if (!--this.txCount && options2.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache3.prototype.reset = function(options2) {
      var _this = this;
      this.init();
      utilities2.canonicalStringify.reset();
      if (options2 && options2.discardWatches) {
        this.watches.forEach(function(watch) {
          return _this.maybeBroadcastWatch.forget(watch);
        });
        this.watches.clear();
        forgetCache2(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache3.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache3.prototype.batch = function(options2) {
      var _this = this;
      var update = options2.update, _a3 = options2.optimistic, optimistic = _a3 === void 0 ? true : _a3, removeOptimistic = options2.removeOptimistic, onWatchUpdated = options2.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a4 = _this, data = _a4.data, optimisticData = _a4.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(tslib2.__assign(tslib2.__assign({}, options2), { onWatchUpdated: function(watch) {
          alreadyDirty.add(watch);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(tslib2.__assign(tslib2.__assign({}, options2), { onWatchUpdated: function(watch, diff2) {
          var result = onWatchUpdated.call(this, watch, diff2);
          if (result !== false) {
            alreadyDirty.delete(watch);
          }
          return result;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch) {
            return _this.maybeBroadcastWatch.dirty(watch);
          });
        }
      } else {
        this.broadcastWatches(options2);
      }
      return updateResult;
    };
    InMemoryCache3.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache3.prototype.transformDocument = function(document2) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
    };
    InMemoryCache3.prototype.broadcastWatches = function(options2) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c2) {
          return _this.maybeBroadcastWatch(c2, options2);
        });
      }
    };
    InMemoryCache3.prototype.addFragmentsToDocument = function(document2) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document2) : document2;
    };
    InMemoryCache3.prototype.addTypenameToDocument = function(document2) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document2);
      }
      return document2;
    };
    InMemoryCache3.prototype.broadcastWatch = function(c2, options2) {
      var lastDiff = c2.lastDiff;
      var diff2 = this.diff(c2);
      if (options2) {
        if (c2.optimistic && typeof options2.optimistic === "string") {
          diff2.fromOptimisticTransaction = true;
        }
        if (options2.onWatchUpdated && options2.onWatchUpdated.call(this, c2, diff2, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal2.equal(lastDiff.result, diff2.result)) {
        c2.callback(c2.lastDiff = diff2, lastDiff);
      }
    };
    return InMemoryCache3;
  }(ApolloCache2);
  if (globalThis.__DEV__ !== false) {
    InMemoryCache2.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals2;
  }
  function createFragmentRegistry2() {
    var fragments = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      fragments[_i2] = arguments[_i2];
    }
    return new (FragmentRegistry2.bind.apply(FragmentRegistry2, tslib2.__spreadArray([void 0], fragments, false)))();
  }
  var FragmentRegistry2 = function() {
    function FragmentRegistry3() {
      var fragments = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        fragments[_i2] = arguments[_i2];
      }
      this.registry = /* @__PURE__ */ Object.create(null);
      this.resetCaches();
      if (fragments.length) {
        this.register.apply(this, fragments);
      }
    }
    FragmentRegistry3.prototype.register = function() {
      var _this = this;
      var fragments = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        fragments[_i2] = arguments[_i2];
      }
      var definitions = /* @__PURE__ */ new Map();
      fragments.forEach(function(doc) {
        utilities2.getFragmentDefinitions(doc).forEach(function(node) {
          definitions.set(node.name.value, node);
        });
      });
      definitions.forEach(function(node, name) {
        if (node !== _this.registry[name]) {
          _this.registry[name] = node;
          _this.invalidate(name);
        }
      });
      return this;
    };
    FragmentRegistry3.prototype.invalidate = function(name) {
    };
    FragmentRegistry3.prototype.resetCaches = function() {
      var proto = FragmentRegistry3.prototype;
      this.invalidate = (this.lookup = optimism2.wrap(proto.lookup.bind(this), {
        makeCacheKey: function(arg) {
          return arg;
        },
        max: utilities2.cacheSizes["fragmentRegistry.lookup"] || 1e3
      })).dirty;
      this.transform = optimism2.wrap(proto.transform.bind(this), {
        cache: caches2.WeakCache,
        max: utilities2.cacheSizes["fragmentRegistry.transform"] || 2e3
      });
      this.findFragmentSpreads = optimism2.wrap(proto.findFragmentSpreads.bind(this), {
        cache: caches2.WeakCache,
        max: utilities2.cacheSizes["fragmentRegistry.findFragmentSpreads"] || 4e3
      });
    };
    FragmentRegistry3.prototype.lookup = function(fragmentName) {
      return this.registry[fragmentName] || null;
    };
    FragmentRegistry3.prototype.transform = function(document2) {
      var _this = this;
      var defined = /* @__PURE__ */ new Map();
      utilities2.getFragmentDefinitions(document2).forEach(function(def) {
        defined.set(def.name.value, def);
      });
      var unbound = /* @__PURE__ */ new Set();
      var enqueue2 = function(spreadName) {
        if (!defined.has(spreadName)) {
          unbound.add(spreadName);
        }
      };
      var enqueueChildSpreads = function(node) {
        return Object.keys(_this.findFragmentSpreads(node)).forEach(enqueue2);
      };
      enqueueChildSpreads(document2);
      var missing = [];
      var map = /* @__PURE__ */ Object.create(null);
      unbound.forEach(function(fragmentName) {
        var knownFragmentDef = defined.get(fragmentName);
        if (knownFragmentDef) {
          enqueueChildSpreads(map[fragmentName] = knownFragmentDef);
        } else {
          missing.push(fragmentName);
          var def = _this.lookup(fragmentName);
          if (def) {
            enqueueChildSpreads(map[fragmentName] = def);
          }
        }
      });
      if (missing.length) {
        var defsToAppend_1 = [];
        missing.forEach(function(name) {
          var def = map[name];
          if (def) {
            defsToAppend_1.push(def);
          }
        });
        if (defsToAppend_1.length) {
          document2 = tslib2.__assign(tslib2.__assign({}, document2), { definitions: document2.definitions.concat(defsToAppend_1) });
        }
      }
      return document2;
    };
    FragmentRegistry3.prototype.findFragmentSpreads = function(root2) {
      var spreads = /* @__PURE__ */ Object.create(null);
      graphql2.visit(root2, {
        FragmentSpread: function(node) {
          spreads[node.name.value] = node;
        }
      });
      return spreads;
    };
    return FragmentRegistry3;
  }();
  exports.canonicalStringify = utilities2.canonicalStringify;
  exports.isReference = utilities2.isReference;
  exports.makeReference = utilities2.makeReference;
  exports.ApolloCache = ApolloCache2;
  exports.InMemoryCache = InMemoryCache2;
  exports.MissingFieldError = MissingFieldError2;
  exports.Policies = Policies2;
  exports.cacheSlot = cacheSlot2;
  exports.createFragmentRegistry = createFragmentRegistry2;
  exports.defaultDataIdFromObject = defaultDataIdFromObject2;
  exports.fieldNameFromStoreName = fieldNameFromStoreName2;
  exports.makeVar = makeVar2;
})(cache$1);
var utilities$3 = {};
const require$$6$1 = /* @__PURE__ */ getAugmentedNamespace(module$1);
Object.defineProperty(utilities$3, "__esModule", { value: true });
var globals$2 = require$$1;
var graphql = require$$9$1;
var trie = require$$8$1;
var tslib$3 = require$$0;
var caches = require$$4$1;
var optimism = require$$5;
var zenObservableTs = require$$6$1;
function shouldInclude(_a3, variables) {
  var directives = _a3.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a4) {
    var directive = _a4.directive, ifArgument = _a4.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      globals$2.invariant(evaledValue !== void 0, 69, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function getDirectiveNames(root2) {
  var names = [];
  graphql.visit(root2, {
    Directive: function(node) {
      names.push(node.name.value);
    }
  });
  return names;
}
var hasAnyDirectives = function(names, root2) {
  return hasDirectives(names, root2, false);
};
var hasAllDirectives = function(names, root2) {
  return hasDirectives(names, root2, true);
};
function hasDirectives(names, root2, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  graphql.visit(root2, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return graphql.BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a3) {
  var value = _a3.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      globals$2.invariant(directiveArguments && directiveArguments.length === 1, 70, directiveName);
      var ifArgument = directiveArguments[0];
      globals$2.invariant(ifArgument.name && ifArgument.name.value === "if", 71, directiveName);
      var ifValue = ifArgument.value;
      globals$2.invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 72, directiveName);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
var isReactNative = globals$2.maybe(function() {
  return navigator.product;
}) == "ReactNative";
var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !commonjsGlobal.HermesInternal);
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof globals$2.maybe(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = globals$2.maybe(function() {
  return navigator.userAgent.indexOf("jsdom") >= 0;
}) || false;
var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function isPlainObject$1(obj) {
  return obj !== null && typeof obj === "object" && (Object.getPrototypeOf(obj) === Object.prototype || Object.getPrototypeOf(obj) === null);
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw globals$2.newInvariantError(
        73,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    globals$2.invariant(fragments.length === 1, 74, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = tslib$3.__assign(tslib$3.__assign({}, document2), { definitions: tslib$3.__spreadArray([
    {
      kind: "OperationDefinition",
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      globals$2.invariant(fragment, 75, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
var scheduledCleanup = /* @__PURE__ */ new WeakSet();
function schedule(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache2)) {
    scheduledCleanup.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup.delete(cache2);
    }, 100);
  }
}
var AutoCleanedWeakCache = function(max2, dispose) {
  var cache2 = new caches.WeakCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = caches.WeakCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var AutoCleanedStrongCache = function(max2, dispose) {
  var cache2 = new caches.StrongCache(max2, dispose);
  cache2.set = function(key, value) {
    var ret = caches.StrongCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
var cacheSizes = tslib$3.__assign({}, globals$2.global[cacheSizeSymbol]);
var globalCaches = {};
function registerGlobalCache(name, getSize) {
  globalCaches[name] = getSize;
}
var canonicalStringify = Object.assign(function canonicalStringify3(value) {
  return JSON.stringify(value, stableObjectReplacer);
}, {
  reset: function() {
    sortingMap = new AutoCleanedStrongCache(cacheSizes.canonicalStringify || 1e3);
  }
});
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("canonicalStringify", function() {
    return sortingMap.size;
  });
}
var sortingMap;
canonicalStringify.reset();
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder(key, i2, keys) {
  return i2 === 0 || keys[i2 - 1] <= key;
}
function makeReference(id2) {
  return { __ref: String(id2) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name.value] = null;
  } else {
    throw globals$2.newInvariantError(84, name.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a3) {
          var name = _a3.name, value = _a3.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a3) {
      var name = _a3.name, value = _a3.value;
      return valueToObjectRepresentation(argObj, name, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify = canonicalStringify;
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = storeKeyNameStringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s2) {
    var previous = storeKeyNameStringify;
    storeKeyNameStringify = s2;
    return previous;
  }
});
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a3) {
      var name = _a3.name, value = _a3.value;
      return valueToObjectRepresentation(argObj_1, name, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  var fragments;
  for (var _i2 = 0, _a3 = selectionSet.selections; _i2 < _a3.length; _i2++) {
    var selection = _a3[_i2];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  if (fragments) {
    for (var _b2 = 0, fragments_1 = fragments; _b2 < fragments_1.length; _b2++) {
      var selection = fragments_1[_b2];
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  globals$2.invariant(doc && doc.kind === "Document", 76);
  var operations = doc.definitions.filter(function(d3) {
    return d3.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw globals$2.newInvariantError(77, definition.kind);
    }
    return definition;
  });
  globals$2.invariant(operations.length <= 1, 78, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  globals$2.invariant(queryDef && queryDef.operation === "query", 79);
  return queryDef;
}
function getFragmentDefinition(doc) {
  globals$2.invariant(doc.kind === "Document", 80);
  globals$2.invariant(doc.definitions.length <= 1, 81);
  var fragmentDef = doc.definitions[0];
  globals$2.invariant(fragmentDef.kind === "FragmentDefinition", 82);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i2 = 0, _a3 = queryDoc.definitions; _i2 < _a3.length; _i2++) {
    var definition = _a3[_i2];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw globals$2.newInvariantError(83);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function identity(document2) {
  return document2;
}
var DocumentTransform = function() {
  function DocumentTransform2(transform, options2) {
    if (options2 === void 0) {
      options2 = /* @__PURE__ */ Object.create(null);
    }
    this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
    this.transform = transform;
    if (options2.getCacheKey) {
      this.getCacheKey = options2.getCacheKey;
    }
    this.cached = options2.cache !== false;
    this.resetCache();
  }
  DocumentTransform2.prototype.getCacheKey = function(document2) {
    return [document2];
  };
  DocumentTransform2.identity = function() {
    return new DocumentTransform2(identity, { cache: false });
  };
  DocumentTransform2.split = function(predicate, left, right) {
    if (right === void 0) {
      right = DocumentTransform2.identity();
    }
    return Object.assign(new DocumentTransform2(
      function(document2) {
        var documentTransform = predicate(document2) ? left : right;
        return documentTransform.transformDocument(document2);
      },
      { cache: false }
    ), { left, right });
  };
  DocumentTransform2.prototype.resetCache = function() {
    var _this = this;
    if (this.cached) {
      var stableCacheKeys_1 = new trie.Trie(canUseWeakMap);
      this.performWork = optimism.wrap(DocumentTransform2.prototype.performWork.bind(this), {
        makeCacheKey: function(document2) {
          var cacheKeys = _this.getCacheKey(document2);
          if (cacheKeys) {
            globals$2.invariant(Array.isArray(cacheKeys), 68);
            return stableCacheKeys_1.lookupArray(cacheKeys);
          }
        },
        max: cacheSizes["documentTransform.cache"],
        cache: caches.WeakCache
      });
    }
  };
  DocumentTransform2.prototype.performWork = function(document2) {
    checkDocument(document2);
    return this.transform(document2);
  };
  DocumentTransform2.prototype.transformDocument = function(document2) {
    if (this.resultCache.has(document2)) {
      return document2;
    }
    var transformedDocument = this.performWork(document2);
    this.resultCache.add(transformedDocument);
    return transformedDocument;
  };
  DocumentTransform2.prototype.concat = function(otherTransform) {
    var _this = this;
    return Object.assign(new DocumentTransform2(
      function(document2) {
        return otherTransform.transformDocument(_this.transformDocument(document2));
      },
      { cache: false }
    ), {
      left: this,
      right: otherTransform
    });
  };
  return DocumentTransform2;
}();
var printCache;
var print$1 = Object.assign(function(ast2) {
  var result = printCache.get(ast2);
  if (!result) {
    result = graphql.print(ast2);
    printCache.set(ast2, result);
  }
  return result;
}, {
  reset: function() {
    printCache = new AutoCleanedWeakCache(cacheSizes.print || 2e3);
  }
});
print$1.reset();
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("print", function() {
    return printCache ? printCache.size : 0;
  });
}
var isArray = Array.isArray;
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
var TYPENAME_FIELD = {
  kind: graphql.Kind.FIELD,
  name: {
    kind: graphql.Kind.NAME,
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === graphql.Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach(function(testConfig, test) {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p3 = 0, ancestor = void 0; p3 < ancestors.length && (ancestor = ancestors[p3]); ++p3) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === graphql.Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === graphql.Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && globals$2.invariant.error(85);
    return null;
  };
  var operationCount = 0;
  for (var i2 = doc.definitions.length - 1; i2 >= 0; --i2) {
    if (doc.definitions[i2].kind === graphql.Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config) {
      return config && config.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = graphql.visit(doc, {
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (operationCount > 0 && node.selectionSet.selections.every(function(selection) {
          return selection.kind === graphql.Kind.FIELD && selection.name.value === "__typename";
        })) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === graphql.Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === graphql.Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(graphql.visit(docWithoutDirectiveSubtrees, {
    FragmentSpread: enterVisitor,
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return tslib$3.__assign(tslib$3.__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument = Object.assign(function(doc) {
  return graphql.visit(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === graphql.Kind.OPERATION_DEFINITION) {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d3) {
          return d3.name.value === "export";
        })) {
          return;
        }
        return tslib$3.__assign(tslib$3.__assign({}, node), { selections: tslib$3.__spreadArray(tslib$3.__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
var connectionRemoveConfig = {
  test: function(directive) {
    var willRemove = directive.name.value === "connection";
    if (willRemove) {
      if (!directive.arguments || !directive.arguments.some(function(arg) {
        return arg.name.value === "key";
      })) {
        globalThis.__DEV__ !== false && globals$2.invariant.warn(86);
      }
    }
    return willRemove;
  }
};
function removeConnectionDirectiveFromDocument(doc) {
  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));
}
function getArgumentMatcher(config) {
  return function argumentMatcher(argument) {
    return config.some(function(aConfig) {
      return argument.value && argument.value.kind === graphql.Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));
    });
  };
}
function removeArgumentsFromDocument(config, doc) {
  var argMatcher = getArgumentMatcher(config);
  return nullIfDocIsEmpty(graphql.visit(doc, {
    OperationDefinition: {
      enter: function(node) {
        return tslib$3.__assign(tslib$3.__assign({}, node), {
          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function(varDef) {
            return !config.some(function(arg) {
              return arg.name === varDef.variable.name.value;
            });
          }) : []
        });
      }
    },
    Field: {
      enter: function(node) {
        var shouldRemoveField = config.some(function(argConfig) {
          return argConfig.remove;
        });
        if (shouldRemoveField) {
          var argMatchCount_1 = 0;
          if (node.arguments) {
            node.arguments.forEach(function(arg) {
              if (argMatcher(arg)) {
                argMatchCount_1 += 1;
              }
            });
          }
          if (argMatchCount_1 === 1) {
            return null;
          }
        }
      }
    },
    Argument: {
      enter: function(node) {
        if (argMatcher(node)) {
          return null;
        }
      }
    }
  }));
}
function removeFragmentSpreadFromDocument(config, doc) {
  function enter(node) {
    if (config.some(function(def) {
      return def.name === node.name.value;
    })) {
      return null;
    }
  }
  return nullIfDocIsEmpty(graphql.visit(doc, {
    FragmentSpread: { enter },
    FragmentDefinition: { enter }
  }));
}
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = graphql.visit(document2, {
    OperationDefinition: {
      enter: function(node) {
        return tslib$3.__assign(tslib$3.__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  return modifiedDoc;
}
function isOperation(document2, operation) {
  var _a3;
  return ((_a3 = getOperationDefinition(document2)) === null || _a3 === void 0 ? void 0 : _a3.operation) === operation;
}
function isMutationOperation(document2) {
  return isOperation(document2, "mutation");
}
function isQueryOperation(document2) {
  return isOperation(document2, "query");
}
function isSubscriptionOperation(document2) {
  return isOperation(document2, "subscription");
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    sources[_i2] = arguments[_i2];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count2 = sources.length;
  if (count2 > 1) {
    var merger = new DeepMerger();
    for (var i2 = 1; i2 < count2; ++i2) {
      target = merger.merge(target, sources[i2]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = function() {
  function DeepMerger2(reconciler) {
    if (reconciler === void 0) {
      reconciler = defaultReconciler;
    }
    this.reconciler = reconciler;
    this.isObject = isNonNullObject;
    this.pastCopies = /* @__PURE__ */ new Set();
  }
  DeepMerger2.prototype.merge = function(target, source) {
    var _this = this;
    var context2 = [];
    for (var _i2 = 2; _i2 < arguments.length; _i2++) {
      context2[_i2 - 2] = arguments[_i2];
    }
    if (isNonNullObject(source) && isNonNullObject(target)) {
      Object.keys(source).forEach(function(sourceKey) {
        if (hasOwnProperty$1.call(target, sourceKey)) {
          var targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            var result = _this.reconciler.apply(_this, tslib$3.__spreadArray([
              target,
              source,
              sourceKey
            ], context2, false));
            if (result !== targetValue) {
              target = _this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = _this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  };
  DeepMerger2.prototype.shallowCopyForMerge = function(value) {
    if (isNonNullObject(value)) {
      if (!this.pastCopies.has(value)) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else {
          value = tslib$3.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
        }
        this.pastCopies.add(value);
      }
    }
    return value;
  };
  return DeepMerger2;
}();
function concatPagination(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    merge: function(existing, incoming) {
      return existing ? tslib$3.__spreadArray(tslib$3.__spreadArray([], existing, true), incoming, true) : incoming;
    }
  };
}
function offsetLimitPagination(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    merge: function(existing, incoming, _a3) {
      var args = _a3.args;
      var merged = existing ? existing.slice(0) : [];
      if (incoming) {
        if (args) {
          var _b2 = args.offset, offset2 = _b2 === void 0 ? 0 : _b2;
          for (var i2 = 0; i2 < incoming.length; ++i2) {
            merged[offset2 + i2] = incoming[i2];
          }
        } else {
          merged.push.apply(merged, incoming);
        }
      }
      return merged;
    }
  };
}
function relayStylePagination(keyArgs) {
  if (keyArgs === void 0) {
    keyArgs = false;
  }
  return {
    keyArgs,
    read: function(existing, _a3) {
      var canRead = _a3.canRead, readField = _a3.readField;
      if (!existing)
        return existing;
      var edges = [];
      var firstEdgeCursor = "";
      var lastEdgeCursor = "";
      existing.edges.forEach(function(edge) {
        if (canRead(readField("node", edge))) {
          edges.push(edge);
          if (edge.cursor) {
            firstEdgeCursor = firstEdgeCursor || edge.cursor || "";
            lastEdgeCursor = edge.cursor || lastEdgeCursor;
          }
        }
      });
      if (edges.length > 1 && firstEdgeCursor === lastEdgeCursor) {
        firstEdgeCursor = "";
      }
      var _b2 = existing.pageInfo || {}, startCursor = _b2.startCursor, endCursor = _b2.endCursor;
      return tslib$3.__assign(tslib$3.__assign({}, getExtras(existing)), { edges, pageInfo: tslib$3.__assign(tslib$3.__assign({}, existing.pageInfo), {
        startCursor: startCursor || firstEdgeCursor,
        endCursor: endCursor || lastEdgeCursor
      }) });
    },
    merge: function(existing, incoming, _a3) {
      var args = _a3.args, isReference2 = _a3.isReference, readField = _a3.readField;
      if (!existing) {
        existing = makeEmptyData();
      }
      if (!incoming) {
        return existing;
      }
      var incomingEdges = incoming.edges ? incoming.edges.map(function(edge) {
        if (isReference2(edge = tslib$3.__assign({}, edge))) {
          edge.cursor = readField("cursor", edge);
        }
        return edge;
      }) : [];
      if (incoming.pageInfo) {
        var pageInfo_1 = incoming.pageInfo;
        var startCursor = pageInfo_1.startCursor, endCursor = pageInfo_1.endCursor;
        var firstEdge = incomingEdges[0];
        var lastEdge = incomingEdges[incomingEdges.length - 1];
        if (firstEdge && startCursor) {
          firstEdge.cursor = startCursor;
        }
        if (lastEdge && endCursor) {
          lastEdge.cursor = endCursor;
        }
        var firstCursor = firstEdge && firstEdge.cursor;
        if (firstCursor && !startCursor) {
          incoming = mergeDeep(incoming, {
            pageInfo: {
              startCursor: firstCursor
            }
          });
        }
        var lastCursor = lastEdge && lastEdge.cursor;
        if (lastCursor && !endCursor) {
          incoming = mergeDeep(incoming, {
            pageInfo: {
              endCursor: lastCursor
            }
          });
        }
      }
      var prefix = existing.edges;
      var suffix = [];
      if (args && args.after) {
        var index2 = prefix.findIndex(function(edge) {
          return edge.cursor === args.after;
        });
        if (index2 >= 0) {
          prefix = prefix.slice(0, index2 + 1);
        }
      } else if (args && args.before) {
        var index2 = prefix.findIndex(function(edge) {
          return edge.cursor === args.before;
        });
        suffix = index2 < 0 ? prefix : prefix.slice(index2);
        prefix = [];
      } else if (incoming.edges) {
        prefix = [];
      }
      var edges = tslib$3.__spreadArray(tslib$3.__spreadArray(tslib$3.__spreadArray([], prefix, true), incomingEdges, true), suffix, true);
      var pageInfo = tslib$3.__assign(tslib$3.__assign({}, incoming.pageInfo), existing.pageInfo);
      if (incoming.pageInfo) {
        var _b2 = incoming.pageInfo, hasPreviousPage = _b2.hasPreviousPage, hasNextPage = _b2.hasNextPage, startCursor = _b2.startCursor, endCursor = _b2.endCursor, extras2 = tslib$3.__rest(_b2, ["hasPreviousPage", "hasNextPage", "startCursor", "endCursor"]);
        Object.assign(pageInfo, extras2);
        if (!prefix.length) {
          if (void 0 !== hasPreviousPage)
            pageInfo.hasPreviousPage = hasPreviousPage;
          if (void 0 !== startCursor)
            pageInfo.startCursor = startCursor;
        }
        if (!suffix.length) {
          if (void 0 !== hasNextPage)
            pageInfo.hasNextPage = hasNextPage;
          if (void 0 !== endCursor)
            pageInfo.endCursor = endCursor;
        }
      }
      return tslib$3.__assign(tslib$3.__assign(tslib$3.__assign({}, getExtras(existing)), getExtras(incoming)), { edges, pageInfo });
    }
  };
}
var getExtras = function(obj) {
  return tslib$3.__rest(obj, notExtras);
};
var notExtras = ["edges", "pageInfo"];
function makeEmptyData() {
  return {
    edges: [],
    pageInfo: {
      hasPreviousPage: false,
      hasNextPage: true,
      startCursor: "",
      endCursor: ""
    }
  };
}
function createFulfilledPromise(value) {
  var promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}
function createRejectedPromise(reason) {
  var promise = Promise.reject(reason);
  promise.catch(function() {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}
function isStatefulPromise(promise) {
  return "status" in promise;
}
function wrapPromiseWithState(promise) {
  if (isStatefulPromise(promise)) {
    return promise;
  }
  var pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then(function(value) {
    if (pendingPromise.status === "pending") {
      var fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, function(reason) {
    if (pendingPromise.status === "pending") {
      var rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}
var toString = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen2) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_1 = val.slice(0);
      seen2.set(val, copy_1);
      copy_1.forEach(function(child, i2) {
        copy_1[i2] = cloneDeepHelper(child, seen2);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen2 = seen2 || /* @__PURE__ */ new Map();
      if (seen2.has(val))
        return seen2.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen2.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen2);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e2) {
      if (e2 instanceof TypeError)
        return null;
      throw e2;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers, method, argument) {
  var observersWithMethod = [];
  observers.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap(observable, mapFn, catchFn) {
  return new zenObservableTs.Observable(function(observer) {
    var promiseQueue = {
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? 0 : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            return observer.next(result);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: zenObservableTs.Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = function(_super) {
  tslib$3.__extends(Concast2, _super);
  function Concast2(sources) {
    var _this = _super.call(this, function(observer) {
      _this.addObserver(observer);
      return function() {
        return _this.removeObserver(observer);
      };
    }) || this;
    _this.observers = /* @__PURE__ */ new Set();
    _this.promise = new Promise(function(resolve, reject) {
      _this.resolve = resolve;
      _this.reject = reject;
    });
    _this.handlers = {
      next: function(result) {
        if (_this.sub !== null) {
          _this.latest = ["next", result];
          _this.notify("next", result);
          iterateObserversSafely(_this.observers, "next", result);
        }
      },
      error: function(error) {
        var sub = _this.sub;
        if (sub !== null) {
          if (sub)
            setTimeout(function() {
              return sub.unsubscribe();
            });
          _this.sub = null;
          _this.latest = ["error", error];
          _this.reject(error);
          _this.notify("error", error);
          iterateObserversSafely(_this.observers, "error", error);
        }
      },
      complete: function() {
        var _a3 = _this, sub = _a3.sub, _b2 = _a3.sources, sources2 = _b2 === void 0 ? [] : _b2;
        if (sub !== null) {
          var value = sources2.shift();
          if (!value) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            if (_this.latest && _this.latest[0] === "next") {
              _this.resolve(_this.latest[1]);
            } else {
              _this.resolve();
            }
            _this.notify("complete");
            iterateObserversSafely(_this.observers, "complete");
          } else if (isPromiseLike(value)) {
            value.then(function(obs) {
              return _this.sub = obs.subscribe(_this.handlers);
            }, _this.handlers.error);
          } else {
            _this.sub = value.subscribe(_this.handlers);
          }
        }
      }
    };
    _this.nextResultListeners = /* @__PURE__ */ new Set();
    _this.cancel = function(reason) {
      _this.reject(reason);
      _this.sources = [];
      _this.handlers.complete();
    };
    _this.promise.catch(function(_2) {
    });
    if (typeof sources === "function") {
      sources = [new zenObservableTs.Observable(sources)];
    }
    if (isPromiseLike(sources)) {
      sources.then(function(iterable) {
        return _this.start(iterable);
      }, _this.handlers.error);
    } else {
      _this.start(sources);
    }
    return _this;
  }
  Concast2.prototype.start = function(sources) {
    if (this.sub !== void 0)
      return;
    this.sources = Array.from(sources);
    this.handlers.complete();
  };
  Concast2.prototype.deliverLastMessage = function(observer) {
    if (this.latest) {
      var nextOrError = this.latest[0];
      var method = observer[nextOrError];
      if (method) {
        method.call(observer, this.latest[1]);
      }
      if (this.sub === null && nextOrError === "next" && observer.complete) {
        observer.complete();
      }
    }
  };
  Concast2.prototype.addObserver = function(observer) {
    if (!this.observers.has(observer)) {
      this.deliverLastMessage(observer);
      this.observers.add(observer);
    }
  };
  Concast2.prototype.removeObserver = function(observer) {
    if (this.observers.delete(observer) && this.observers.size < 1) {
      this.handlers.complete();
    }
  };
  Concast2.prototype.notify = function(method, arg) {
    var nextResultListeners = this.nextResultListeners;
    if (nextResultListeners.size) {
      this.nextResultListeners = /* @__PURE__ */ new Set();
      nextResultListeners.forEach(function(listener) {
        return listener(method, arg);
      });
    }
  };
  Concast2.prototype.beforeNext = function(callback) {
    var called = false;
    this.nextResultListeners.add(function(method, arg) {
      if (!called) {
        called = true;
        callback(method, arg);
      }
    });
  };
  return Concast2;
}(zenObservableTs.Observable);
fixObservableSubclass(Concast);
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(_a3) {
      var data = _a3.data, path = _a3.path;
      for (var i2 = path.length - 1; i2 >= 0; --i2) {
        var key = path[i2];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}
function graphQLResultHasError(result) {
  var errors2 = getGraphQLErrorsFromResult(result);
  return isNonEmptyArray(errors2);
}
function getGraphQLErrorsFromResult(result) {
  var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}
function compact() {
  var objects = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    objects[_i2] = arguments[_i2];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  var count2 = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count2 + 1);
  return "".concat(prefix, ":").concat(count2, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value, space) {
  if (space === void 0) {
    space = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}
function mergeOptions(defaults, options2) {
  return compact(defaults, options2, options2.variables && {
    variables: compact(tslib$3.__assign(tslib$3.__assign({}, defaults && defaults.variables), options2.variables))
  });
}
function omitDeep(value, key) {
  return __omitDeep(value, key);
}
function __omitDeep(value, key, known) {
  if (known === void 0) {
    known = /* @__PURE__ */ new Map();
  }
  if (known.has(value)) {
    return known.get(value);
  }
  var modified = false;
  if (Array.isArray(value)) {
    var array_1 = [];
    known.set(value, array_1);
    value.forEach(function(value2, index2) {
      var result = __omitDeep(value2, key, known);
      modified || (modified = result !== value2);
      array_1[index2] = result;
    });
    if (modified) {
      return array_1;
    }
  } else if (isPlainObject$1(value)) {
    var obj_1 = Object.create(Object.getPrototypeOf(value));
    known.set(value, obj_1);
    Object.keys(value).forEach(function(k2) {
      if (k2 === key) {
        modified = true;
        return;
      }
      var result = __omitDeep(value[k2], key, known);
      modified || (modified = result !== value[k2]);
      obj_1[k2] = result;
    });
    if (modified) {
      return obj_1;
    }
  }
  return value;
}
function stripTypename(value) {
  return omitDeep(value, "__typename");
}
utilities$3.DEV = globals$2.DEV;
utilities$3.maybe = globals$2.maybe;
utilities$3.Observable = zenObservableTs.Observable;
utilities$3.AutoCleanedStrongCache = AutoCleanedStrongCache;
utilities$3.AutoCleanedWeakCache = AutoCleanedWeakCache;
utilities$3.Concast = Concast;
utilities$3.DeepMerger = DeepMerger;
utilities$3.DocumentTransform = DocumentTransform;
utilities$3.addTypenameToDocument = addTypenameToDocument;
utilities$3.argumentsObjectFromField = argumentsObjectFromField;
utilities$3.asyncMap = asyncMap;
utilities$3.buildQueryFromSelectionSet = buildQueryFromSelectionSet;
utilities$3.cacheSizes = cacheSizes;
utilities$3.canUseAsyncIteratorSymbol = canUseAsyncIteratorSymbol;
utilities$3.canUseDOM = canUseDOM;
utilities$3.canUseLayoutEffect = canUseLayoutEffect;
utilities$3.canUseSymbol = canUseSymbol;
utilities$3.canUseWeakMap = canUseWeakMap;
utilities$3.canUseWeakSet = canUseWeakSet;
utilities$3.canonicalStringify = canonicalStringify;
utilities$3.checkDocument = checkDocument;
utilities$3.cloneDeep = cloneDeep;
utilities$3.compact = compact;
utilities$3.concatPagination = concatPagination;
utilities$3.createFragmentMap = createFragmentMap;
utilities$3.createFulfilledPromise = createFulfilledPromise;
utilities$3.createRejectedPromise = createRejectedPromise;
utilities$3.fixObservableSubclass = fixObservableSubclass;
utilities$3.getDefaultValues = getDefaultValues;
utilities$3.getDirectiveNames = getDirectiveNames;
utilities$3.getFragmentDefinition = getFragmentDefinition;
utilities$3.getFragmentDefinitions = getFragmentDefinitions;
utilities$3.getFragmentFromSelection = getFragmentFromSelection;
utilities$3.getFragmentQueryDocument = getFragmentQueryDocument;
utilities$3.getGraphQLErrorsFromResult = getGraphQLErrorsFromResult;
utilities$3.getInclusionDirectives = getInclusionDirectives;
var getMainDefinition_1 = utilities$3.getMainDefinition = getMainDefinition;
utilities$3.getOperationDefinition = getOperationDefinition;
utilities$3.getOperationName = getOperationName;
utilities$3.getQueryDefinition = getQueryDefinition;
utilities$3.getStoreKeyName = getStoreKeyName;
utilities$3.getTypenameFromResult = getTypenameFromResult;
utilities$3.graphQLResultHasError = graphQLResultHasError;
utilities$3.hasAllDirectives = hasAllDirectives;
utilities$3.hasAnyDirectives = hasAnyDirectives;
utilities$3.hasClientExports = hasClientExports;
utilities$3.hasDirectives = hasDirectives;
utilities$3.isApolloPayloadResult = isApolloPayloadResult;
utilities$3.isArray = isArray;
utilities$3.isDocumentNode = isDocumentNode;
utilities$3.isExecutionPatchIncrementalResult = isExecutionPatchIncrementalResult;
utilities$3.isExecutionPatchInitialResult = isExecutionPatchInitialResult;
utilities$3.isExecutionPatchResult = isExecutionPatchResult;
utilities$3.isField = isField;
utilities$3.isInlineFragment = isInlineFragment;
utilities$3.isMutationOperation = isMutationOperation;
utilities$3.isNonEmptyArray = isNonEmptyArray;
utilities$3.isNonNullObject = isNonNullObject;
utilities$3.isPlainObject = isPlainObject$1;
utilities$3.isQueryOperation = isQueryOperation;
utilities$3.isReference = isReference;
utilities$3.isStatefulPromise = isStatefulPromise;
utilities$3.isSubscriptionOperation = isSubscriptionOperation;
utilities$3.iterateObserversSafely = iterateObserversSafely;
utilities$3.makeReference = makeReference;
utilities$3.makeUniqueId = makeUniqueId;
utilities$3.maybeDeepFreeze = maybeDeepFreeze;
utilities$3.mergeDeep = mergeDeep;
utilities$3.mergeDeepArray = mergeDeepArray;
utilities$3.mergeIncrementalData = mergeIncrementalData;
utilities$3.mergeOptions = mergeOptions;
utilities$3.offsetLimitPagination = offsetLimitPagination;
utilities$3.omitDeep = omitDeep;
utilities$3.print = print$1;
utilities$3.relayStylePagination = relayStylePagination;
utilities$3.removeArgumentsFromDocument = removeArgumentsFromDocument;
utilities$3.removeClientSetsFromDocument = removeClientSetsFromDocument;
utilities$3.removeConnectionDirectiveFromDocument = removeConnectionDirectiveFromDocument;
utilities$3.removeDirectivesFromDocument = removeDirectivesFromDocument;
utilities$3.removeFragmentSpreadFromDocument = removeFragmentSpreadFromDocument;
utilities$3.resultKeyNameFromField = resultKeyNameFromField;
utilities$3.shouldInclude = shouldInclude;
utilities$3.storeKeyNameFromField = storeKeyNameFromField;
utilities$3.stringifyForDisplay = stringifyForDisplay;
utilities$3.stripTypename = stripTypename;
utilities$3.valueToObjectRepresentation = valueToObjectRepresentation;
utilities$3.wrapPromiseWithState = wrapPromiseWithState;
const fragmentRegistry = cache$1.createFragmentRegistry();
var hooks = {};
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(context$2);
const require$$7$1 = /* @__PURE__ */ getAugmentedNamespace(errors$1);
const require$$7 = /* @__PURE__ */ getAugmentedNamespace(core$4);
const require$$8 = /* @__PURE__ */ getAugmentedNamespace(parser$2);
const require$$9 = /* @__PURE__ */ getAugmentedNamespace(internal$1);
const require$$6 = /* @__PURE__ */ getAugmentedNamespace(cache$3);
Object.defineProperty(hooks, "__esModule", { value: true });
var globals$1 = require$$1;
var React = rehacktExports;
var context$1 = require$$2;
var tslib$2 = require$$0;
var utilities$2 = require$$2$1;
var equal$1 = require$$4;
var errors = require$$7$1;
var core$3 = require$$7;
var parser = require$$8;
var internal = require$$9;
var cache = require$$6;
function _interopDefaultLegacy(e2) {
  return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
}
function _interopNamespace(e2) {
  if (e2 && e2.__esModule) return e2;
  var n2 = /* @__PURE__ */ Object.create(null);
  if (e2) {
    for (var k2 in e2) {
      n2[k2] = e2[k2];
    }
  }
  n2["default"] = e2;
  return Object.freeze(n2);
}
var React__namespace = /* @__PURE__ */ _interopNamespace(React);
var equal__default = /* @__PURE__ */ _interopDefaultLegacy(equal$1);
function useApolloClient(override) {
  var context$1$1 = React__namespace.useContext(context$1.getApolloContext());
  var client = override || context$1$1.client;
  globals$1.invariant(!!client, 49);
  return client;
}
var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook$1 = React__namespace[uSESKey];
var useSyncExternalStore = realHook$1 || function(subscribe2, getSnapshot, getServerSnapshot) {
  var value = getSnapshot();
  if (globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && value !== getSnapshot()) {
    didWarnUncachedGetSnapshot = true;
    globalThis.__DEV__ !== false && globals$1.invariant.error(59);
  }
  var _a3 = React__namespace.useState({
    inst: { value, getSnapshot }
  }), inst = _a3[0].inst, forceUpdate = _a3[1];
  if (utilities$2.canUseLayoutEffect) {
    React__namespace.useLayoutEffect(function() {
      Object.assign(inst, { value, getSnapshot });
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    }, [subscribe2, value, getSnapshot]);
  } else {
    Object.assign(inst, { value, getSnapshot });
  }
  React__namespace.useEffect(function() {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({ inst });
    }
    return subscribe2(function handleStoreChange() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    });
  }, [subscribe2]);
  return value;
};
function checkIfSnapshotChanged(_a3) {
  var value = _a3.value, getSnapshot = _a3.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b2) {
    return true;
  }
}
function useDeepMemo(memoFn, deps) {
  var ref = React__namespace.useRef();
  if (!ref.current || !equal$1.equal(ref.current.deps, deps)) {
    ref.current = { value: memoFn(), deps };
  }
  return ref.current.value;
}
var useIsomorphicLayoutEffect = utilities$2.canUseDOM ? React__namespace.useLayoutEffect : React__namespace.useEffect;
var Ctx;
function noop$1() {
}
function useRenderGuard() {
  if (!Ctx) {
    Ctx = React__namespace.createContext(null);
  }
  return React__namespace.useCallback(
    function() {
      var orig = console.error;
      try {
        console.error = noop$1;
        React__namespace["useContext"](Ctx);
        return true;
      } catch (e2) {
        return false;
      } finally {
        console.error = orig;
      }
    },
    []
  );
}
var INIT = {};
function useLazyRef(getInitialValue) {
  var ref = React__namespace.useRef(INIT);
  if (ref.current === INIT) {
    ref.current = getInitialValue();
  }
  return ref;
}
var useKey = "use";
var realHook = React__namespace[useKey];
var __use = realHook || function __use2(promise) {
  var statefulPromise = utilities$2.wrapPromiseWithState(promise);
  switch (statefulPromise.status) {
    case "pending":
      throw statefulPromise;
    case "rejected":
      throw statefulPromise.reason;
    case "fulfilled":
      return statefulPromise.value;
  }
};
var wrapperSymbol = Symbol.for("apollo.hook.wrappers");
function wrapHook(hookName, useHook, clientOrObsQuery) {
  var queryManager = clientOrObsQuery["queryManager"];
  var wrappers = queryManager && queryManager[wrapperSymbol];
  var wrapper = wrappers && wrappers[hookName];
  return wrapper ? wrapper(useHook) : useHook;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function noop() {
}
var lastWatchOptions = Symbol();
function useQuery(query, options2) {
  if (options2 === void 0) {
    options2 = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useQuery", _useQuery, useApolloClient(options2 && options2.client))(query, options2);
}
function _useQuery(query, options2) {
  var _a3 = useQueryInternals(query, options2), result = _a3.result, obsQueryFields = _a3.obsQueryFields;
  return React__namespace.useMemo(function() {
    return tslib$2.__assign(tslib$2.__assign({}, result), obsQueryFields);
  }, [result, obsQueryFields]);
}
function useInternalState(client, query, options2, renderPromises, makeWatchQueryOptions) {
  function createInternalState(previous) {
    var _a4;
    parser.verifyDocumentType(query, parser.DocumentType.Query);
    var internalState2 = {
      client,
      query,
      observable: renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions(void 0, client, options2, makeWatchQueryOptions())),
      resultData: {
        previousData: (_a4 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a4 === void 0 ? void 0 : _a4.data
      }
    };
    return internalState2;
  }
  var _a3 = React__namespace.useState(createInternalState), internalState = _a3[0], updateInternalState = _a3[1];
  function onQueryExecuted(watchQueryOptions) {
    var _a4;
    var _b2;
    Object.assign(internalState.observable, (_a4 = {}, _a4[lastWatchOptions] = watchQueryOptions, _a4));
    var resultData = internalState.resultData;
    updateInternalState(tslib$2.__assign(tslib$2.__assign({}, internalState), {
      query: watchQueryOptions.query,
      resultData: Object.assign(resultData, {
        previousData: ((_b2 = resultData.current) === null || _b2 === void 0 ? void 0 : _b2.data) || resultData.previousData,
        current: void 0
      })
    }));
  }
  if (client !== internalState.client || query !== internalState.query) {
    var newInternalState = createInternalState(internalState);
    updateInternalState(newInternalState);
    return [newInternalState, onQueryExecuted];
  }
  return [internalState, onQueryExecuted];
}
function useQueryInternals(query, options2) {
  var client = useApolloClient(options2.client);
  var renderPromises = React__namespace.useContext(context$1.getApolloContext()).renderPromises;
  var isSyncSSR = !!renderPromises;
  var disableNetworkFetches = client.disableNetworkFetches;
  var ssrAllowed = options2.ssr !== false && !options2.skip;
  var partialRefetch = options2.partialRefetch;
  var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options2, isSyncSSR);
  var _a3 = useInternalState(client, query, options2, renderPromises, makeWatchQueryOptions), _b2 = _a3[0], observable = _b2.observable, resultData = _b2.resultData, onQueryExecuted = _a3[1];
  var watchQueryOptions = makeWatchQueryOptions(observable);
  useResubscribeIfNecessary(
    resultData,
    observable,
    client,
    options2,
    watchQueryOptions
  );
  var obsQueryFields = React__namespace.useMemo(function() {
    return bindObservableMethods(observable);
  }, [observable]);
  useRegisterSSRObservable(observable, renderPromises, ssrAllowed);
  var result = useObservableSubscriptionResult(resultData, observable, client, options2, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
    onCompleted: options2.onCompleted || noop,
    onError: options2.onError || noop
  });
  return {
    result,
    obsQueryFields,
    observable,
    resultData,
    client,
    onQueryExecuted
  };
}
function useObservableSubscriptionResult(resultData, observable, client, options2, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
  var callbackRef = React__namespace.useRef(callbacks);
  React__namespace.useEffect(function() {
    callbackRef.current = callbacks;
  });
  var resultOverride = (isSyncSSR || disableNetworkFetches) && options2.ssr === false && !options2.skip ? ssrDisabledResult : options2.skip || watchQueryOptions.fetchPolicy === "standby" ? skipStandbyResult : void 0;
  var previousData = resultData.previousData;
  var currentResultOverride = React__namespace.useMemo(function() {
    return resultOverride && toQueryResult(resultOverride, previousData, observable, client);
  }, [client, observable, resultOverride, previousData]);
  return useSyncExternalStore(React__namespace.useCallback(function(handleStoreChange) {
    if (isSyncSSR) {
      return function() {
      };
    }
    var onNext = function() {
      var previousResult = resultData.current;
      var result = observable.getCurrentResult();
      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal$1.equal(previousResult.data, result.data)) {
        return;
      }
      setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
    };
    var onError = function(error) {
      subscription.current.unsubscribe();
      subscription.current = observable.resubscribeAfterError(onNext, onError);
      if (!hasOwnProperty.call(error, "graphQLErrors")) {
        throw error;
      }
      var previousResult = resultData.current;
      if (!previousResult || previousResult && previousResult.loading || !equal$1.equal(error, previousResult.error)) {
        setResult({
          data: previousResult && previousResult.data,
          error,
          loading: false,
          networkStatus: core$3.NetworkStatus.error
        }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
      }
    };
    var subscription = { current: observable.subscribe(onNext, onError) };
    return function() {
      setTimeout(function() {
        return subscription.current.unsubscribe();
      });
    };
  }, [
    disableNetworkFetches,
    isSyncSSR,
    observable,
    resultData,
    partialRefetch,
    client
  ]), function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  }, function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  });
}
function useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {
  if (renderPromises && ssrAllowed) {
    renderPromises.registerSSRObservable(observable);
    if (observable.getCurrentResult().loading) {
      renderPromises.addObservableQueryPromise(observable);
    }
  }
}
function useResubscribeIfNecessary(resultData, observable, client, options2, watchQueryOptions) {
  var _a3;
  if (observable[lastWatchOptions] && !equal$1.equal(observable[lastWatchOptions], watchQueryOptions)) {
    observable.reobserve(getObsQueryOptions(observable, client, options2, watchQueryOptions));
    resultData.previousData = ((_a3 = resultData.current) === null || _a3 === void 0 ? void 0 : _a3.data) || resultData.previousData;
    resultData.current = void 0;
  }
  observable[lastWatchOptions] = watchQueryOptions;
}
function createMakeWatchQueryOptions(client, query, _a3, isSyncSSR) {
  if (_a3 === void 0) {
    _a3 = {};
  }
  var skip = _a3.skip;
  _a3.ssr;
  _a3.onCompleted;
  _a3.onError;
  var defaultOptions2 = _a3.defaultOptions, otherOptions = tslib$2.__rest(_a3, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
  return function(observable) {
    var watchQueryOptions = Object.assign(otherOptions, { query });
    if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
      watchQueryOptions.fetchPolicy = "cache-first";
    }
    if (!watchQueryOptions.variables) {
      watchQueryOptions.variables = {};
    }
    if (skip) {
      watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
      watchQueryOptions.fetchPolicy = "standby";
    } else if (!watchQueryOptions.fetchPolicy) {
      watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
    }
    return watchQueryOptions;
  };
}
function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {
  var toMerge = [];
  var globalDefaults = client.defaultOptions.watchQuery;
  if (globalDefaults)
    toMerge.push(globalDefaults);
  if (queryHookOptions.defaultOptions) {
    toMerge.push(queryHookOptions.defaultOptions);
  }
  toMerge.push(utilities$2.compact(observable && observable.options, watchQueryOptions));
  return toMerge.reduce(utilities$2.mergeOptions);
}
function setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
  var previousResult = resultData.current;
  if (previousResult && previousResult.data) {
    resultData.previousData = previousResult.data;
  }
  if (!nextResult.error && utilities$2.isNonEmptyArray(nextResult.errors)) {
    nextResult.error = new errors.ApolloError({ graphQLErrors: nextResult.errors });
  }
  resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
  forceUpdate();
  handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
}
function handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {
  if (!result.loading) {
    var error_1 = toApolloError$1(result);
    Promise.resolve().then(function() {
      if (error_1) {
        callbacks.onError(error_1);
      } else if (result.data && previousNetworkStatus !== result.networkStatus && result.networkStatus === core$3.NetworkStatus.ready) {
        callbacks.onCompleted(result.data);
      }
    }).catch(function(error) {
      globalThis.__DEV__ !== false && globals$1.invariant.warn(error);
    });
  }
}
function getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {
  if (!resultData.current) {
    setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
    }, callbacks);
  }
  return resultData.current;
}
function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {
  var _a3;
  return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a3 = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a3 === void 0 ? void 0 : _a3.fetchPolicy) || "cache-first";
}
function toApolloError$1(result) {
  return utilities$2.isNonEmptyArray(result.errors) ? new errors.ApolloError({ graphQLErrors: result.errors }) : result.error;
}
function toQueryResult(result, previousData, observable, client) {
  var data = result.data;
  result.partial;
  var resultWithoutPartial = tslib$2.__rest(result, ["data", "partial"]);
  var queryResult = tslib$2.__assign(tslib$2.__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData });
  return queryResult;
}
function unsafeHandlePartialRefetch(result, observable, partialRefetch) {
  if (result.partial && partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
    observable.refetch();
    return tslib$2.__assign(tslib$2.__assign({}, result), { loading: true, networkStatus: core$3.NetworkStatus.refetch });
  }
  return result;
}
var ssrDisabledResult = utilities$2.maybeDeepFreeze({
  loading: true,
  data: void 0,
  error: void 0,
  networkStatus: core$3.NetworkStatus.loading
});
var skipStandbyResult = utilities$2.maybeDeepFreeze({
  loading: false,
  data: void 0,
  error: void 0,
  networkStatus: core$3.NetworkStatus.ready
});
function bindObservableMethods(observable) {
  return {
    refetch: observable.refetch.bind(observable),
    reobserve: observable.reobserve.bind(observable),
    fetchMore: observable.fetchMore.bind(observable),
    updateQuery: observable.updateQuery.bind(observable),
    startPolling: observable.startPolling.bind(observable),
    stopPolling: observable.stopPolling.bind(observable),
    subscribeToMore: observable.subscribeToMore.bind(observable)
  };
}
var EAGER_METHODS = [
  "refetch",
  "reobserve",
  "fetchMore",
  "updateQuery",
  "startPolling",
  "stopPolling",
  "subscribeToMore"
];
function useLazyQuery(query, options2) {
  var _a3;
  var execOptionsRef = React__namespace.useRef();
  var optionsRef = React__namespace.useRef();
  var queryRef = React__namespace.useRef();
  var merged = utilities$2.mergeOptions(options2, execOptionsRef.current || {});
  var document2 = (_a3 = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a3 !== void 0 ? _a3 : query;
  optionsRef.current = options2;
  queryRef.current = document2;
  var queryHookOptions = tslib$2.__assign(tslib$2.__assign({}, merged), { skip: !execOptionsRef.current });
  var _b2 = useQueryInternals(document2, queryHookOptions), obsQueryFields = _b2.obsQueryFields, useQueryResult = _b2.result, client = _b2.client, resultData = _b2.resultData, observable = _b2.observable, onQueryExecuted = _b2.onQueryExecuted;
  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);
  var forceUpdateState = React__namespace.useReducer(function(tick) {
    return tick + 1;
  }, 0)[1];
  var eagerMethods = React__namespace.useMemo(function() {
    var eagerMethods2 = {};
    var _loop_1 = function(key2) {
      var method = obsQueryFields[key2];
      eagerMethods2[key2] = function() {
        if (!execOptionsRef.current) {
          execOptionsRef.current = /* @__PURE__ */ Object.create(null);
          forceUpdateState();
        }
        return method.apply(this, arguments);
      };
    };
    for (var _i2 = 0, EAGER_METHODS_1 = EAGER_METHODS; _i2 < EAGER_METHODS_1.length; _i2++) {
      var key = EAGER_METHODS_1[_i2];
      _loop_1(key);
    }
    return eagerMethods2;
  }, [forceUpdateState, obsQueryFields]);
  var called = !!execOptionsRef.current;
  var result = React__namespace.useMemo(function() {
    return tslib$2.__assign(tslib$2.__assign(tslib$2.__assign({}, useQueryResult), eagerMethods), { called });
  }, [useQueryResult, eagerMethods, called]);
  var execute2 = React__namespace.useCallback(function(executeOptions) {
    execOptionsRef.current = executeOptions ? tslib$2.__assign(tslib$2.__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
      fetchPolicy: initialFetchPolicy
    };
    var options3 = utilities$2.mergeOptions(optionsRef.current, tslib$2.__assign({ query: queryRef.current }, execOptionsRef.current));
    var promise = executeQuery(resultData, observable, client, document2, tslib$2.__assign(tslib$2.__assign({}, options3), { skip: false }), onQueryExecuted).then(function(queryResult) {
      return Object.assign(queryResult, eagerMethods);
    });
    promise.catch(function() {
    });
    return promise;
  }, [
    client,
    document2,
    eagerMethods,
    initialFetchPolicy,
    observable,
    resultData,
    onQueryExecuted
  ]);
  var executeRef = React__namespace.useRef(execute2);
  useIsomorphicLayoutEffect(function() {
    executeRef.current = execute2;
  });
  var stableExecute = React__namespace.useCallback(function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    return executeRef.current.apply(executeRef, args);
  }, []);
  return [stableExecute, result];
}
function executeQuery(resultData, observable, client, currentQuery, options2, onQueryExecuted) {
  var query = options2.query || currentQuery;
  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options2, false)(observable);
  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options2, watchQueryOptions));
  onQueryExecuted(watchQueryOptions);
  return new Promise(function(resolve) {
    var result;
    concast.subscribe({
      next: function(value) {
        result = value;
      },
      error: function() {
        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));
      },
      complete: function() {
        resolve(toQueryResult(result, resultData.previousData, observable, client));
      }
    });
  });
}
function useMutation(mutation, options2) {
  var client = useApolloClient(options2 === null || options2 === void 0 ? void 0 : options2.client);
  parser.verifyDocumentType(mutation, parser.DocumentType.Mutation);
  var _a3 = React__namespace.useState({
    called: false,
    loading: false,
    client
  }), result = _a3[0], setResult2 = _a3[1];
  var ref = React__namespace.useRef({
    result,
    mutationId: 0,
    isMounted: true,
    client,
    mutation,
    options: options2
  });
  useIsomorphicLayoutEffect(function() {
    Object.assign(ref.current, { client, options: options2, mutation });
  });
  var execute2 = React__namespace.useCallback(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a4 = ref.current, options3 = _a4.options, mutation2 = _a4.mutation;
    var baseOptions = tslib$2.__assign(tslib$2.__assign({}, options3), { mutation: mutation2 });
    var client2 = executeOptions.client || ref.current.client;
    if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
      setResult2(ref.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client2
      });
    }
    var mutationId = ++ref.current.mutationId;
    var clientOptions = utilities$2.mergeOptions(baseOptions, executeOptions);
    return client2.mutate(clientOptions).then(function(response) {
      var _a5, _b2;
      var data = response.data, errors$12 = response.errors;
      var error = errors$12 && errors$12.length > 0 ? new errors.ApolloError({ graphQLErrors: errors$12 }) : void 0;
      var onError = executeOptions.onError || ((_a5 = ref.current.options) === null || _a5 === void 0 ? void 0 : _a5.onError);
      if (error && onError) {
        onError(error, clientOptions);
      }
      if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data,
          error,
          client: client2
        };
        if (ref.current.isMounted && !equal$1.equal(ref.current.result, result_1)) {
          setResult2(ref.current.result = result_1);
        }
      }
      var onCompleted = executeOptions.onCompleted || ((_b2 = ref.current.options) === null || _b2 === void 0 ? void 0 : _b2.onCompleted);
      if (!error) {
        onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
      }
      return response;
    }).catch(function(error) {
      var _a5;
      if (mutationId === ref.current.mutationId && ref.current.isMounted) {
        var result_2 = {
          loading: false,
          error,
          data: void 0,
          called: true,
          client: client2
        };
        if (!equal$1.equal(ref.current.result, result_2)) {
          setResult2(ref.current.result = result_2);
        }
      }
      var onError = executeOptions.onError || ((_a5 = ref.current.options) === null || _a5 === void 0 ? void 0 : _a5.onError);
      if (onError) {
        onError(error, clientOptions);
        return { data: void 0, errors: error };
      }
      throw error;
    });
  }, []);
  var reset = React__namespace.useCallback(function() {
    if (ref.current.isMounted) {
      var result_3 = {
        called: false,
        loading: false,
        client: ref.current.client
      };
      Object.assign(ref.current, { mutationId: 0, result: result_3 });
      setResult2(result_3);
    }
  }, []);
  React__namespace.useEffect(function() {
    var current = ref.current;
    current.isMounted = true;
    return function() {
      current.isMounted = false;
    };
  }, []);
  return [execute2, tslib$2.__assign({ reset }, result)];
}
function useSubscription(subscription, options2) {
  if (options2 === void 0) {
    options2 = /* @__PURE__ */ Object.create(null);
  }
  var hasIssuedDeprecationWarningRef = React__namespace.useRef(false);
  var client = useApolloClient(options2.client);
  parser.verifyDocumentType(subscription, parser.DocumentType.Subscription);
  if (!hasIssuedDeprecationWarningRef.current) {
    hasIssuedDeprecationWarningRef.current = true;
    if (options2.onSubscriptionData) {
      globalThis.__DEV__ !== false && globals$1.invariant.warn(options2.onData ? 52 : 53);
    }
    if (options2.onSubscriptionComplete) {
      globalThis.__DEV__ !== false && globals$1.invariant.warn(options2.onComplete ? 54 : 55);
    }
  }
  var skip = options2.skip, fetchPolicy = options2.fetchPolicy, errorPolicy = options2.errorPolicy, shouldResubscribe = options2.shouldResubscribe, context2 = options2.context, extensions = options2.extensions, ignoreResults = options2.ignoreResults;
  var variables = useDeepMemo(function() {
    return options2.variables;
  }, [options2.variables]);
  var recreate = function() {
    return createSubscription(client, subscription, variables, fetchPolicy, errorPolicy, context2, extensions);
  };
  var _a3 = React__namespace.useState(options2.skip ? null : recreate), observable = _a3[0], setObservable = _a3[1];
  var recreateRef = React__namespace.useRef(recreate);
  useIsomorphicLayoutEffect(function() {
    recreateRef.current = recreate;
  });
  if (skip) {
    if (observable) {
      setObservable(observable = null);
    }
  } else if (!observable || (client !== observable.__.client || subscription !== observable.__.query || fetchPolicy !== observable.__.fetchPolicy || errorPolicy !== observable.__.errorPolicy || !equal$1.equal(variables, observable.__.variables)) && (typeof shouldResubscribe === "function" ? !!shouldResubscribe(options2) : shouldResubscribe) !== false) {
    setObservable(observable = recreate());
  }
  var optionsRef = React__namespace.useRef(options2);
  React__namespace.useEffect(function() {
    optionsRef.current = options2;
  });
  var fallbackLoading = !skip && !ignoreResults;
  var fallbackResult = React__namespace.useMemo(function() {
    return {
      loading: fallbackLoading,
      error: void 0,
      data: void 0,
      variables
    };
  }, [fallbackLoading, variables]);
  var ignoreResultsRef = React__namespace.useRef(ignoreResults);
  useIsomorphicLayoutEffect(function() {
    ignoreResultsRef.current = ignoreResults;
  });
  var ret = useSyncExternalStore(React__namespace.useCallback(function(update) {
    if (!observable) {
      return function() {
      };
    }
    var subscriptionStopped = false;
    var variables2 = observable.__.variables;
    var client2 = observable.__.client;
    var subscription2 = observable.subscribe({
      next: function(fetchResult) {
        var _a4, _b2;
        if (subscriptionStopped) {
          return;
        }
        var result = {
          loading: false,
          data: fetchResult.data,
          error: toApolloError$1(fetchResult),
          variables: variables2
        };
        observable.__.setResult(result);
        if (!ignoreResultsRef.current)
          update();
        if (result.error) {
          (_b2 = (_a4 = optionsRef.current).onError) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, result.error);
        } else if (optionsRef.current.onData) {
          optionsRef.current.onData({
            client: client2,
            data: result
          });
        } else if (optionsRef.current.onSubscriptionData) {
          optionsRef.current.onSubscriptionData({
            client: client2,
            subscriptionData: result
          });
        }
      },
      error: function(error) {
        var _a4, _b2;
        error = error instanceof core$3.ApolloError ? error : new core$3.ApolloError({ protocolErrors: [error] });
        if (!subscriptionStopped) {
          observable.__.setResult({
            loading: false,
            data: void 0,
            error,
            variables: variables2
          });
          if (!ignoreResultsRef.current)
            update();
          (_b2 = (_a4 = optionsRef.current).onError) === null || _b2 === void 0 ? void 0 : _b2.call(_a4, error);
        }
      },
      complete: function() {
        if (!subscriptionStopped) {
          if (optionsRef.current.onComplete) {
            optionsRef.current.onComplete();
          } else if (optionsRef.current.onSubscriptionComplete) {
            optionsRef.current.onSubscriptionComplete();
          }
        }
      }
    });
    return function() {
      subscriptionStopped = true;
      setTimeout(function() {
        subscription2.unsubscribe();
      });
    };
  }, [observable]), function() {
    return observable && !skip && !ignoreResults ? observable.__.result : fallbackResult;
  });
  return React__namespace.useMemo(function() {
    return tslib$2.__assign(tslib$2.__assign({}, ret), { restart: function() {
      globals$1.invariant(!optionsRef.current.skip, 56);
      setObservable(recreateRef.current());
    } });
  }, [ret]);
}
function createSubscription(client, query, variables, fetchPolicy, errorPolicy, context2, extensions) {
  var options2 = {
    query,
    variables,
    fetchPolicy,
    errorPolicy,
    context: context2,
    extensions
  };
  var __ = tslib$2.__assign(tslib$2.__assign({}, options2), { client, result: {
    loading: true,
    data: void 0,
    error: void 0,
    variables
  }, setResult: function(result) {
    __.result = result;
  } });
  var observable = null;
  return Object.assign(new core$3.Observable(function(observer) {
    if (!observable) {
      observable = client.subscribe(options2);
    }
    var sub = observable.subscribe(observer);
    return function() {
      return sub.unsubscribe();
    };
  }), {
    __
  });
}
function useReactiveVar(rv) {
  return useSyncExternalStore(React__namespace.useCallback(function(update) {
    return rv.onNextChange(function onNext() {
      update();
      rv.onNextChange(onNext);
    });
  }, [rv]), rv, rv);
}
function useFragment(options2) {
  return wrapHook("useFragment", _useFragment, useApolloClient(options2.client))(options2);
}
function _useFragment(options2) {
  var cache2 = useApolloClient(options2.client).cache;
  var diffOptions = useDeepMemo(function() {
    var fragment = options2.fragment, fragmentName = options2.fragmentName, from2 = options2.from, _a3 = options2.optimistic, optimistic = _a3 === void 0 ? true : _a3, rest = tslib$2.__rest(options2, ["fragment", "fragmentName", "from", "optimistic"]);
    return tslib$2.__assign(tslib$2.__assign({}, rest), { returnPartialData: true, id: typeof from2 === "string" ? from2 : cache2.identify(from2), query: cache2["getFragmentDoc"](fragment, fragmentName), optimistic });
  }, [options2]);
  var resultRef = useLazyRef(function() {
    return diffToResult(cache2.diff(diffOptions));
  });
  var stableOptions = useDeepMemo(function() {
    return options2;
  }, [options2]);
  React__namespace.useMemo(function() {
    resultRef.current = diffToResult(cache2.diff(diffOptions));
  }, [diffOptions, cache2]);
  var getSnapshot = React__namespace.useCallback(function() {
    return resultRef.current;
  }, []);
  return useSyncExternalStore(React__namespace.useCallback(function(forceUpdate) {
    var lastTimeout = 0;
    var subscription = cache2.watchFragment(stableOptions).subscribe({
      next: function(result) {
        if (equal__default(result, resultRef.current))
          return;
        resultRef.current = result;
        clearTimeout(lastTimeout);
        lastTimeout = setTimeout(forceUpdate);
      }
    });
    return function() {
      subscription.unsubscribe();
      clearTimeout(lastTimeout);
    };
  }, [cache2, stableOptions]), getSnapshot, getSnapshot);
}
function diffToResult(diff2) {
  var result = {
    data: diff2.result,
    complete: !!diff2.complete
  };
  if (diff2.missing) {
    result.missing = utilities$2.mergeDeepArray(diff2.missing.map(function(error) {
      return error.missing;
    }));
  }
  return result;
}
var skipToken = Symbol.for("apollo.skipToken");
function useSuspenseQuery(query, options2) {
  if (options2 === void 0) {
    options2 = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useSuspenseQuery", _useSuspenseQuery, useApolloClient(typeof options2 === "object" ? options2.client : void 0))(query, options2);
}
function _useSuspenseQuery(query, options2) {
  var client = useApolloClient(options2.client);
  var suspenseCache = internal.getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({
    client,
    query,
    options: options2
  });
  var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
  var _a3 = options2.queryKey, queryKey = _a3 === void 0 ? [] : _a3;
  var cacheKey = tslib$2.__spreadArray([
    query,
    cache.canonicalStringify(variables)
  ], [].concat(queryKey), true);
  var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
    return client.watchQuery(watchQueryOptions);
  });
  var _b2 = React__namespace.useState([queryRef.key, queryRef.promise]), current = _b2[0], setPromise = _b2[1];
  if (current[0] !== queryRef.key) {
    current[0] = queryRef.key;
    current[1] = queryRef.promise;
  }
  var promise = current[1];
  if (queryRef.didChangeOptions(watchQueryOptions)) {
    current[1] = promise = queryRef.applyOptions(watchQueryOptions);
  }
  React__namespace.useEffect(function() {
    var dispose = queryRef.retain();
    var removeListener = queryRef.listen(function(promise2) {
      setPromise([queryRef.key, promise2]);
    });
    return function() {
      removeListener();
      dispose();
    };
  }, [queryRef]);
  var skipResult = React__namespace.useMemo(function() {
    var error = toApolloError(queryRef.result);
    return {
      loading: false,
      data: queryRef.result.data,
      networkStatus: error ? core$3.NetworkStatus.error : core$3.NetworkStatus.ready,
      error
    };
  }, [queryRef.result]);
  var result = fetchPolicy === "standby" ? skipResult : __use(promise);
  var fetchMore = React__namespace.useCallback(function(options3) {
    var promise2 = queryRef.fetchMore(options3);
    setPromise([queryRef.key, queryRef.promise]);
    return promise2;
  }, [queryRef]);
  var refetch = React__namespace.useCallback(function(variables2) {
    var promise2 = queryRef.refetch(variables2);
    setPromise([queryRef.key, queryRef.promise]);
    return promise2;
  }, [queryRef]);
  var subscribeToMore = queryRef.observable.subscribeToMore;
  return React__namespace.useMemo(function() {
    return {
      client,
      data: result.data,
      error: toApolloError(result),
      networkStatus: result.networkStatus,
      fetchMore,
      refetch,
      subscribeToMore
    };
  }, [client, fetchMore, refetch, result, subscribeToMore]);
}
function validateOptions(options2) {
  var query = options2.query, fetchPolicy = options2.fetchPolicy, returnPartialData = options2.returnPartialData;
  parser.verifyDocumentType(query, parser.DocumentType.Query);
  validateFetchPolicy(fetchPolicy);
  validatePartialDataReturn(fetchPolicy, returnPartialData);
}
function validateFetchPolicy(fetchPolicy) {
  if (fetchPolicy === void 0) {
    fetchPolicy = "cache-first";
  }
  var supportedFetchPolicies = [
    "cache-first",
    "network-only",
    "no-cache",
    "cache-and-network"
  ];
  globals$1.invariant(supportedFetchPolicies.includes(fetchPolicy), 57, fetchPolicy);
}
function validatePartialDataReturn(fetchPolicy, returnPartialData) {
  if (fetchPolicy === "no-cache" && returnPartialData) {
    globalThis.__DEV__ !== false && globals$1.invariant.warn(58);
  }
}
function toApolloError(result) {
  return utilities$2.isNonEmptyArray(result.errors) ? new core$3.ApolloError({ graphQLErrors: result.errors }) : result.error;
}
function useWatchQueryOptions(_a3) {
  var client = _a3.client, query = _a3.query, options2 = _a3.options;
  return useDeepMemo(function() {
    var _a4;
    if (options2 === skipToken) {
      return { query, fetchPolicy: "standby" };
    }
    var fetchPolicy = options2.fetchPolicy || ((_a4 = client.defaultOptions.watchQuery) === null || _a4 === void 0 ? void 0 : _a4.fetchPolicy) || "cache-first";
    var watchQueryOptions = tslib$2.__assign(tslib$2.__assign({}, options2), { fetchPolicy, query, notifyOnNetworkStatusChange: false, nextFetchPolicy: void 0 });
    if (globalThis.__DEV__ !== false) {
      validateOptions(watchQueryOptions);
    }
    if (options2.skip) {
      watchQueryOptions.fetchPolicy = "standby";
    }
    return watchQueryOptions;
  }, [client, options2, query]);
}
function useBackgroundQuery(query, options2) {
  if (options2 === void 0) {
    options2 = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useBackgroundQuery", _useBackgroundQuery, useApolloClient(typeof options2 === "object" ? options2.client : void 0))(query, options2);
}
function _useBackgroundQuery(query, options2) {
  var client = useApolloClient(options2.client);
  var suspenseCache = internal.getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({ client, query, options: options2 });
  var fetchPolicy = watchQueryOptions.fetchPolicy, variables = watchQueryOptions.variables;
  var _a3 = options2.queryKey, queryKey = _a3 === void 0 ? [] : _a3;
  var didFetchResult = React__namespace.useRef(fetchPolicy !== "standby");
  didFetchResult.current || (didFetchResult.current = fetchPolicy !== "standby");
  var cacheKey = tslib$2.__spreadArray([
    query,
    cache.canonicalStringify(variables)
  ], [].concat(queryKey), true);
  var queryRef = suspenseCache.getQueryRef(cacheKey, function() {
    return client.watchQuery(watchQueryOptions);
  });
  var _b2 = React__namespace.useState(internal.wrapQueryRef(queryRef)), wrappedQueryRef = _b2[0], setWrappedQueryRef = _b2[1];
  if (internal.unwrapQueryRef(wrappedQueryRef) !== queryRef) {
    setWrappedQueryRef(internal.wrapQueryRef(queryRef));
  }
  if (queryRef.didChangeOptions(watchQueryOptions)) {
    var promise = queryRef.applyOptions(watchQueryOptions);
    internal.updateWrappedQueryRef(wrappedQueryRef, promise);
  }
  React__namespace.useEffect(function() {
    var id2 = setTimeout(function() {
      if (queryRef.disposed) {
        suspenseCache.add(cacheKey, queryRef);
      }
    });
    return function() {
      return clearTimeout(id2);
    };
  });
  var fetchMore = React__namespace.useCallback(function(options3) {
    var promise2 = queryRef.fetchMore(options3);
    setWrappedQueryRef(internal.wrapQueryRef(queryRef));
    return promise2;
  }, [queryRef]);
  var refetch = React__namespace.useCallback(function(variables2) {
    var promise2 = queryRef.refetch(variables2);
    setWrappedQueryRef(internal.wrapQueryRef(queryRef));
    return promise2;
  }, [queryRef]);
  React__namespace.useEffect(function() {
    return queryRef.softRetain();
  }, [queryRef]);
  return [
    didFetchResult.current ? wrappedQueryRef : void 0,
    {
      fetchMore,
      refetch,
      subscribeToMore: queryRef.observable.subscribeToMore
    }
  ];
}
function useLoadableQuery(query, options2) {
  if (options2 === void 0) {
    options2 = /* @__PURE__ */ Object.create(null);
  }
  var client = useApolloClient(options2.client);
  var suspenseCache = internal.getSuspenseCache(client);
  var watchQueryOptions = useWatchQueryOptions({ client, query, options: options2 });
  var _a3 = options2.queryKey, queryKey = _a3 === void 0 ? [] : _a3;
  var _b2 = React__namespace.useState(null), queryRef = _b2[0], setQueryRef = _b2[1];
  internal.assertWrappedQueryRef(queryRef);
  var internalQueryRef = queryRef && internal.unwrapQueryRef(queryRef);
  if (queryRef && (internalQueryRef === null || internalQueryRef === void 0 ? void 0 : internalQueryRef.didChangeOptions(watchQueryOptions))) {
    var promise = internalQueryRef.applyOptions(watchQueryOptions);
    internal.updateWrappedQueryRef(queryRef, promise);
  }
  var calledDuringRender = useRenderGuard();
  var fetchMore = React__namespace.useCallback(function(options3) {
    if (!internalQueryRef) {
      throw new Error("The query has not been loaded. Please load the query.");
    }
    var promise2 = internalQueryRef.fetchMore(options3);
    setQueryRef(internal.wrapQueryRef(internalQueryRef));
    return promise2;
  }, [internalQueryRef]);
  var refetch = React__namespace.useCallback(function(options3) {
    if (!internalQueryRef) {
      throw new Error("The query has not been loaded. Please load the query.");
    }
    var promise2 = internalQueryRef.refetch(options3);
    setQueryRef(internal.wrapQueryRef(internalQueryRef));
    return promise2;
  }, [internalQueryRef]);
  var loadQuery = React__namespace.useCallback(function() {
    var args = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      args[_i2] = arguments[_i2];
    }
    globals$1.invariant(!calledDuringRender(), 50);
    var variables = args[0];
    var cacheKey = tslib$2.__spreadArray([
      query,
      cache.canonicalStringify(variables)
    ], [].concat(queryKey), true);
    var queryRef2 = suspenseCache.getQueryRef(cacheKey, function() {
      return client.watchQuery(tslib$2.__assign(tslib$2.__assign({}, watchQueryOptions), { variables }));
    });
    setQueryRef(internal.wrapQueryRef(queryRef2));
  }, [
    query,
    queryKey,
    suspenseCache,
    watchQueryOptions,
    calledDuringRender,
    client
  ]);
  var subscribeToMore = React__namespace.useCallback(function(options3) {
    globals$1.invariant(internalQueryRef, 51);
    return internalQueryRef.observable.subscribeToMore(options3);
  }, [internalQueryRef]);
  var reset = React__namespace.useCallback(function() {
    setQueryRef(null);
  }, []);
  return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];
}
function useQueryRefHandlers(queryRef) {
  var unwrapped = internal.unwrapQueryRef(queryRef);
  return wrapHook("useQueryRefHandlers", _useQueryRefHandlers, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
}
function _useQueryRefHandlers(queryRef) {
  internal.assertWrappedQueryRef(queryRef);
  var _a3 = React__namespace.useState(queryRef), previousQueryRef = _a3[0], setPreviousQueryRef = _a3[1];
  var _b2 = React__namespace.useState(queryRef), wrappedQueryRef = _b2[0], setWrappedQueryRef = _b2[1];
  var internalQueryRef = internal.unwrapQueryRef(queryRef);
  if (previousQueryRef !== queryRef) {
    setPreviousQueryRef(queryRef);
    setWrappedQueryRef(queryRef);
  } else {
    internal.updateWrappedQueryRef(queryRef, internal.getWrappedPromise(wrappedQueryRef));
  }
  var refetch = React__namespace.useCallback(function(variables) {
    var promise = internalQueryRef.refetch(variables);
    setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
    return promise;
  }, [internalQueryRef]);
  var fetchMore = React__namespace.useCallback(function(options2) {
    var promise = internalQueryRef.fetchMore(options2);
    setWrappedQueryRef(internal.wrapQueryRef(internalQueryRef));
    return promise;
  }, [internalQueryRef]);
  return {
    refetch,
    fetchMore,
    subscribeToMore: internalQueryRef.observable.subscribeToMore
  };
}
function useReadQuery(queryRef) {
  var unwrapped = internal.unwrapQueryRef(queryRef);
  return wrapHook("useReadQuery", _useReadQuery, unwrapped ? unwrapped["observable"] : useApolloClient())(queryRef);
}
function _useReadQuery(queryRef) {
  internal.assertWrappedQueryRef(queryRef);
  var internalQueryRef = React__namespace.useMemo(function() {
    return internal.unwrapQueryRef(queryRef);
  }, [queryRef]);
  var getPromise = React__namespace.useCallback(function() {
    return internal.getWrappedPromise(queryRef);
  }, [queryRef]);
  if (internalQueryRef.disposed) {
    internalQueryRef.reinitialize();
    internal.updateWrappedQueryRef(queryRef, internalQueryRef.promise);
  }
  React__namespace.useEffect(function() {
    return internalQueryRef.retain();
  }, [internalQueryRef]);
  var promise = useSyncExternalStore(React__namespace.useCallback(function(forceUpdate) {
    return internalQueryRef.listen(function(promise2) {
      internal.updateWrappedQueryRef(queryRef, promise2);
      forceUpdate();
    });
  }, [internalQueryRef, queryRef]), getPromise, getPromise);
  var result = __use(promise);
  return React__namespace.useMemo(function() {
    return {
      data: result.data,
      networkStatus: result.networkStatus,
      error: toApolloError(result)
    };
  }, [result]);
}
hooks.skipToken = skipToken;
hooks.useApolloClient = useApolloClient;
var useBackgroundQuery_1 = hooks.useBackgroundQuery = useBackgroundQuery;
hooks.useFragment = useFragment;
hooks.useLazyQuery = useLazyQuery;
hooks.useLoadableQuery = useLoadableQuery;
var useMutation_1 = hooks.useMutation = useMutation;
var useQuery_1 = hooks.useQuery = useQuery;
hooks.useQueryRefHandlers = useQueryRefHandlers;
hooks.useReactiveVar = useReactiveVar;
var useReadQuery_1 = hooks.useReadQuery = useReadQuery;
var useSubscription_1 = hooks.useSubscription = useSubscription;
var useSuspenseQuery_1 = hooks.useSuspenseQuery = useSuspenseQuery;
class CellErrorBoundary extends React$2.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.log("Cell failure: ", {
      error,
      errorInfo
    });
  }
  render() {
    const { renderFallback } = this.props;
    if (this.state.hasError) {
      return renderFallback({
        error: this.state.error,
        resetErrorBoundary: () => {
          this.setState({ hasError: false, error: void 0 });
        }
      });
    }
    return this.props.children;
  }
}
var hasElementType = typeof Element !== "undefined";
var hasMap = typeof Map === "function";
var hasSet = typeof Set === "function";
var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
function equal(a3, b2) {
  if (a3 === b2) return true;
  if (a3 && b2 && typeof a3 == "object" && typeof b2 == "object") {
    if (a3.constructor !== b2.constructor) return false;
    var length, i2, keys;
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a3[i2], b2[i2])) return false;
      return true;
    }
    var it2;
    if (hasMap && a3 instanceof Map && b2 instanceof Map) {
      if (a3.size !== b2.size) return false;
      it2 = a3.entries();
      while (!(i2 = it2.next()).done)
        if (!b2.has(i2.value[0])) return false;
      it2 = a3.entries();
      while (!(i2 = it2.next()).done)
        if (!equal(i2.value[1], b2.get(i2.value[0]))) return false;
      return true;
    }
    if (hasSet && a3 instanceof Set && b2 instanceof Set) {
      if (a3.size !== b2.size) return false;
      it2 = a3.entries();
      while (!(i2 = it2.next()).done)
        if (!b2.has(i2.value[0])) return false;
      return true;
    }
    if (hasArrayBuffer && ArrayBuffer.isView(a3) && ArrayBuffer.isView(b2)) {
      length = a3.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (a3[i2] !== b2[i2]) return false;
      return true;
    }
    if (a3.constructor === RegExp) return a3.source === b2.source && a3.flags === b2.flags;
    if (a3.valueOf !== Object.prototype.valueOf && typeof a3.valueOf === "function" && typeof b2.valueOf === "function") return a3.valueOf() === b2.valueOf();
    if (a3.toString !== Object.prototype.toString && typeof a3.toString === "function" && typeof b2.toString === "function") return a3.toString() === b2.toString();
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b2).length) return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
    if (hasElementType && a3 instanceof Element) return false;
    for (i2 = length; i2-- !== 0; ) {
      if ((keys[i2] === "_owner" || keys[i2] === "__v" || keys[i2] === "__o") && a3.$$typeof) {
        continue;
      }
      if (!equal(a3[keys[i2]], b2[keys[i2]])) return false;
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
var reactFastCompare = function isEqual(a3, b2) {
  try {
    return equal(a3, b2);
  } catch (error) {
    if ((error.message || "").match(/stack|recursion/i)) {
      console.warn("react-fast-compare cannot handle circular refs");
      return false;
    }
    throw error;
  }
};
const fastCompare = /* @__PURE__ */ getDefaultExportFromCjs(reactFastCompare);
var invariant = function(condition, format, a3, b2, c2, d3, e2, f3) {
  if (!condition) {
    var error;
    if (format === void 0) {
      error = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    } else {
      var args = [a3, b2, c2, d3, e2, f3];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() {
          return args[argIndex++];
        })
      );
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
};
var browser = invariant;
const invariant$1 = /* @__PURE__ */ getDefaultExportFromCjs(browser);
var shallowequal = function shallowEqual(objA, objB, compare, compareContext) {
  var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (ret !== void 0) {
    return !!ret;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    var valueA = objA[key];
    var valueB = objB[key];
    ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
    if (ret === false || ret === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
};
const shallowEqual2 = /* @__PURE__ */ getDefaultExportFromCjs(shallowequal);
var TAG_NAMES = /* @__PURE__ */ ((TAG_NAMES2) => {
  TAG_NAMES2["BASE"] = "base";
  TAG_NAMES2["BODY"] = "body";
  TAG_NAMES2["HEAD"] = "head";
  TAG_NAMES2["HTML"] = "html";
  TAG_NAMES2["LINK"] = "link";
  TAG_NAMES2["META"] = "meta";
  TAG_NAMES2["NOSCRIPT"] = "noscript";
  TAG_NAMES2["SCRIPT"] = "script";
  TAG_NAMES2["STYLE"] = "style";
  TAG_NAMES2["TITLE"] = "title";
  TAG_NAMES2["FRAGMENT"] = "Symbol(react.fragment)";
  return TAG_NAMES2;
})(TAG_NAMES || {});
var SEO_PRIORITY_TAGS = {
  link: { rel: ["amphtml", "canonical", "alternate"] },
  script: { type: ["application/ld+json"] },
  meta: {
    charset: "",
    name: ["generator", "robots", "description"],
    property: [
      "og:type",
      "og:title",
      "og:url",
      "og:image",
      "og:image:alt",
      "og:description",
      "twitter:url",
      "twitter:title",
      "twitter:description",
      "twitter:image",
      "twitter:image:alt",
      "twitter:card",
      "twitter:site"
    ]
  }
};
var VALID_TAG_NAMES = Object.values(TAG_NAMES);
var REACT_TAG_MAP = {
  accesskey: "accessKey",
  charset: "charSet",
  class: "className",
  contenteditable: "contentEditable",
  contextmenu: "contextMenu",
  "http-equiv": "httpEquiv",
  itemprop: "itemProp",
  tabindex: "tabIndex"
};
var HTML_TAG_MAP = Object.entries(REACT_TAG_MAP).reduce(
  (carry, [key, value]) => {
    carry[value] = key;
    return carry;
  },
  {}
);
var HELMET_ATTRIBUTE = "data-rh";
var HELMET_PROPS = {
  DEFAULT_TITLE: "defaultTitle",
  DEFER: "defer",
  ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters",
  ON_CHANGE_CLIENT_STATE: "onChangeClientState",
  TITLE_TEMPLATE: "titleTemplate",
  PRIORITIZE_SEO_TAGS: "prioritizeSeoTags"
};
var getInnermostProperty = (propsList, property) => {
  for (let i2 = propsList.length - 1; i2 >= 0; i2 -= 1) {
    const props = propsList[i2];
    if (Object.prototype.hasOwnProperty.call(props, property)) {
      return props[property];
    }
  }
  return null;
};
var getTitleFromPropsList = (propsList) => {
  let innermostTitle = getInnermostProperty(
    propsList,
    "title"
    /* TITLE */
  );
  const innermostTemplate = getInnermostProperty(propsList, HELMET_PROPS.TITLE_TEMPLATE);
  if (Array.isArray(innermostTitle)) {
    innermostTitle = innermostTitle.join("");
  }
  if (innermostTemplate && innermostTitle) {
    return innermostTemplate.replace(/%s/g, () => innermostTitle);
  }
  const innermostDefaultTitle = getInnermostProperty(propsList, HELMET_PROPS.DEFAULT_TITLE);
  return innermostTitle || innermostDefaultTitle || void 0;
};
var getOnChangeClientState = (propsList) => getInnermostProperty(propsList, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) || (() => {
});
var getAttributesFromPropsList = (tagType, propsList) => propsList.filter((props) => typeof props[tagType] !== "undefined").map((props) => props[tagType]).reduce((tagAttrs, current) => ({ ...tagAttrs, ...current }), {});
var getBaseTagFromPropsList = (primaryAttributes, propsList) => propsList.filter((props) => typeof props[
  "base"
  /* BASE */
] !== "undefined").map((props) => props[
  "base"
  /* BASE */
]).reverse().reduce((innermostBaseTag, tag) => {
  if (!innermostBaseTag.length) {
    const keys = Object.keys(tag);
    for (let i2 = 0; i2 < keys.length; i2 += 1) {
      const attributeKey = keys[i2];
      const lowerCaseAttributeKey = attributeKey.toLowerCase();
      if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && tag[lowerCaseAttributeKey]) {
        return innermostBaseTag.concat(tag);
      }
    }
  }
  return innermostBaseTag;
}, []);
var warn = (msg) => console && typeof console.warn === "function" && console.warn(msg);
var getTagsFromPropsList = (tagName, primaryAttributes, propsList) => {
  const approvedSeenTags = {};
  return propsList.filter((props) => {
    if (Array.isArray(props[tagName])) {
      return true;
    }
    if (typeof props[tagName] !== "undefined") {
      warn(
        `Helmet: ${tagName} should be of type "Array". Instead found type "${typeof props[tagName]}"`
      );
    }
    return false;
  }).map((props) => props[tagName]).reverse().reduce((approvedTags, instanceTags) => {
    const instanceSeenTags = {};
    instanceTags.filter((tag) => {
      let primaryAttributeKey;
      const keys2 = Object.keys(tag);
      for (let i2 = 0; i2 < keys2.length; i2 += 1) {
        const attributeKey = keys2[i2];
        const lowerCaseAttributeKey = attributeKey.toLowerCase();
        if (primaryAttributes.indexOf(lowerCaseAttributeKey) !== -1 && !(primaryAttributeKey === "rel" && tag[primaryAttributeKey].toLowerCase() === "canonical") && !(lowerCaseAttributeKey === "rel" && tag[lowerCaseAttributeKey].toLowerCase() === "stylesheet")) {
          primaryAttributeKey = lowerCaseAttributeKey;
        }
        if (primaryAttributes.indexOf(attributeKey) !== -1 && (attributeKey === "innerHTML" || attributeKey === "cssText" || attributeKey === "itemprop")) {
          primaryAttributeKey = attributeKey;
        }
      }
      if (!primaryAttributeKey || !tag[primaryAttributeKey]) {
        return false;
      }
      const value = tag[primaryAttributeKey].toLowerCase();
      if (!approvedSeenTags[primaryAttributeKey]) {
        approvedSeenTags[primaryAttributeKey] = {};
      }
      if (!instanceSeenTags[primaryAttributeKey]) {
        instanceSeenTags[primaryAttributeKey] = {};
      }
      if (!approvedSeenTags[primaryAttributeKey][value]) {
        instanceSeenTags[primaryAttributeKey][value] = true;
        return true;
      }
      return false;
    }).reverse().forEach((tag) => approvedTags.push(tag));
    const keys = Object.keys(instanceSeenTags);
    for (let i2 = 0; i2 < keys.length; i2 += 1) {
      const attributeKey = keys[i2];
      const tagUnion = {
        ...approvedSeenTags[attributeKey],
        ...instanceSeenTags[attributeKey]
      };
      approvedSeenTags[attributeKey] = tagUnion;
    }
    return approvedTags;
  }, []).reverse();
};
var getAnyTrueFromPropsList = (propsList, checkedTag) => {
  if (Array.isArray(propsList) && propsList.length) {
    for (let index2 = 0; index2 < propsList.length; index2 += 1) {
      const prop = propsList[index2];
      if (prop[checkedTag]) {
        return true;
      }
    }
  }
  return false;
};
var reducePropsToState = (propsList) => ({
  baseTag: getBaseTagFromPropsList([
    "href"
    /* HREF */
  ], propsList),
  bodyAttributes: getAttributesFromPropsList("bodyAttributes", propsList),
  defer: getInnermostProperty(propsList, HELMET_PROPS.DEFER),
  encode: getInnermostProperty(propsList, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
  htmlAttributes: getAttributesFromPropsList("htmlAttributes", propsList),
  linkTags: getTagsFromPropsList(
    "link",
    [
      "rel",
      "href"
      /* HREF */
    ],
    propsList
  ),
  metaTags: getTagsFromPropsList(
    "meta",
    [
      "name",
      "charset",
      "http-equiv",
      "property",
      "itemprop"
      /* ITEM_PROP */
    ],
    propsList
  ),
  noscriptTags: getTagsFromPropsList("noscript", [
    "innerHTML"
    /* INNER_HTML */
  ], propsList),
  onChangeClientState: getOnChangeClientState(propsList),
  scriptTags: getTagsFromPropsList(
    "script",
    [
      "src",
      "innerHTML"
      /* INNER_HTML */
    ],
    propsList
  ),
  styleTags: getTagsFromPropsList("style", [
    "cssText"
    /* CSS_TEXT */
  ], propsList),
  title: getTitleFromPropsList(propsList),
  titleAttributes: getAttributesFromPropsList("titleAttributes", propsList),
  prioritizeSeoTags: getAnyTrueFromPropsList(propsList, HELMET_PROPS.PRIORITIZE_SEO_TAGS)
});
var flattenArray = (possibleArray) => Array.isArray(possibleArray) ? possibleArray.join("") : possibleArray;
var checkIfPropsMatch = (props, toMatch) => {
  const keys = Object.keys(props);
  for (let i2 = 0; i2 < keys.length; i2 += 1) {
    if (toMatch[keys[i2]] && toMatch[keys[i2]].includes(props[keys[i2]])) {
      return true;
    }
  }
  return false;
};
var prioritizer = (elementsList, propsToMatch) => {
  if (Array.isArray(elementsList)) {
    return elementsList.reduce(
      (acc, elementAttrs) => {
        if (checkIfPropsMatch(elementAttrs, propsToMatch)) {
          acc.priority.push(elementAttrs);
        } else {
          acc.default.push(elementAttrs);
        }
        return acc;
      },
      { priority: [], default: [] }
    );
  }
  return { default: elementsList, priority: [] };
};
var without = (obj, key) => {
  return {
    ...obj,
    [key]: void 0
  };
};
var SELF_CLOSING_TAGS = [
  "noscript",
  "script",
  "style"
  /* STYLE */
];
var encodeSpecialCharacters = (str, encode = true) => {
  if (encode === false) {
    return String(str);
  }
  return String(str).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
};
var generateElementAttributesAsString = (attributes) => Object.keys(attributes).reduce((str, key) => {
  const attr = typeof attributes[key] !== "undefined" ? `${key}="${attributes[key]}"` : `${key}`;
  return str ? `${str} ${attr}` : attr;
}, "");
var generateTitleAsString = (type, title, attributes, encode) => {
  const attributeString = generateElementAttributesAsString(attributes);
  const flattenedTitle = flattenArray(title);
  return attributeString ? `<${type} ${HELMET_ATTRIBUTE}="true" ${attributeString}>${encodeSpecialCharacters(
    flattenedTitle,
    encode
  )}</${type}>` : `<${type} ${HELMET_ATTRIBUTE}="true">${encodeSpecialCharacters(
    flattenedTitle,
    encode
  )}</${type}>`;
};
var generateTagsAsString = (type, tags, encode = true) => tags.reduce((str, t2) => {
  const tag = t2;
  const attributeHtml = Object.keys(tag).filter(
    (attribute) => !(attribute === "innerHTML" || attribute === "cssText")
  ).reduce((string, attribute) => {
    const attr = typeof tag[attribute] === "undefined" ? attribute : `${attribute}="${encodeSpecialCharacters(tag[attribute], encode)}"`;
    return string ? `${string} ${attr}` : attr;
  }, "");
  const tagContent = tag.innerHTML || tag.cssText || "";
  const isSelfClosing = SELF_CLOSING_TAGS.indexOf(type) === -1;
  return `${str}<${type} ${HELMET_ATTRIBUTE}="true" ${attributeHtml}${isSelfClosing ? `/>` : `>${tagContent}</${type}>`}`;
}, "");
var convertElementAttributesToReactProps = (attributes, initProps = {}) => Object.keys(attributes).reduce((obj, key) => {
  const mapped = REACT_TAG_MAP[key];
  obj[mapped || key] = attributes[key];
  return obj;
}, initProps);
var generateTitleAsReactComponent = (_type, title, attributes) => {
  const initProps = {
    key: title,
    [HELMET_ATTRIBUTE]: true
  };
  const props = convertElementAttributesToReactProps(attributes, initProps);
  return [React$2.createElement("title", props, title)];
};
var generateTagsAsReactComponent = (type, tags) => tags.map((tag, i2) => {
  const mappedTag = {
    key: i2,
    [HELMET_ATTRIBUTE]: true
  };
  Object.keys(tag).forEach((attribute) => {
    const mapped = REACT_TAG_MAP[attribute];
    const mappedAttribute = mapped || attribute;
    if (mappedAttribute === "innerHTML" || mappedAttribute === "cssText") {
      const content = tag.innerHTML || tag.cssText;
      mappedTag.dangerouslySetInnerHTML = { __html: content };
    } else {
      mappedTag[mappedAttribute] = tag[attribute];
    }
  });
  return React$2.createElement(type, mappedTag);
});
var getMethodsForTag = (type, tags, encode = true) => {
  switch (type) {
    case "title":
      return {
        toComponent: () => generateTitleAsReactComponent(type, tags.title, tags.titleAttributes),
        toString: () => generateTitleAsString(type, tags.title, tags.titleAttributes, encode)
      };
    case "bodyAttributes":
    case "htmlAttributes":
      return {
        toComponent: () => convertElementAttributesToReactProps(tags),
        toString: () => generateElementAttributesAsString(tags)
      };
    default:
      return {
        toComponent: () => generateTagsAsReactComponent(type, tags),
        toString: () => generateTagsAsString(type, tags, encode)
      };
  }
};
var getPriorityMethods = ({ metaTags, linkTags, scriptTags, encode }) => {
  const meta = prioritizer(metaTags, SEO_PRIORITY_TAGS.meta);
  const link = prioritizer(linkTags, SEO_PRIORITY_TAGS.link);
  const script = prioritizer(scriptTags, SEO_PRIORITY_TAGS.script);
  const priorityMethods = {
    toComponent: () => [
      ...generateTagsAsReactComponent("meta", meta.priority),
      ...generateTagsAsReactComponent("link", link.priority),
      ...generateTagsAsReactComponent("script", script.priority)
    ],
    toString: () => (
      // generate all the tags as strings and concatenate them
      `${getMethodsForTag("meta", meta.priority, encode)} ${getMethodsForTag(
        "link",
        link.priority,
        encode
      )} ${getMethodsForTag("script", script.priority, encode)}`
    )
  };
  return {
    priorityMethods,
    metaTags: meta.default,
    linkTags: link.default,
    scriptTags: script.default
  };
};
var mapStateOnServer = (props) => {
  const {
    baseTag,
    bodyAttributes,
    encode = true,
    htmlAttributes,
    noscriptTags,
    styleTags,
    title = "",
    titleAttributes,
    prioritizeSeoTags
  } = props;
  let { linkTags, metaTags, scriptTags } = props;
  let priorityMethods = {
    toComponent: () => {
    },
    toString: () => ""
  };
  if (prioritizeSeoTags) {
    ({ priorityMethods, linkTags, metaTags, scriptTags } = getPriorityMethods(props));
  }
  return {
    priority: priorityMethods,
    base: getMethodsForTag("base", baseTag, encode),
    bodyAttributes: getMethodsForTag("bodyAttributes", bodyAttributes, encode),
    htmlAttributes: getMethodsForTag("htmlAttributes", htmlAttributes, encode),
    link: getMethodsForTag("link", linkTags, encode),
    meta: getMethodsForTag("meta", metaTags, encode),
    noscript: getMethodsForTag("noscript", noscriptTags, encode),
    script: getMethodsForTag("script", scriptTags, encode),
    style: getMethodsForTag("style", styleTags, encode),
    title: getMethodsForTag("title", { title, titleAttributes }, encode)
  };
};
var server_default = mapStateOnServer;
var instances = [];
var isDocument = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var HelmetData = class {
  constructor(context2, canUseDOM2) {
    __publicField(this, "instances", []);
    __publicField(this, "canUseDOM", isDocument);
    __publicField(this, "context");
    __publicField(this, "value", {
      setHelmet: (serverState) => {
        this.context.helmet = serverState;
      },
      helmetInstances: {
        get: () => this.canUseDOM ? instances : this.instances,
        add: (instance) => {
          (this.canUseDOM ? instances : this.instances).push(instance);
        },
        remove: (instance) => {
          const index2 = (this.canUseDOM ? instances : this.instances).indexOf(instance);
          (this.canUseDOM ? instances : this.instances).splice(index2, 1);
        }
      }
    });
    this.context = context2;
    this.canUseDOM = canUseDOM2 || false;
    if (!canUseDOM2) {
      context2.helmet = server_default({
        baseTag: [],
        bodyAttributes: {},
        htmlAttributes: {},
        linkTags: [],
        metaTags: [],
        noscriptTags: [],
        scriptTags: [],
        styleTags: [],
        title: "",
        titleAttributes: {}
      });
    }
  }
};
var defaultValue = {};
var Context = React$2.createContext(defaultValue);
var HelmetProvider$1 = (_a2 = class extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "helmetData");
    this.helmetData = new HelmetData(this.props.context || {}, _a2.canUseDOM);
  }
  render() {
    return /* @__PURE__ */ React$2.createElement(Context.Provider, { value: this.helmetData.value }, this.props.children);
  }
}, __publicField(_a2, "canUseDOM", isDocument), _a2);
var updateTags = (type, tags) => {
  const headElement = document.head || document.querySelector(
    "head"
    /* HEAD */
  );
  const tagNodes = headElement.querySelectorAll(`${type}[${HELMET_ATTRIBUTE}]`);
  const oldTags = [].slice.call(tagNodes);
  const newTags = [];
  let indexToDelete;
  if (tags && tags.length) {
    tags.forEach((tag) => {
      const newElement = document.createElement(type);
      for (const attribute in tag) {
        if (Object.prototype.hasOwnProperty.call(tag, attribute)) {
          if (attribute === "innerHTML") {
            newElement.innerHTML = tag.innerHTML;
          } else if (attribute === "cssText") {
            if (newElement.styleSheet) {
              newElement.styleSheet.cssText = tag.cssText;
            } else {
              newElement.appendChild(document.createTextNode(tag.cssText));
            }
          } else {
            const attr = attribute;
            const value = typeof tag[attr] === "undefined" ? "" : tag[attr];
            newElement.setAttribute(attribute, value);
          }
        }
      }
      newElement.setAttribute(HELMET_ATTRIBUTE, "true");
      if (oldTags.some((existingTag, index2) => {
        indexToDelete = index2;
        return newElement.isEqualNode(existingTag);
      })) {
        oldTags.splice(indexToDelete, 1);
      } else {
        newTags.push(newElement);
      }
    });
  }
  oldTags.forEach((tag) => {
    var _a3;
    return (_a3 = tag.parentNode) == null ? void 0 : _a3.removeChild(tag);
  });
  newTags.forEach((tag) => headElement.appendChild(tag));
  return {
    oldTags,
    newTags
  };
};
var updateAttributes = (tagName, attributes) => {
  const elementTag = document.getElementsByTagName(tagName)[0];
  if (!elementTag) {
    return;
  }
  const helmetAttributeString = elementTag.getAttribute(HELMET_ATTRIBUTE);
  const helmetAttributes = helmetAttributeString ? helmetAttributeString.split(",") : [];
  const attributesToRemove = [...helmetAttributes];
  const attributeKeys = Object.keys(attributes);
  for (const attribute of attributeKeys) {
    const value = attributes[attribute] || "";
    if (elementTag.getAttribute(attribute) !== value) {
      elementTag.setAttribute(attribute, value);
    }
    if (helmetAttributes.indexOf(attribute) === -1) {
      helmetAttributes.push(attribute);
    }
    const indexToSave = attributesToRemove.indexOf(attribute);
    if (indexToSave !== -1) {
      attributesToRemove.splice(indexToSave, 1);
    }
  }
  for (let i2 = attributesToRemove.length - 1; i2 >= 0; i2 -= 1) {
    elementTag.removeAttribute(attributesToRemove[i2]);
  }
  if (helmetAttributes.length === attributesToRemove.length) {
    elementTag.removeAttribute(HELMET_ATTRIBUTE);
  } else if (elementTag.getAttribute(HELMET_ATTRIBUTE) !== attributeKeys.join(",")) {
    elementTag.setAttribute(HELMET_ATTRIBUTE, attributeKeys.join(","));
  }
};
var updateTitle = (title, attributes) => {
  if (typeof title !== "undefined" && document.title !== title) {
    document.title = flattenArray(title);
  }
  updateAttributes("title", attributes);
};
var commitTagChanges = (newState, cb2) => {
  const {
    baseTag,
    bodyAttributes,
    htmlAttributes,
    linkTags,
    metaTags,
    noscriptTags,
    onChangeClientState,
    scriptTags,
    styleTags,
    title,
    titleAttributes
  } = newState;
  updateAttributes("body", bodyAttributes);
  updateAttributes("html", htmlAttributes);
  updateTitle(title, titleAttributes);
  const tagUpdates = {
    baseTag: updateTags("base", baseTag),
    linkTags: updateTags("link", linkTags),
    metaTags: updateTags("meta", metaTags),
    noscriptTags: updateTags("noscript", noscriptTags),
    scriptTags: updateTags("script", scriptTags),
    styleTags: updateTags("style", styleTags)
  };
  const addedTags = {};
  const removedTags = {};
  Object.keys(tagUpdates).forEach((tagType) => {
    const { newTags, oldTags } = tagUpdates[tagType];
    if (newTags.length) {
      addedTags[tagType] = newTags;
    }
    if (oldTags.length) {
      removedTags[tagType] = tagUpdates[tagType].oldTags;
    }
  });
  if (cb2) {
    cb2();
  }
  onChangeClientState(newState, addedTags, removedTags);
};
var _helmetCallback = null;
var handleStateChangeOnClient = (newState) => {
  if (_helmetCallback) {
    cancelAnimationFrame(_helmetCallback);
  }
  if (newState.defer) {
    _helmetCallback = requestAnimationFrame(() => {
      commitTagChanges(newState, () => {
        _helmetCallback = null;
      });
    });
  } else {
    commitTagChanges(newState);
    _helmetCallback = null;
  }
};
var client_default = handleStateChangeOnClient;
var HelmetDispatcher = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "rendered", false);
  }
  shouldComponentUpdate(nextProps) {
    return !shallowEqual2(nextProps, this.props);
  }
  componentDidUpdate() {
    this.emitChange();
  }
  componentWillUnmount() {
    const { helmetInstances } = this.props.context;
    helmetInstances.remove(this);
    this.emitChange();
  }
  emitChange() {
    const { helmetInstances, setHelmet } = this.props.context;
    let serverState = null;
    const state = reducePropsToState(
      helmetInstances.get().map((instance) => {
        const props = { ...instance.props };
        delete props.context;
        return props;
      })
    );
    if (HelmetProvider$1.canUseDOM) {
      client_default(state);
    } else if (server_default) {
      serverState = server_default(state);
    }
    setHelmet(serverState);
  }
  // componentWillMount will be deprecated
  // for SSR, initialize on first render
  // constructor is also unsafe in StrictMode
  init() {
    if (this.rendered) {
      return;
    }
    this.rendered = true;
    const { helmetInstances } = this.props.context;
    helmetInstances.add(this);
    this.emitChange();
  }
  render() {
    this.init();
    return null;
  }
};
var Helmet$1 = (_b = class extends reactExports.Component {
  shouldComponentUpdate(nextProps) {
    return !fastCompare(without(this.props, "helmetData"), without(nextProps, "helmetData"));
  }
  mapNestedChildrenToProps(child, nestedChildren) {
    if (!nestedChildren) {
      return null;
    }
    switch (child.type) {
      case "script":
      case "noscript":
        return {
          innerHTML: nestedChildren
        };
      case "style":
        return {
          cssText: nestedChildren
        };
      default:
        throw new Error(
          `<${child.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`
        );
    }
  }
  flattenArrayTypeChildren(child, arrayTypeChildren, newChildProps, nestedChildren) {
    return {
      ...arrayTypeChildren,
      [child.type]: [
        ...arrayTypeChildren[child.type] || [],
        {
          ...newChildProps,
          ...this.mapNestedChildrenToProps(child, nestedChildren)
        }
      ]
    };
  }
  mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren) {
    switch (child.type) {
      case "title":
        return {
          ...newProps,
          [child.type]: nestedChildren,
          titleAttributes: { ...newChildProps }
        };
      case "body":
        return {
          ...newProps,
          bodyAttributes: { ...newChildProps }
        };
      case "html":
        return {
          ...newProps,
          htmlAttributes: { ...newChildProps }
        };
      default:
        return {
          ...newProps,
          [child.type]: { ...newChildProps }
        };
    }
  }
  mapArrayTypeChildrenToProps(arrayTypeChildren, newProps) {
    let newFlattenedProps = { ...newProps };
    Object.keys(arrayTypeChildren).forEach((arrayChildName) => {
      newFlattenedProps = {
        ...newFlattenedProps,
        [arrayChildName]: arrayTypeChildren[arrayChildName]
      };
    });
    return newFlattenedProps;
  }
  warnOnInvalidChildren(child, nestedChildren) {
    invariant$1(
      VALID_TAG_NAMES.some((name) => child.type === name),
      typeof child.type === "function" ? `You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information.` : `Only elements types ${VALID_TAG_NAMES.join(
        ", "
      )} are allowed. Helmet does not support rendering <${child.type}> elements. Refer to our API for more information.`
    );
    invariant$1(
      !nestedChildren || typeof nestedChildren === "string" || Array.isArray(nestedChildren) && !nestedChildren.some((nestedChild) => typeof nestedChild !== "string"),
      `Helmet expects a string as a child of <${child.type}>. Did you forget to wrap your children in braces? ( <${child.type}>{\`\`}</${child.type}> ) Refer to our API for more information.`
    );
    return true;
  }
  mapChildrenToProps(children, newProps) {
    let arrayTypeChildren = {};
    React$2.Children.forEach(children, (child) => {
      if (!child || !child.props) {
        return;
      }
      const { children: nestedChildren, ...childProps } = child.props;
      const newChildProps = Object.keys(childProps).reduce((obj, key) => {
        obj[HTML_TAG_MAP[key] || key] = childProps[key];
        return obj;
      }, {});
      let { type } = child;
      if (typeof type === "symbol") {
        type = type.toString();
      } else {
        this.warnOnInvalidChildren(child, nestedChildren);
      }
      switch (type) {
        case "Symbol(react.fragment)":
          newProps = this.mapChildrenToProps(nestedChildren, newProps);
          break;
        case "link":
        case "meta":
        case "noscript":
        case "script":
        case "style":
          arrayTypeChildren = this.flattenArrayTypeChildren(
            child,
            arrayTypeChildren,
            newChildProps,
            nestedChildren
          );
          break;
        default:
          newProps = this.mapObjectTypeChildren(child, newProps, newChildProps, nestedChildren);
          break;
      }
    });
    return this.mapArrayTypeChildrenToProps(arrayTypeChildren, newProps);
  }
  render() {
    const { children, ...props } = this.props;
    let newProps = { ...props };
    let { helmetData } = props;
    if (children) {
      newProps = this.mapChildrenToProps(children, newProps);
    }
    if (helmetData && !(helmetData instanceof HelmetData)) {
      const data = helmetData;
      helmetData = new HelmetData(data.context, true);
      delete newProps.helmetData;
    }
    return helmetData ? /* @__PURE__ */ React$2.createElement(HelmetDispatcher, { ...newProps, context: helmetData.value }) : /* @__PURE__ */ React$2.createElement(Context.Consumer, null, (context2) => /* @__PURE__ */ React$2.createElement(HelmetDispatcher, { ...newProps, context: context2 }));
  }
}, __publicField(_b, "defaultProps", {
  defer: true,
  encodeSpecialCharacters: true,
  prioritizeSeoTags: false
}), _b);
const helmetPkg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Helmet: Helmet$1,
  HelmetData,
  HelmetProvider: HelmetProvider$1
}, Symbol.toStringTag, { value: "Module" }));
const { Helmet, HelmetProvider } = helmetPkg;
const RedwoodProvider = ({
  children,
  titleTemplate
}) => {
  const appTitle = globalThis.__REDWOOD__APP_TITLE;
  const template = () => {
    if (titleTemplate) {
      let template2 = titleTemplate.replace(/%AppTitle/g, appTitle);
      template2 = template2.replace(/%PageTitle/g, "%s");
      return template2;
    }
    return "";
  };
  return /* @__PURE__ */ React$2.createElement(HelmetProvider, { context: globalThis.__REDWOOD__HELMET_CONTEXT }, /* @__PURE__ */ React$2.createElement(Helmet, { titleTemplate: template(), defaultTitle: appTitle }, /* @__PURE__ */ React$2.createElement("title", null, appTitle)), children);
};
const ServerHtmlContext = reactExports.createContext(() => {
});
ServerHtmlContext.Provider;
var core$2 = {};
const require$$3$1 = /* @__PURE__ */ getAugmentedNamespace(core$5);
const require$$3 = /* @__PURE__ */ getAugmentedNamespace(http);
const require$$10 = /* @__PURE__ */ getAugmentedNamespace(utils);
const require$$11 = /* @__PURE__ */ getAugmentedNamespace(invariant$6);
const require$$12 = /* @__PURE__ */ getAugmentedNamespace(lib);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib2 = require$$0;
  var globals2 = require$$1;
  var core2 = require$$3$1;
  var http2 = require$$3;
  var equal2 = require$$4;
  var utilities2 = require$$2$1;
  var cache2 = require$$6;
  var errors2 = require$$7$1;
  var trie2 = require$$8$1;
  var graphql2 = require$$9$1;
  var utils2 = require$$10;
  var tsInvariant = require$$11;
  var graphqlTag = require$$12;
  function _interopDefaultLegacy2(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2["default"] : e2;
  }
  var equal__default2 = /* @__PURE__ */ _interopDefaultLegacy2(equal2);
  var version2 = "3.11.1";
  function isNonNullObject2(obj) {
    return obj !== null && typeof obj === "object";
  }
  function isNonEmptyArray2(value) {
    return Array.isArray(value) && value.length > 0;
  }
  var hasOwnProperty$22 = Object.prototype.hasOwnProperty;
  var defaultReconciler2 = function(target, source, property) {
    return this.merge(target[property], source[property]);
  };
  var DeepMerger2 = function() {
    function DeepMerger3(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler2;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject2;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger3.prototype.merge = function(target, source) {
      var _this = this;
      var context2 = [];
      for (var _i2 = 2; _i2 < arguments.length; _i2++) {
        context2[_i2 - 2] = arguments[_i2];
      }
      if (isNonNullObject2(source) && isNonNullObject2(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty$22.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result = _this.reconciler.apply(_this, tslib2.__spreadArray([
                target,
                source,
                sourceKey
              ], context2, false));
              if (result !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger3.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject2(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = tslib2.__assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger3;
  }();
  function isExecutionPatchIncrementalResult2(value) {
    return "incremental" in value;
  }
  function mergeIncrementalData2(prevResult, result) {
    var mergedData = prevResult;
    var merger = new DeepMerger2();
    if (isExecutionPatchIncrementalResult2(result) && isNonEmptyArray2(result.incremental)) {
      result.incremental.forEach(function(_a3) {
        var data = _a3.data, path = _a3.path;
        for (var i2 = path.length - 1; i2 >= 0; --i2) {
          var key = path[i2];
          var isNumericKey = !isNaN(+key);
          var parent_1 = isNumericKey ? [] : {};
          parent_1[key] = data;
          data = parent_1;
        }
        mergedData = merger.merge(mergedData, data);
      });
    }
    return mergedData;
  }
  exports.NetworkStatus = void 0;
  (function(NetworkStatus2) {
    NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
    NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
    NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
    NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
    NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
    NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
    NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
  })(exports.NetworkStatus || (exports.NetworkStatus = {}));
  function isNetworkRequestInFlight2(networkStatus) {
    return networkStatus ? networkStatus < 7 : false;
  }
  function isNetworkRequestSettled2(networkStatus) {
    return networkStatus === 7 || networkStatus === 8;
  }
  function equalByQuery2(query, _a3, _b2, variables) {
    var aData = _a3.data, aRest = tslib2.__rest(_a3, ["data"]);
    var bData = _b2.data, bRest = tslib2.__rest(_b2, ["data"]);
    return equal__default2(aRest, bRest) && equalBySelectionSet2(utilities2.getMainDefinition(query).selectionSet, aData, bData, {
      fragmentMap: utilities2.createFragmentMap(utilities2.getFragmentDefinitions(query)),
      variables
    });
  }
  function equalBySelectionSet2(selectionSet, aResult, bResult, context2) {
    if (aResult === bResult) {
      return true;
    }
    var seenSelections = /* @__PURE__ */ new Set();
    return selectionSet.selections.every(function(selection) {
      if (seenSelections.has(selection))
        return true;
      seenSelections.add(selection);
      if (!utilities2.shouldInclude(selection, context2.variables))
        return true;
      if (selectionHasNonreactiveDirective2(selection))
        return true;
      if (utilities2.isField(selection)) {
        var resultKey = utilities2.resultKeyNameFromField(selection);
        var aResultChild = aResult && aResult[resultKey];
        var bResultChild = bResult && bResult[resultKey];
        var childSelectionSet = selection.selectionSet;
        if (!childSelectionSet) {
          return equal__default2(aResultChild, bResultChild);
        }
        var aChildIsArray = Array.isArray(aResultChild);
        var bChildIsArray = Array.isArray(bResultChild);
        if (aChildIsArray !== bChildIsArray)
          return false;
        if (aChildIsArray && bChildIsArray) {
          var length_1 = aResultChild.length;
          if (bResultChild.length !== length_1) {
            return false;
          }
          for (var i2 = 0; i2 < length_1; ++i2) {
            if (!equalBySelectionSet2(childSelectionSet, aResultChild[i2], bResultChild[i2], context2)) {
              return false;
            }
          }
          return true;
        }
        return equalBySelectionSet2(childSelectionSet, aResultChild, bResultChild, context2);
      } else {
        var fragment = utilities2.getFragmentFromSelection(selection, context2.fragmentMap);
        if (fragment) {
          if (selectionHasNonreactiveDirective2(fragment))
            return true;
          return equalBySelectionSet2(
            fragment.selectionSet,
            aResult,
            bResult,
            context2
          );
        }
      }
    });
  }
  function selectionHasNonreactiveDirective2(selection) {
    return !!selection.directives && selection.directives.some(directiveIsNonreactive2);
  }
  function directiveIsNonreactive2(dir) {
    return dir.name.value === "nonreactive";
  }
  var assign2 = Object.assign, hasOwnProperty$12 = Object.hasOwnProperty;
  var ObservableQuery2 = function(_super) {
    tslib2.__extends(ObservableQuery3, _super);
    function ObservableQuery3(_a3) {
      var queryManager = _a3.queryManager, queryInfo = _a3.queryInfo, options2 = _a3.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback2;
          }
        } catch (_a4) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(last.result);
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor2(options2.fetchPolicy);
      _this.isTornDown = false;
      _this.subscribeToMore = _this.subscribeToMore.bind(_this);
      var _b2 = queryManager.defaultOptions.watchQuery, _c2 = _b2 === void 0 ? {} : _b2, _d = _c2.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e2 = options2.fetchPolicy, fetchPolicy = _e2 === void 0 ? defaultFetchPolicy : _e2, _f = options2.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = tslib2.__assign(tslib2.__assign({}, options2), {
        initialFetchPolicy,
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = utilities2.getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery3.prototype, "query", {
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery3.prototype, "variables", {
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery3.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result) {
            resolve(result);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery3.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    };
    ObservableQuery3.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || exports.NetworkStatus.ready;
      var result = tslib2.__assign(tslib2.__assign({}, lastResult), { loading: isNetworkRequestInFlight2(networkStatus), networkStatus });
      var _a3 = this.options.fetchPolicy, fetchPolicy = _a3 === void 0 ? "cache-first" : _a3;
      if (skipCacheDataFor2(fetchPolicy) || this.queryManager.getDocumentInfo(this.query).hasForcedResolvers) ;
      else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff2 = this.queryInfo.getDiff();
        if (diff2.complete || this.options.returnPartialData) {
          result.data = diff2.result;
        }
        if (equal2.equal(result.data, {})) {
          result.data = void 0;
        }
        if (diff2.complete) {
          delete result.partial;
          if (diff2.complete && result.networkStatus === exports.NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result.networkStatus = exports.NetworkStatus.ready;
            result.loading = false;
          }
        } else {
          result.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff2.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
          logMissingFieldErrors2(diff2.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result);
      }
      return result;
    };
    ObservableQuery3.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var resultIsDifferent = this.queryManager.getDocumentInfo(this.query).hasNonreactiveDirective ? !equalByQuery2(this.query, this.last.result, newResult, this.variables) : !equal2.equal(this.last.result, newResult);
      return resultIsDifferent || variables && !equal2.equal(this.last.variables, variables);
    };
    ObservableQuery3.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal2.equal(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery3.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery3.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery3.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery3.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery3.prototype.refetch = function(variables) {
      var _a3;
      var reobserveOptions = {
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty$12.call(variables, "variables")) {
        var queryDef = utilities2.getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v2) {
          return v2.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && globals2.invariant.warn(
            20,
            variables,
            ((_a3 = queryDef.name) === null || _a3 === void 0 ? void 0 : _a3.value) || queryDef
          );
        }
      }
      if (variables && !equal2.equal(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = tslib2.__assign(tslib2.__assign({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, exports.NetworkStatus.refetch);
    };
    ObservableQuery3.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = tslib2.__assign(tslib2.__assign({}, fetchMoreOptions.query ? fetchMoreOptions : tslib2.__assign(tslib2.__assign(tslib2.__assign(tslib2.__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: tslib2.__assign(tslib2.__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = exports.NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      return this.queryManager.fetchQuery(qid, combinedOptions, exports.NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === exports.NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        _this.queryManager.cache.batch({
          update: function(cache3) {
            var updateQuery = fetchMoreOptions.updateQuery;
            if (updateQuery) {
              cache3.updateQuery({
                query: _this.query,
                variables: _this.variables,
                returnPartialData: true,
                optimistic: false
              }, function(previous) {
                return updateQuery(previous, {
                  fetchMoreResult: fetchMoreResult.data,
                  variables: combinedOptions.variables
                });
              });
            } else {
              cache3.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: function(watch) {
            updatedQuerySet.add(watch.query);
          }
        });
        return fetchMoreResult;
      }).finally(function() {
        if (!updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst2(_this);
        }
      });
    };
    ObservableQuery3.prototype.subscribeToMore = function(options2) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options2.document,
        variables: options2.variables,
        context: options2.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options2.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a3) {
              var variables = _a3.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options2.onError) {
            options2.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && globals2.invariant.error(21, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery3.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery3.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = utilities2.compact(this.options, newOptions || {});
      assign2(this.options, mergedOptions);
    };
    ObservableQuery3.prototype.setVariables = function(variables) {
      if (equal2.equal(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, exports.NetworkStatus.setVariables);
    };
    ObservableQuery3.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery3.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery3.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery3.prototype.applyNextFetchPolicy = function(reason, options2) {
      if (options2.nextFetchPolicy) {
        var _a3 = options2.fetchPolicy, fetchPolicy = _a3 === void 0 ? "cache-first" : _a3, _b2 = options2.initialFetchPolicy, initialFetchPolicy = _b2 === void 0 ? fetchPolicy : _b2;
        if (fetchPolicy === "standby") ;
        else if (typeof options2.nextFetchPolicy === "function") {
          options2.fetchPolicy = options2.nextFetchPolicy(fetchPolicy, {
            reason,
            options: options2,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options2.fetchPolicy = initialFetchPolicy;
        } else {
          options2.fetchPolicy = options2.nextFetchPolicy;
        }
      }
      return options2.fetchPolicy;
    };
    ObservableQuery3.prototype.fetch = function(options2, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options2, newNetworkStatus, query);
    };
    ObservableQuery3.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a3 = this, pollingInfo = _a3.pollingInfo, pollInterval = _a3.options.pollInterval;
      if (!pollInterval || !this.hasObservers()) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      globals2.invariant(pollInterval, 22);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        var _a4, _b2;
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight2(_this.queryInfo.networkStatus) && !((_b2 = (_a4 = _this.options).skipPollAttempt) === null || _b2 === void 0 ? void 0 : _b2.call(_a4))) {
            _this.reobserve({
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, exports.NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery3.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal2.equal(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = tslib2.__assign({ result: this.queryManager.assumeImmutableResults ? newResult : utilities2.cloneDeep(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery3.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = newNetworkStatus === exports.NetworkStatus.refetch || newNetworkStatus === exports.NetworkStatus.fetchMore || newNetworkStatus === exports.NetworkStatus.poll;
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = utilities2.compact(this.options, newOptions || {});
      var options2 = useDisposableConcast ? mergedOptions : assign2(this.options, mergedOptions);
      var query = this.transformDocument(options2.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal2.equal(newOptions.variables, oldVariables) && options2.fetchPolicy !== "standby" && (options2.fetchPolicy === oldFetchPolicy || typeof options2.nextFetchPolicy === "function")) {
          this.applyNextFetchPolicy("variables-changed", options2);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = exports.NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor2(options2.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options2.variables && tslib2.__assign({}, options2.variables);
      var _a3 = this.fetch(options2, newNetworkStatus, query), concast = _a3.concast, fromLink = _a3.fromLink;
      var observer = {
        next: function(result) {
          if (equal2.equal(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportResult(result, variables);
          }
        },
        error: function(error) {
          if (equal2.equal(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportError(error, variables);
          }
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery3.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return this.reobserveAsConcast(newOptions, newNetworkStatus).promise;
    };
    ObservableQuery3.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      var last = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last;
      return subscription;
    };
    ObservableQuery3.prototype.observe = function() {
      this.reportResult(
        this.getCurrentResult(false),
        this.variables
      );
    };
    ObservableQuery3.prototype.reportResult = function(result, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result, variables);
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      if (lastError || isDifferent) {
        utilities2.iterateObserversSafely(this.observers, "next", result);
      }
    };
    ObservableQuery3.prototype.reportError = function(error, variables) {
      var errorResult = tslib2.__assign(tslib2.__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: exports.NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      utilities2.iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery3.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery3.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery3.prototype.transformDocument = function(document2) {
      return this.queryManager.transform(document2);
    };
    return ObservableQuery3;
  }(utilities2.Observable);
  utilities2.fixObservableSubclass(ObservableQuery2);
  function reobserveCacheFirst2(obsQuery) {
    var _a3 = obsQuery.options, fetchPolicy = _a3.fetchPolicy, nextFetchPolicy = _a3.nextFetchPolicy;
    if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
      return obsQuery.reobserve({
        fetchPolicy: "cache-first",
        nextFetchPolicy: function(currentFetchPolicy, context2) {
          this.nextFetchPolicy = nextFetchPolicy;
          if (typeof this.nextFetchPolicy === "function") {
            return this.nextFetchPolicy(currentFetchPolicy, context2);
          }
          return fetchPolicy;
        }
      });
    }
    return obsQuery.reobserve();
  }
  function defaultSubscriptionObserverErrorCallback2(error) {
    globalThis.__DEV__ !== false && globals2.invariant.error(23, error.message, error.stack);
  }
  function logMissingFieldErrors2(missing) {
    if (globalThis.__DEV__ !== false && missing) {
      globalThis.__DEV__ !== false && globals2.invariant.debug(24, missing);
    }
  }
  function skipCacheDataFor2(fetchPolicy) {
    return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
  }
  var destructiveMethodCounts2 = new (utilities2.canUseWeakMap ? WeakMap : Map)();
  function wrapDestructiveCacheMethod2(cache3, methodName) {
    var original = cache3[methodName];
    if (typeof original === "function") {
      cache3[methodName] = function() {
        destructiveMethodCounts2.set(
          cache3,
          (destructiveMethodCounts2.get(cache3) + 1) % 1e15
        );
        return original.apply(this, arguments);
      };
    }
  }
  function cancelNotifyTimeout2(info) {
    if (info["notifyTimeout"]) {
      clearTimeout(info["notifyTimeout"]);
      info["notifyTimeout"] = void 0;
    }
  }
  var QueryInfo2 = function() {
    function QueryInfo3(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache3 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts2.has(cache3)) {
        destructiveMethodCounts2.set(cache3, 0);
        wrapDestructiveCacheMethod2(cache3, "evict");
        wrapDestructiveCacheMethod2(cache3, "modify");
        wrapDestructiveCacheMethod2(cache3, "reset");
      }
    }
    QueryInfo3.prototype.init = function(query) {
      var networkStatus = query.networkStatus || exports.NetworkStatus.loading;
      if (this.variables && this.networkStatus !== exports.NetworkStatus.loading && !equal2.equal(this.variables, query.variables)) {
        networkStatus = exports.NetworkStatus.setVariables;
      }
      if (!equal2.equal(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo3.prototype.reset = function() {
      cancelNotifyTimeout2(this);
      this.dirty = false;
    };
    QueryInfo3.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    };
    QueryInfo3.prototype.getDiff = function() {
      var options2 = this.getDiffOptions();
      if (this.lastDiff && equal2.equal(options2, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff2 = this.cache.diff(options2);
      this.updateLastDiff(diff2, options2);
      return diff2;
    };
    QueryInfo3.prototype.updateLastDiff = function(diff2, options2) {
      this.lastDiff = diff2 ? {
        diff: diff2,
        options: options2 || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo3.prototype.getDiffOptions = function(variables) {
      var _a3;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a3 = this.observableQuery) === null || _a3 === void 0 ? void 0 : _a3.options.canonizeResults
      };
    };
    QueryInfo3.prototype.setDiff = function(diff2) {
      var _this = this;
      var _a3;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      if (diff2 && !diff2.complete && ((_a3 = this.observableQuery) === null || _a3 === void 0 ? void 0 : _a3.getLastError())) {
        return;
      }
      this.updateLastDiff(diff2);
      if (!this.dirty && !equal2.equal(oldDiff && oldDiff.result, diff2 && diff2.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo3.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff2 = _this.getDiff();
          if (diff2.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst2(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo3.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout2(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo3.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight2(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo3.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo3.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo3.prototype.cancel = function() {
    };
    QueryInfo3.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = tslib2.__assign(tslib2.__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff2) {
        return _this.setDiff(diff2);
      } });
      if (!this.lastWatch || !equal2.equal(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo3.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo3.prototype.shouldWrite = function(result, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && lastWrite.dmCount === destructiveMethodCounts2.get(this.cache) && equal2.equal(variables, lastWrite.variables) && equal2.equal(result.data, lastWrite.result.data));
    };
    QueryInfo3.prototype.markResult = function(result, document2, options2, cacheWriteBehavior) {
      var _this = this;
      var merger = new utilities2.DeepMerger();
      var graphQLErrors = utilities2.isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result && utilities2.isNonEmptyArray(result.incremental)) {
        var mergedData = utilities2.mergeIncrementalData(this.getDiff().result, result);
        result.data = mergedData;
      } else if ("hasNext" in result && result.hasNext) {
        var diff2 = this.getDiff();
        result.data = merger.merge(diff2.result, result.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options2.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options2.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult2(result, options2.errorPolicy)) {
          this.cache.performTransaction(function(cache3) {
            if (_this.shouldWrite(result, options2.variables)) {
              cache3.writeQuery({
                query: document2,
                data: result.data,
                variables: options2.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result,
                variables: options2.variables,
                dmCount: destructiveMethodCounts2.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options2.variables);
            var diff3 = cache3.diff(diffOptions);
            if (!_this.stopped && equal2.equal(_this.variables, options2.variables)) {
              _this.updateWatch(options2.variables);
            }
            _this.updateLastDiff(diff3, diffOptions);
            if (diff3.complete) {
              result.data = diff3.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo3.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = exports.NetworkStatus.ready;
    };
    QueryInfo3.prototype.markError = function(error) {
      this.networkStatus = exports.NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo3;
  }();
  function shouldWriteResult2(result, errorPolicy) {
    if (errorPolicy === void 0) {
      errorPolicy = "none";
    }
    var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
    var writeWithErrors = !utilities2.graphQLResultHasError(result);
    if (!writeWithErrors && ignoreErrors && result.data) {
      writeWithErrors = true;
    }
    return writeWithErrors;
  }
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var IGNORE2 = /* @__PURE__ */ Object.create(null);
  var QueryManager2 = function() {
    function QueryManager3(options2) {
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new utilities2.AutoCleanedWeakCache(utilities2.cacheSizes["queryManager.getDocumentInfo"] || 2e3);
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = new trie2.Trie(false);
      var defaultDocumentTransform = new utilities2.DocumentTransform(
        function(document2) {
          return _this.cache.transformDocument(document2);
        },
        { cache: false }
      );
      this.cache = options2.cache;
      this.link = options2.link;
      this.defaultOptions = options2.defaultOptions;
      this.queryDeduplication = options2.queryDeduplication;
      this.clientAwareness = options2.clientAwareness;
      this.localState = options2.localState;
      this.ssrMode = options2.ssrMode;
      this.assumeImmutableResults = options2.assumeImmutableResults;
      var documentTransform = options2.documentTransform;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      this.defaultContext = options2.defaultContext || /* @__PURE__ */ Object.create(null);
      if (this.onBroadcast = options2.onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager3.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(globals2.newInvariantError(25));
    };
    QueryManager3.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager3.prototype.mutate = function(_a3) {
      return tslib2.__awaiter(this, arguments, void 0, function(_b2) {
        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
        var _c2, _d;
        var mutation = _b2.mutation, variables = _b2.variables, optimisticResponse = _b2.optimisticResponse, updateQueries = _b2.updateQueries, _e2 = _b2.refetchQueries, refetchQueries = _e2 === void 0 ? [] : _e2, _f = _b2.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b2.update, onQueryUpdated = _b2.onQueryUpdated, _g = _b2.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c2 = this.defaultOptions.mutate) === null || _c2 === void 0 ? void 0 : _c2.fetchPolicy) || "network-only" : _g, _h = _b2.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b2.keepRootFields, context2 = _b2.context;
        return tslib2.__generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              globals2.invariant(mutation, 26);
              globals2.invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 27);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2) return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context2)];
            case 1:
              variables = _j.sent();
              _j.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context: context2,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return utilities2.asyncMap(self2.getObservableFromLink(mutation, tslib2.__assign(tslib2.__assign({}, context2), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result) {
                  if (utilities2.graphQLResultHasError(result) && errorPolicy === "none") {
                    throw new errors2.ApolloError({
                      graphQLErrors: utilities2.getGraphQLErrorsFromResult(result)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = tslib2.__assign({}, result);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && utilities2.graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context: context2,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: isOptimistic ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(storeResult);
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (isOptimistic) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof errors2.ApolloError ? err : new errors2.ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager3.prototype.markMutationResult = function(mutation, cache3) {
      var _this = this;
      if (cache3 === void 0) {
        cache3 = this.cache;
      }
      var result = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult2(result, mutation.errorPolicy)) {
        if (!utilities2.isExecutionPatchIncrementalResult(result)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (utilities2.isExecutionPatchIncrementalResult(result) && utilities2.isNonEmptyArray(result.incremental)) {
          var diff2 = cache3.diff({
            id: "ROOT_MUTATION",
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff2.result) {
            mergedData = mergeIncrementalData2(diff2.result, result);
          }
          if (typeof mergedData !== "undefined") {
            result.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a3, queryId) {
            var observableQuery = _a3.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty2.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b2 = _this.queries.get(queryId), document2 = _b2.document, variables = _b2.variables;
            var _c2 = cache3.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c2.result, complete = _c2.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result,
                queryName: document2 && utilities2.getOperationName(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache4) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache4.write(write);
              });
            }
            var update = mutation.update;
            var isFinalResult = !utilities2.isExecutionPatchResult(result) || utilities2.isExecutionPatchIncrementalResult(result) && !result.hasNext;
            if (update) {
              if (!skipCache) {
                var diff3 = cache4.diff({
                  id: "ROOT_MUTATION",
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff3.complete) {
                  result = tslib2.__assign(tslib2.__assign({}, result), { data: diff3.result });
                  if ("incremental" in result) {
                    delete result.incremental;
                  }
                  if ("hasNext" in result) {
                    delete result.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache4, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache4.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a3) {
                  var fieldName = _a3.fieldName, DELETE2 = _a3.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          optimistic: false,
          removeOptimistic: mutation.removeOptimistic,
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result2) {
          return results_1.push(result2);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result;
          });
        }
      }
      return Promise.resolve(result);
    };
    QueryManager3.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE: IGNORE2 }) : optimisticResponse;
      if (data === IGNORE2) {
        return false;
      }
      this.cache.recordOptimisticTransaction(function(cache3) {
        try {
          _this.markMutationResult(tslib2.__assign(tslib2.__assign({}, mutation), { result: { data } }), cache3);
        } catch (error) {
          globalThis.__DEV__ !== false && globals2.invariant.error(error);
        }
      }, mutation.mutationId);
      return true;
    };
    QueryManager3.prototype.fetchQuery = function(queryId, options2, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options2, networkStatus).concast.promise;
    };
    QueryManager3.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager3.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager3.prototype.transform = function(document2) {
      return this.documentTransform.transformDocument(document2);
    };
    QueryManager3.prototype.getDocumentInfo = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var cacheEntry = {
          hasClientExports: utilities2.hasClientExports(document2),
          hasForcedResolvers: this.localState.shouldForceResolvers(document2),
          hasNonreactiveDirective: utilities2.hasDirectives(["nonreactive"], document2),
          clientQuery: this.localState.clientQuery(document2),
          serverQuery: utilities2.removeDirectivesFromDocument([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" }
          ], document2),
          defaultVars: utilities2.getDefaultValues(utilities2.getOperationDefinition(document2)),
          asQuery: tslib2.__assign(tslib2.__assign({}, document2), { definitions: document2.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return tslib2.__assign(tslib2.__assign({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document2, cacheEntry);
      }
      return transformCache.get(document2);
    };
    QueryManager3.prototype.getVariables = function(document2, variables) {
      return tslib2.__assign(tslib2.__assign({}, this.getDocumentInfo(document2).defaultVars), variables);
    };
    QueryManager3.prototype.watchQuery = function(options2) {
      var query = this.transform(options2.query);
      options2 = tslib2.__assign(tslib2.__assign({}, options2), { variables: this.getVariables(query, options2.variables) });
      if (typeof options2.notifyOnNetworkStatusChange === "undefined") {
        options2.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo2(this);
      var observable = new ObservableQuery2({
        queryManager: this,
        queryInfo,
        options: options2
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager3.prototype.query = function(options2, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      globals2.invariant(options2.query, 28);
      globals2.invariant(options2.query.kind === "Document", 29);
      globals2.invariant(!options2.returnPartialData, 30);
      globals2.invariant(!options2.pollInterval, 31);
      return this.fetchQuery(queryId, tslib2.__assign(tslib2.__assign({}, options2), { query: this.transform(options2.query) })).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager3.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager3.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager3.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager3.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager3.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager3.prototype.clearStore = function(options2) {
      if (options2 === void 0) {
        options2 = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(globals2.newInvariantError(32));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = exports.NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options2);
    };
    QueryManager3.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNamesAndDocs = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNamesAndDocs.set(desc, false);
          } else if (utilities2.isDocumentNode(desc)) {
            queryNamesAndDocs.set(_this.transform(desc), false);
          } else if (utilities2.isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a3, queryId) {
        var oq = _a3.observableQuery, document2 = _a3.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndDocs.has(queryName) || document2 && queryNamesAndDocs.has(document2)) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndDocs.set(queryName, true);
            if (document2)
              queryNamesAndDocs.set(document2, true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options2) {
          var queryId = utilities2.makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options2.query,
            variables: options2.variables
          });
          var oq = new ObservableQuery2({
            queryManager: _this,
            queryInfo,
            options: tslib2.__assign(tslib2.__assign({}, options2), { fetchPolicy: "network-only" })
          });
          globals2.invariant(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndDocs.size) {
        queryNamesAndDocs.forEach(function(included, nameOrDoc) {
          if (!included) {
            globalThis.__DEV__ !== false && globals2.invariant.warn(typeof nameOrDoc === "string" ? 33 : 34, nameOrDoc);
          }
        });
      }
      return queries;
    };
    QueryManager3.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager3.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager3.prototype.startGraphQLSubscription = function(_a3) {
      var _this = this;
      var query = _a3.query, fetchPolicy = _a3.fetchPolicy, _b2 = _a3.errorPolicy, errorPolicy = _b2 === void 0 ? "none" : _b2, variables = _a3.variables, _c2 = _a3.context, context2 = _c2 === void 0 ? {} : _c2, _d = _a3.extensions, extensions = _d === void 0 ? {} : _d;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context2, variables2, extensions).map(function(result) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult2(result, errorPolicy)) {
              _this.cache.write({
                query,
                result: result.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = utilities2.graphQLResultHasError(result);
          var hasProtocolErrors = errors2.graphQLResultHasProtocolErrors(result);
          if (hasErrors || hasProtocolErrors) {
            var errors$12 = {};
            if (hasErrors) {
              errors$12.graphQLErrors = result.errors;
            }
            if (hasProtocolErrors) {
              errors$12.protocolErrors = result.extensions[errors2.PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new errors2.ApolloError(errors$12);
            }
          }
          if (errorPolicy === "ignore") {
            delete result.errors;
          }
          return result;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context2).then(makeObservable);
        return new utilities2.Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager3.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager3.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager3.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager3.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager3.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager3.prototype.getObservableFromLink = function(query, context2, variables, extensions, deduplication) {
      var _this = this;
      var _a3;
      if (deduplication === void 0) {
        deduplication = (_a3 = context2 === null || context2 === void 0 ? void 0 : context2.queryDeduplication) !== null && _a3 !== void 0 ? _a3 : this.queryDeduplication;
      }
      var observable;
      var _b2 = this.getDocumentInfo(query), serverQuery = _b2.serverQuery, clientQuery = _b2.clientQuery;
      if (serverQuery) {
        var _c2 = this, inFlightLinkObservables_1 = _c2.inFlightLinkObservables, link = _c2.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: utilities2.getOperationName(serverQuery) || void 0,
          context: this.prepareContext(tslib2.__assign(tslib2.__assign({}, context2), { forceFetch: !deduplication })),
          extensions
        };
        context2 = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = utilities2.print(serverQuery);
          var varJson_1 = cache2.canonicalStringify(variables);
          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
          observable = entry.observable;
          if (!observable) {
            var concast = new utilities2.Concast([
              core2.execute(link, operation)
            ]);
            observable = entry.observable = concast;
            concast.beforeNext(function() {
              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
            });
          }
        } else {
          observable = new utilities2.Concast([
            core2.execute(link, operation)
          ]);
        }
      } else {
        observable = new utilities2.Concast([utilities2.Observable.of({ data: {} })]);
        context2 = this.prepareContext(context2);
      }
      if (clientQuery) {
        observable = utilities2.asyncMap(observable, function(result) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result,
            context: context2,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager3.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options2) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options2.query);
      return utilities2.asyncMap(this.getObservableFromLink(linkDocument, options2.context, options2.variables), function(result) {
        var graphQLErrors = utilities2.getGraphQLErrorsFromResult(result);
        var hasErrors = graphQLErrors.length > 0;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && options2.errorPolicy === "none") {
            throw queryInfo.markError(new errors2.ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result, linkDocument, options2, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result.data,
          loading: false,
          networkStatus: exports.NetworkStatus.ready
        };
        if (hasErrors && options2.errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = exports.NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = errors2.isApolloError(networkError) ? networkError : new errors2.ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager3.prototype.fetchConcastWithInfo = function(queryId, options2, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = exports.NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options2.query;
      }
      var variables = this.getVariables(query, options2.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a3 = options2.fetchPolicy, fetchPolicy = _a3 === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a3, _b2 = options2.errorPolicy, errorPolicy = _b2 === void 0 ? defaults && defaults.errorPolicy || "none" : _b2, _c2 = options2.returnPartialData, returnPartialData = _c2 === void 0 ? false : _c2, _d = options2.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e2 = options2.context, context2 = _e2 === void 0 ? {} : _e2;
      var normalized = Object.assign({}, options2, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context: context2
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (normalized.fetchPolicy !== "standby" && sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options2);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new utilities2.Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new utilities2.Concast(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager3.prototype.refetchQueries = function(_a3) {
      var _this = this;
      var updateCache = _a3.updateCache, include = _a3.include, _b2 = _a3.optimistic, optimistic = _b2 === void 0 ? false : _b2, _c2 = _a3.removeOptimistic, removeOptimistic = _c2 === void 0 ? optimistic ? utilities2.makeUniqueId("refetchQueries") : void 0 : _c2, onQueryUpdated = _a3.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          optimistic: optimistic && removeOptimistic || false,
          removeOptimistic,
          onWatchUpdated: function(watch, diff2, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo2 && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result = onQueryUpdated(oq, diff2, lastDiff);
                if (result === true) {
                  result = oq.refetch();
                }
                if (result !== false) {
                  results.set(oq, result);
                }
                return result;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff: diff2 });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a4, queryId) {
          var oq = _a4.oq, lastDiff = _a4.lastDiff, diff2 = _a4.diff;
          var result;
          if (onQueryUpdated) {
            if (!diff2) {
              var info = oq["queryInfo"];
              info.reset();
              diff2 = info.getDiff();
            }
            result = onQueryUpdated(oq, diff2, lastDiff);
          }
          if (!onQueryUpdated || result === true) {
            result = oq.refetch();
          }
          if (result !== false) {
            results.set(oq, result);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results;
    };
    QueryManager3.prototype.fetchQueryByPolicy = function(queryInfo, _a3, networkStatus) {
      var _this = this;
      var query = _a3.query, variables = _a3.variables, fetchPolicy = _a3.fetchPolicy, refetchWritePolicy = _a3.refetchWritePolicy, errorPolicy = _a3.errorPolicy, returnPartialData = _a3.returnPartialData, context2 = _a3.context, notifyOnNetworkStatusChange = _a3.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff3, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || exports.NetworkStatus.loading;
        }
        var data = diff3.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal2.equal(data, {})) {
          logMissingFieldErrors2(diff3.missing);
        }
        var fromData = function(data2) {
          return utilities2.Observable.of(tslib2.__assign({ data: data2, loading: isNetworkRequestInFlight2(networkStatus2), networkStatus: networkStatus2 }, diff3.complete ? null : { partial: true }));
        };
        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context: context2,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === exports.NetworkStatus.refetch && Array.isArray(diff3.missing)) {
          return fromData(void 0);
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === exports.NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context: context2,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight2(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff2 = readCache();
          if (diff2.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff2, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff2), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff2 = readCache();
          if (diff2.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff2), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager3.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo2(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager3.prototype.prepareContext = function(context2) {
      if (context2 === void 0) {
        context2 = {};
      }
      var newContext = this.localState.prepareContext(context2);
      return tslib2.__assign(tslib2.__assign(tslib2.__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager3;
  }();
  var LocalState2 = function() {
    function LocalState3(_a3) {
      var cache3 = _a3.cache, client = _a3.client, resolvers = _a3.resolvers, fragmentMatcher = _a3.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache3;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState3.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = utilities2.mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = utilities2.mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState3.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState3.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState3.prototype.runResolvers = function(_a3) {
      return tslib2.__awaiter(this, arguments, void 0, function(_b2) {
        var document2 = _b2.document, remoteResult = _b2.remoteResult, context2 = _b2.context, variables = _b2.variables, _c2 = _b2.onlyRunForcedResolvers, onlyRunForcedResolvers = _c2 === void 0 ? false : _c2;
        return tslib2.__generator(this, function(_d) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context2, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return tslib2.__assign(tslib2.__assign({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState3.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState3.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState3.prototype.clientQuery = function(document2) {
      if (utilities2.hasDirectives(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState3.prototype.serverQuery = function(document2) {
      return utilities2.removeClientSetsFromDocument(document2);
    };
    LocalState3.prototype.prepareContext = function(context2) {
      var cache3 = this.cache;
      return tslib2.__assign(tslib2.__assign({}, context2), {
        cache: cache3,
        getCacheKey: function(obj) {
          return cache3.identify(obj);
        }
      });
    };
    LocalState3.prototype.addExportedVariables = function(document_1) {
      return tslib2.__awaiter(this, arguments, void 0, function(document2, variables, context2) {
        if (variables === void 0) {
          variables = {};
        }
        if (context2 === void 0) {
          context2 = {};
        }
        return tslib2.__generator(this, function(_a3) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context2), variables).then(function(data) {
              return tslib2.__assign(tslib2.__assign({}, variables), data.exportedVariables);
            })];
          }
          return [2, tslib2.__assign({}, variables)];
        });
      });
    };
    LocalState3.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      graphql2.visit(document2, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return graphql2.BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState3.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: utilities2.buildQueryFromSelectionSet(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState3.prototype.resolveDocument = function(document_1, rootValue_1) {
      return tslib2.__awaiter(this, arguments, void 0, function(document2, rootValue, context2, variables, fragmentMatcher, onlyRunForcedResolvers) {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a3, cache3, client, execContext, isClientFieldDescendant;
        if (context2 === void 0) {
          context2 = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return tslib2.__generator(this, function(_b2) {
          mainDefinition = utilities2.getMainDefinition(document2);
          fragments = utilities2.getFragmentDefinitions(document2);
          fragmentMap = utilities2.createFragmentMap(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a3 = this, cache3 = _a3.cache, client = _a3.client;
          execContext = {
            fragmentMap,
            context: tslib2.__assign(tslib2.__assign({}, context2), { cache: cache3, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
            return {
              result,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState3.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var fragmentMap, context2, variables, resultsToMerge, execute2;
        var _this = this;
        return tslib2.__generator(this, function(_a3) {
          fragmentMap = execContext.fragmentMap, context2 = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return tslib2.__awaiter(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return tslib2.__generator(this, function(_a4) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [2];
                }
                if (!utilities2.shouldInclude(selection, variables)) {
                  return [2];
                }
                if (utilities2.isField(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a5;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a5 = {}, _a5[utilities2.resultKeyNameFromField(selection)] = fieldResult, _a5));
                    }
                  })];
                }
                if (utilities2.isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  globals2.invariant(fragment, 18, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context2)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [2];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return utilities2.mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState3.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return tslib2.__awaiter(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return tslib2.__generator(this, function(_a3) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = utilities2.resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  cache2.cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    utilities2.argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result) {
            var _a4, _b2;
            if (result === void 0) {
              result = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result;
            }
            if (result == null) {
              return result;
            }
            var isClientField = (_b2 = (_a4 = field.directives) === null || _a4 === void 0 ? void 0 : _a4.some(function(d3) {
              return d3.name.value === "client";
            })) !== null && _b2 !== void 0 ? _b2 : false;
            if (Array.isArray(result)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
            }
          })];
        });
      });
    };
    LocalState3.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
      var _this = this;
      return Promise.all(result.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState3.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node) {
        return !Array.isArray(node);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          graphql2.visit(definitionNode, {
            Directive: function(node, _2, __, ___, ancestors) {
              if (node.name.value === "client") {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && graphql2.isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _2, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              globals2.invariant(fragment, 19, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node) {
                  if (isSingleASTNode(node) && graphql2.isSelectionNode(node)) {
                    matches_1.add(node);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState3;
  }();
  var cacheSizeSymbol2 = Symbol.for("apollo.cacheSize");
  var cacheSizes2 = tslib2.__assign({}, globals2.global[cacheSizeSymbol2]);
  var globalCaches2 = {};
  var getApolloClientMemoryInternals2 = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals2 : void 0;
  function getCurrentCacheSizes2() {
    var defaults = {
      parser: 1e3,
      canonicalStringify: 1e3,
      print: 2e3,
      "documentTransform.cache": 2e3,
      "queryManager.getDocumentInfo": 2e3,
      "PersistedQueryLink.persistedQueryHashes": 2e3,
      "fragmentRegistry.transform": 2e3,
      "fragmentRegistry.lookup": 1e3,
      "fragmentRegistry.findFragmentSpreads": 4e3,
      "cache.fragmentQueryDocuments": 1e3,
      "removeTypenameFromVariables.getVariableDefinitions": 2e3,
      "inMemoryCache.maybeBroadcastWatch": 5e3,
      "inMemoryCache.executeSelectionSet": 5e4,
      "inMemoryCache.executeSubSelectedArray": 1e4
    };
    return Object.fromEntries(Object.entries(defaults).map(function(_a3) {
      var k3 = _a3[0], v2 = _a3[1];
      return [
        k3,
        cacheSizes2[k3] || v2
      ];
    }));
  }
  function _getApolloClientMemoryInternals2() {
    var _a3, _b2, _c2, _d, _e2;
    if (!(globalThis.__DEV__ !== false))
      throw new Error("only supported in development mode");
    return {
      limits: getCurrentCacheSizes2(),
      sizes: tslib2.__assign({ print: (_a3 = globalCaches2.print) === null || _a3 === void 0 ? void 0 : _a3.call(globalCaches2), parser: (_b2 = globalCaches2.parser) === null || _b2 === void 0 ? void 0 : _b2.call(globalCaches2), canonicalStringify: (_c2 = globalCaches2.canonicalStringify) === null || _c2 === void 0 ? void 0 : _c2.call(globalCaches2), links: linkInfo2(this.link), queryManager: {
        getDocumentInfo: this["queryManager"]["transformCache"].size,
        documentTransforms: transformInfo2(this["queryManager"].documentTransform)
      } }, (_e2 = (_d = this.cache).getMemoryInternals) === null || _e2 === void 0 ? void 0 : _e2.call(_d))
    };
  }
  function isWrapper2(f3) {
    return !!f3 && "dirtyKey" in f3;
  }
  function getWrapperInformation2(f3) {
    return isWrapper2(f3) ? f3.size : void 0;
  }
  function isDefined2(value) {
    return value != null;
  }
  function transformInfo2(transform) {
    return recurseTransformInfo2(transform).map(function(cache3) {
      return { cache: cache3 };
    });
  }
  function recurseTransformInfo2(transform) {
    return transform ? tslib2.__spreadArray(tslib2.__spreadArray([
      getWrapperInformation2(transform === null || transform === void 0 ? void 0 : transform["performWork"])
    ], recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["left"]), true), recurseTransformInfo2(transform === null || transform === void 0 ? void 0 : transform["right"]), true).filter(isDefined2) : [];
  }
  function linkInfo2(link) {
    var _a3;
    return link ? tslib2.__spreadArray(tslib2.__spreadArray([
      (_a3 = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a3 === void 0 ? void 0 : _a3.call(link)
    ], linkInfo2(link === null || link === void 0 ? void 0 : link.left), true), linkInfo2(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined2) : [];
  }
  var hasSuggestedDevtools2 = false;
  var ApolloClient2 = function() {
    function ApolloClient3(options2) {
      var _this = this;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options2.cache) {
        throw globals2.newInvariantError(15);
      }
      var uri = options2.uri, credentials = options2.credentials, headers = options2.headers, cache3 = options2.cache, documentTransform = options2.documentTransform, _a3 = options2.ssrMode, ssrMode = _a3 === void 0 ? false : _a3, _b2 = options2.ssrForceFetchDelay, ssrForceFetchDelay = _b2 === void 0 ? 0 : _b2, connectToDevTools = options2.connectToDevTools, _c2 = options2.queryDeduplication, queryDeduplication = _c2 === void 0 ? true : _c2, defaultOptions2 = options2.defaultOptions, defaultContext = options2.defaultContext, _d = options2.assumeImmutableResults, assumeImmutableResults = _d === void 0 ? cache3.assumeImmutableResults : _d, resolvers = options2.resolvers, typeDefs = options2.typeDefs, fragmentMatcher = options2.fragmentMatcher, clientAwarenessName = options2.name, clientAwarenessVersion = options2.version, devtools = options2.devtools;
      var link = options2.link;
      if (!link) {
        link = uri ? new http2.HttpLink({ uri, credentials, headers }) : core2.ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache3;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      this.devtoolsConfig = tslib2.__assign(tslib2.__assign({}, devtools), { enabled: (devtools === null || devtools === void 0 ? void 0 : devtools.enabled) || connectToDevTools });
      if (this.devtoolsConfig.enabled === void 0) {
        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
      }
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.watchFragment = this.watchFragment.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version2;
      this.localState = new LocalState2({
        cache: cache3,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager2({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext,
        documentTransform,
        queryDeduplication,
        ssrMode,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (this.devtoolsConfig.enabled)
        this.connectToDevTools();
    }
    ApolloClient3.prototype.connectToDevTools = function() {
      if (typeof window === "undefined") {
        return;
      }
      var windowWithDevTools = window;
      var devtoolsSymbol = Symbol.for("apollo.devtools");
      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
      windowWithDevTools.__APOLLO_CLIENT__ = this;
      if (!hasSuggestedDevtools2 && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools2 = true;
        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
          setTimeout(function() {
            if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
              var nav = window.navigator;
              var ua2 = nav && nav.userAgent;
              var url = void 0;
              if (typeof ua2 === "string") {
                if (ua2.indexOf("Chrome/") > -1) {
                  url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                } else if (ua2.indexOf("Firefox/") > -1) {
                  url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                }
              }
              if (url) {
                globalThis.__DEV__ !== false && globals2.invariant.log("Download the Apollo DevTools for a better development experience: %s", url);
              }
            }
          }, 1e4);
        }
      }
    };
    Object.defineProperty(ApolloClient3.prototype, "documentTransform", {
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient3.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient3.prototype.watchQuery = function(options2) {
      if (this.defaultOptions.watchQuery) {
        options2 = utilities2.mergeOptions(this.defaultOptions.watchQuery, options2);
      }
      if (this.disableNetworkFetches && (options2.fetchPolicy === "network-only" || options2.fetchPolicy === "cache-and-network")) {
        options2 = tslib2.__assign(tslib2.__assign({}, options2), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options2);
    };
    ApolloClient3.prototype.query = function(options2) {
      if (this.defaultOptions.query) {
        options2 = utilities2.mergeOptions(this.defaultOptions.query, options2);
      }
      globals2.invariant(options2.fetchPolicy !== "cache-and-network", 16);
      if (this.disableNetworkFetches && options2.fetchPolicy === "network-only") {
        options2 = tslib2.__assign(tslib2.__assign({}, options2), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options2);
    };
    ApolloClient3.prototype.mutate = function(options2) {
      if (this.defaultOptions.mutate) {
        options2 = utilities2.mergeOptions(this.defaultOptions.mutate, options2);
      }
      return this.queryManager.mutate(options2);
    };
    ApolloClient3.prototype.subscribe = function(options2) {
      return this.queryManager.startGraphQLSubscription(options2);
    };
    ApolloClient3.prototype.readQuery = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options2, optimistic);
    };
    ApolloClient3.prototype.watchFragment = function(options2) {
      return this.cache.watchFragment(options2);
    };
    ApolloClient3.prototype.readFragment = function(options2, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options2, optimistic);
    };
    ApolloClient3.prototype.writeQuery = function(options2) {
      var ref = this.cache.writeQuery(options2);
      if (options2.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient3.prototype.writeFragment = function(options2) {
      var ref = this.cache.writeFragment(options2);
      if (options2.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient3.prototype.__actionHookForDevTools = function(cb2) {
      this.devToolsHookCb = cb2;
    };
    ApolloClient3.prototype.__requestRaw = function(payload) {
      return core2.execute(this.link, payload);
    };
    ApolloClient3.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn2) {
          return fn2();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient3.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn2) {
          return fn2();
        }));
      });
    };
    ApolloClient3.prototype.onResetStore = function(cb2) {
      var _this = this;
      this.resetStoreCallbacks.push(cb2);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient3.prototype.onClearStore = function(cb2) {
      var _this = this;
      this.clearStoreCallbacks.push(cb2);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c2) {
          return c2 !== cb2;
        });
      };
    };
    ApolloClient3.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient3.prototype.refetchQueries = function(options2) {
      var map = this.queryManager.refetchQueries(options2);
      var queries = [];
      var results = [];
      map.forEach(function(result2, obsQuery) {
        queries.push(obsQuery);
        results.push(result2);
      });
      var result = Promise.all(results);
      result.queries = queries;
      result.results = results;
      result.catch(function(error) {
        globalThis.__DEV__ !== false && globals2.invariant.debug(17, error);
      });
      return result;
    };
    ApolloClient3.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient3.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient3.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient3.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient3.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient3.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient3.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient3.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    Object.defineProperty(ApolloClient3.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: false,
      configurable: true
    });
    return ApolloClient3;
  }();
  if (globalThis.__DEV__ !== false) {
    ApolloClient2.prototype.getMemoryInternals = getApolloClientMemoryInternals2;
  }
  tsInvariant.setVerbosity(globalThis.__DEV__ !== false ? "log" : "silent");
  exports.DocumentTransform = utilities2.DocumentTransform;
  exports.Observable = utilities2.Observable;
  exports.isReference = utilities2.isReference;
  exports.makeReference = utilities2.makeReference;
  exports.mergeOptions = utilities2.mergeOptions;
  exports.ApolloCache = cache2.ApolloCache;
  exports.Cache = cache2.Cache;
  exports.InMemoryCache = cache2.InMemoryCache;
  exports.MissingFieldError = cache2.MissingFieldError;
  exports.defaultDataIdFromObject = cache2.defaultDataIdFromObject;
  exports.makeVar = cache2.makeVar;
  exports.ApolloError = errors2.ApolloError;
  exports.isApolloError = errors2.isApolloError;
  exports.fromError = utils2.fromError;
  exports.fromPromise = utils2.fromPromise;
  exports.throwServerError = utils2.throwServerError;
  exports.toPromise = utils2.toPromise;
  exports.setLogVerbosity = tsInvariant.setVerbosity;
  exports.disableExperimentalFragmentVariables = graphqlTag.disableExperimentalFragmentVariables;
  exports.disableFragmentWarnings = graphqlTag.disableFragmentWarnings;
  exports.enableExperimentalFragmentVariables = graphqlTag.enableExperimentalFragmentVariables;
  exports.gql = graphqlTag.gql;
  exports.resetCaches = graphqlTag.resetCaches;
  exports.ApolloClient = ApolloClient2;
  exports.ObservableQuery = ObservableQuery2;
  exports.isNetworkRequestSettled = isNetworkRequestSettled2;
  for (var k2 in core2) {
    if (k2 !== "default" && !exports.hasOwnProperty(k2)) exports[k2] = core2[k2];
  }
  for (var k2 in http2) {
    if (k2 !== "default" && !exports.hasOwnProperty(k2)) exports[k2] = http2[k2];
  }
})(core$2);
var context = {};
Object.defineProperty(context, "__esModule", { value: true });
var tslib$1 = require$$0;
var core$1 = require$$3$1;
var utilities$1 = require$$2$1;
function setContext(setter) {
  return new core$1.ApolloLink(function(operation, forward) {
    var request = tslib$1.__rest(operation, []);
    return new utilities$1.Observable(function(observer) {
      var handle;
      var closed = false;
      Promise.resolve(request).then(function(req) {
        return setter(req, operation.getContext());
      }).then(operation.setContext).then(function() {
        if (closed)
          return;
        handle = forward(operation).subscribe({
          next: observer.next.bind(observer),
          error: observer.error.bind(observer),
          complete: observer.complete.bind(observer)
        });
      }).catch(observer.error.bind(observer));
      return function() {
        closed = true;
        if (handle)
          handle.unsubscribe();
      };
    });
  });
}
var setContext_1 = context.setContext = setContext;
var persistedQueries = {};
Object.defineProperty(persistedQueries, "__esModule", { value: true });
var tslib = require$$0;
var globals = require$$1;
var utilities = require$$2$1;
var core = require$$3$1;
var VERSION = 1;
function processErrors(graphQLErrors) {
  var byMessage = /* @__PURE__ */ Object.create(null), byCode = /* @__PURE__ */ Object.create(null);
  if (utilities.isNonEmptyArray(graphQLErrors)) {
    graphQLErrors.forEach(function(error) {
      var _a3;
      byMessage[error.message] = error;
      if (typeof ((_a3 = error.extensions) === null || _a3 === void 0 ? void 0 : _a3.code) == "string")
        byCode[error.extensions.code] = error;
    });
  }
  return {
    persistedQueryNotSupported: !!(byMessage.PersistedQueryNotSupported || byCode.PERSISTED_QUERY_NOT_SUPPORTED),
    persistedQueryNotFound: !!(byMessage.PersistedQueryNotFound || byCode.PERSISTED_QUERY_NOT_FOUND)
  };
}
var defaultOptions = {
  disable: function(_a3) {
    var meta = _a3.meta;
    return meta.persistedQueryNotSupported;
  },
  retry: function(_a3) {
    var meta = _a3.meta;
    return meta.persistedQueryNotSupported || meta.persistedQueryNotFound;
  },
  useGETForHashedQueries: false
};
function operationDefinesMutation(operation) {
  return operation.query.definitions.some(function(d3) {
    return d3.kind === "OperationDefinition" && d3.operation === "mutation";
  });
}
var createPersistedQueryLink = function(options2) {
  var hashesByQuery;
  function resetHashCache() {
    hashesByQuery = void 0;
  }
  globals.invariant(options2 && (typeof options2.sha256 === "function" || typeof options2.generateHash === "function"), 40);
  var _a3 = utilities.compact(defaultOptions, options2), sha256 = _a3.sha256, _b2 = _a3.generateHash, generateHash = _b2 === void 0 ? function(query) {
    return Promise.resolve(sha256(utilities.print(query)));
  } : _b2, disable = _a3.disable, retry = _a3.retry, useGETForHashedQueries = _a3.useGETForHashedQueries;
  var supportsPersistedQueries = true;
  var getHashPromise = function(query) {
    return new Promise(function(resolve) {
      return resolve(generateHash(query));
    });
  };
  function getQueryHash(query) {
    if (!query || typeof query !== "object") {
      return getHashPromise(query);
    }
    if (!hashesByQuery) {
      hashesByQuery = new utilities.AutoCleanedWeakCache(utilities.cacheSizes["PersistedQueryLink.persistedQueryHashes"] || 2e3);
    }
    var hash = hashesByQuery.get(query);
    if (!hash)
      hashesByQuery.set(query, hash = getHashPromise(query));
    return hash;
  }
  return Object.assign(new core.ApolloLink(function(operation, forward) {
    globals.invariant(forward, 41);
    var query = operation.query;
    return new utilities.Observable(function(observer) {
      var subscription;
      var retried = false;
      var originalFetchOptions;
      var setFetchOptions = false;
      var maybeRetry = function(_a4, cb2) {
        var response = _a4.response, networkError = _a4.networkError;
        if (!retried && (response && response.errors || networkError)) {
          retried = true;
          var graphQLErrors = [];
          var responseErrors = response && response.errors;
          if (utilities.isNonEmptyArray(responseErrors)) {
            graphQLErrors.push.apply(graphQLErrors, responseErrors);
          }
          var networkErrors = void 0;
          if (typeof (networkError === null || networkError === void 0 ? void 0 : networkError.result) !== "string") {
            networkErrors = networkError && networkError.result && networkError.result.errors;
          }
          if (utilities.isNonEmptyArray(networkErrors)) {
            graphQLErrors.push.apply(graphQLErrors, networkErrors);
          }
          var disablePayload = {
            response,
            networkError,
            operation,
            graphQLErrors: utilities.isNonEmptyArray(graphQLErrors) ? graphQLErrors : void 0,
            meta: processErrors(graphQLErrors)
          };
          supportsPersistedQueries = !disable(disablePayload);
          if (!supportsPersistedQueries) {
            resetHashCache();
          }
          if (retry(disablePayload)) {
            if (subscription)
              subscription.unsubscribe();
            operation.setContext({
              http: {
                includeQuery: true,
                includeExtensions: supportsPersistedQueries
              },
              fetchOptions: {
                method: "POST"
              }
            });
            if (setFetchOptions) {
              operation.setContext({ fetchOptions: originalFetchOptions });
            }
            subscription = forward(operation).subscribe(handler);
            return;
          }
        }
        cb2();
      };
      var handler = {
        next: function(response) {
          maybeRetry({ response }, function() {
            return observer.next(response);
          });
        },
        error: function(networkError) {
          maybeRetry({ networkError }, function() {
            return observer.error(networkError);
          });
        },
        complete: observer.complete.bind(observer)
      };
      operation.setContext({
        http: {
          includeQuery: !supportsPersistedQueries,
          includeExtensions: supportsPersistedQueries
        }
      });
      if (useGETForHashedQueries && supportsPersistedQueries && !operationDefinesMutation(operation)) {
        operation.setContext(function(_a4) {
          var _b3 = _a4.fetchOptions, fetchOptions = _b3 === void 0 ? {} : _b3;
          originalFetchOptions = fetchOptions;
          return {
            fetchOptions: tslib.__assign(tslib.__assign({}, fetchOptions), { method: "GET" })
          };
        });
        setFetchOptions = true;
      }
      if (supportsPersistedQueries) {
        getQueryHash(query).then(function(sha256Hash) {
          operation.extensions.persistedQuery = {
            version: VERSION,
            sha256Hash
          };
          subscription = forward(operation).subscribe(handler);
        }).catch(observer.error.bind(observer));
      } else {
        subscription = forward(operation).subscribe(handler);
      }
      return function() {
        if (subscription)
          subscription.unsubscribe();
      };
    });
  }), {
    resetHashCache
  }, globalThis.__DEV__ !== false ? {
    getMemoryInternals: function() {
      var _a4;
      return {
        PersistedQueryLink: {
          persistedQueryHashes: (_a4 = hashesByQuery === null || hashesByQuery === void 0 ? void 0 : hashesByQuery.size) !== null && _a4 !== void 0 ? _a4 : 0
        }
      };
    }
  } : {});
};
persistedQueries.VERSION = VERSION;
var createPersistedQueryLink_1 = persistedQueries.createPersistedQueryLink = createPersistedQueryLink;
var printer = {};
var blockString = {};
var characterClasses = {};
Object.defineProperty(characterClasses, "__esModule", {
  value: true
});
characterClasses.isDigit = isDigit;
characterClasses.isLetter = isLetter;
characterClasses.isNameContinue = isNameContinue;
characterClasses.isNameStart = isNameStart;
characterClasses.isWhiteSpace = isWhiteSpace;
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}
Object.defineProperty(blockString, "__esModule", {
  value: true
});
blockString.dedentBlockStringLines = dedentBlockStringLines;
blockString.isPrintableAsBlockString = isPrintableAsBlockString;
blockString.printBlockString = printBlockString;
var _characterClasses = characterClasses;
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i2 = 0; i2 < lines.length; ++i2) {
    var _firstNonEmptyLine;
    const line = lines[i2];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i2;
    lastNonEmptyLine = i2;
    if (i2 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i2) => i2 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i2 = 0;
  while (i2 < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i2))) {
    ++i2;
  }
  return i2;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i2 = 0; i2 < value.length; ++i2) {
    switch (value.codePointAt(i2)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString(value, options2) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
    (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
  );
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options2 !== null && options2 !== void 0 && options2.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
var printString$1 = {};
Object.defineProperty(printString$1, "__esModule", {
  value: true
});
printString$1.printString = printString;
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
var visitor = {};
var devAssert$1 = {};
Object.defineProperty(devAssert$1, "__esModule", {
  value: true
});
devAssert$1.devAssert = devAssert;
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var inspect$1 = {};
Object.defineProperty(inspect$1, "__esModule", {
  value: true
});
inspect$1.inspect = inspect;
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i2 = 0; i2 < len; ++i2) {
    items.push(formatValue(array[i2], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}
var ast = {};
Object.defineProperty(ast, "__esModule", {
  value: true
});
ast.Token = ast.QueryDocumentKeys = ast.OperationTypeNode = ast.Location = void 0;
ast.isNode = isNode$1;
class Location2 {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
ast.Location = Location2;
class Token2 {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
ast.Token = Token2;
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
ast.QueryDocumentKeys = QueryDocumentKeys;
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode$1(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
ast.OperationTypeNode = OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (ast.OperationTypeNode = OperationTypeNode = {}));
var kinds = {};
Object.defineProperty(kinds, "__esModule", {
  value: true
});
kinds.Kind = void 0;
var Kind;
kinds.Kind = Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (kinds.Kind = Kind = {}));
Object.defineProperty(visitor, "__esModule", {
  value: true
});
visitor.BREAK = void 0;
visitor.getEnterLeaveForKind = getEnterLeaveForKind;
visitor.getVisitFn = getVisitFn;
visitor.visit = visit;
visitor.visitInParallel = visitInParallel;
var _devAssert = devAssert$1;
var _inspect = inspect$1;
var _ast = ast;
var _kinds = kinds;
const BREAK = Object.freeze({});
visitor.BREAK = BREAK;
function visit(root2, visitor2, visitorKeys = _ast.QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(_kinds.Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor2, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index2 = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
        false,
        `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
      );
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor2, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if ((0, _ast.isNode)(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind of Object.values(_kinds.Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i2 = 0; i2 < visitors.length; ++i2) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i2], kind);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i2] = enter;
      leaveList[i2] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i2 = 0; i2 < visitors.length; i2++) {
          if (skipping[i2] === null) {
            var _enterList$i;
            const result = (_enterList$i = enterList[i2]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i2], args);
            if (result === false) {
              skipping[i2] = node;
            } else if (result === BREAK) {
              skipping[i2] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i2 = 0; i2 < visitors.length; i2++) {
          if (skipping[i2] === null) {
            var _leaveList$i;
            const result = (_leaveList$i = leaveList[i2]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i2], args);
            if (result === BREAK) {
              skipping[i2] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          } else if (skipping[i2] === node) {
            skipping[i2] = null;
          }
        }
      }
    };
    mergedVisitor[kind] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor2, kind) {
  const kindVisitor = visitor2[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor2.enter,
    leave: visitor2.leave
  };
}
function getVisitFn(visitor2, kind, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor2, kind);
  return isLeaving ? leave : enter;
}
Object.defineProperty(printer, "__esModule", {
  value: true
});
var print_1 = printer.print = print;
var _blockString = blockString;
var _printString = printString$1;
var _visitor = visitor;
function print(ast2) {
  return (0, _visitor.visit)(ast2, printDocASTReducer);
}
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue: defaultValue2, directives }) => variable + ": " + type + wrap(" = ", defaultValue2) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue: defaultValue2, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue2), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype2 = Object.getPrototypeOf(value);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function extractFiles(value, isExtractable, path = "") {
  if (!arguments.length) throw new TypeError("Argument 1 `value` is required.");
  if (typeof isExtractable !== "function")
    throw new TypeError("Argument 2 `isExtractable` must be a function.");
  if (typeof path !== "string")
    throw new TypeError("Argument 3 `path` must be a string.");
  const clones = /* @__PURE__ */ new Map();
  const files = /* @__PURE__ */ new Map();
  function recurse(value2, path2, recursed) {
    if (isExtractable(value2)) {
      const filePaths = files.get(value2);
      filePaths ? filePaths.push(path2) : files.set(value2, [path2]);
      return null;
    }
    const valueIsList = Array.isArray(value2) || typeof FileList !== "undefined" && value2 instanceof FileList;
    const valueIsPlainObject = isPlainObject(value2);
    if (valueIsList || valueIsPlainObject) {
      let clone = clones.get(value2);
      const uncloned = !clone;
      if (uncloned) {
        clone = valueIsList ? [] : (
          // Replicate if the plain object is an `Object` instance.
          value2 instanceof /** @type {any} */
          Object ? {} : /* @__PURE__ */ Object.create(null)
        );
        clones.set(
          value2,
          /** @type {Clone} */
          clone
        );
      }
      if (!recursed.has(value2)) {
        const pathPrefix = path2 ? `${path2}.` : "";
        const recursedDeeper = new Set(recursed).add(value2);
        if (valueIsList) {
          let index2 = 0;
          for (const item of value2) {
            const itemClone = recurse(
              item,
              pathPrefix + index2++,
              recursedDeeper
            );
            if (uncloned) clone.push(itemClone);
          }
        } else
          for (const key in value2) {
            const propertyClone = recurse(
              value2[key],
              pathPrefix + key,
              recursedDeeper
            );
            if (uncloned)
              clone[key] = propertyClone;
          }
      }
      return clone;
    }
    return value2;
  }
  return {
    clone: recurse(value, path, /* @__PURE__ */ new Set()),
    files
  };
}
function formDataAppendFile(formData, fieldName, file) {
  "name" in file ? formData.append(fieldName, file, file.name) : formData.append(fieldName, file);
}
function isExtractableFile(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob;
}
function createUploadLink({
  uri: fetchUri = "/graphql",
  useGETForQueries,
  isExtractableFile: customIsExtractableFile = isExtractableFile,
  FormData: CustomFormData,
  formDataAppendFile: customFormDataAppendFile = formDataAppendFile,
  print: print2 = defaultPrinter,
  fetch: customFetch,
  fetchOptions,
  credentials,
  headers,
  includeExtensions
} = {}) {
  const linkConfig = {
    http: { includeExtensions },
    options: fetchOptions,
    credentials,
    headers
  };
  return new ApolloLink((operation) => {
    const context2 = (
      /**
       * @type {import("@apollo/client/core/types.js").DefaultContext & {
       *   clientAwareness?: {
       *     name?: string,
       *     version?: string,
       *   },
       * }}
       */
      operation.getContext()
    );
    const {
      // Apollo Studio client awareness `name` and `version` can be configured
      // via `ApolloClient` constructor options:
      // https://www.apollographql.com/docs/graphos/metrics/client-awareness/#setup
      clientAwareness: { name, version: version2 } = {},
      headers: headers2
    } = context2;
    const contextConfig = {
      http: context2.http,
      options: context2.fetchOptions,
      credentials: context2.credentials,
      headers: {
        // Client awareness headers can be overridden by context `headers`.
        ...name && { "apollographql-client-name": name },
        ...version2 && { "apollographql-client-version": version2 },
        ...headers2
      }
    };
    const { options: options2, body } = selectHttpOptionsAndBodyInternal(
      operation,
      print2,
      fallbackHttpConfig,
      linkConfig,
      contextConfig
    );
    const { clone, files } = extractFiles(body, customIsExtractableFile, "");
    let uri = selectURI(operation, fetchUri);
    if (files.size) {
      if (options2.headers)
        delete options2.headers["content-type"];
      const RuntimeFormData = CustomFormData || FormData;
      const form = new RuntimeFormData();
      form.append("operations", serializeFetchParameter(clone, "Payload"));
      const map = {};
      let i2 = 0;
      files.forEach((paths) => {
        map[++i2] = paths;
      });
      form.append("map", JSON.stringify(map));
      i2 = 0;
      files.forEach((_paths, file) => {
        customFormDataAppendFile(form, String(++i2), file);
      });
      options2.body = form;
    } else {
      if (useGETForQueries && // If the operation contains some mutations GET shouldn’t be used.
      !operation.query.definitions.some(
        (definition) => definition.kind === "OperationDefinition" && definition.operation === "mutation"
      ))
        options2.method = "GET";
      if (options2.method === "GET") {
        const { newURI, parseError } = rewriteURIForGET(uri, body);
        if (parseError)
          return new Observable((observer) => {
            observer.error(parseError);
          });
        uri = newURI;
      } else options2.body = serializeFetchParameter(clone, "Payload");
    }
    const { controller } = createSignalIfSupported();
    if (typeof controller !== "boolean") {
      if (options2.signal)
        options2.signal.aborted ? (
          // Signal already aborted, so immediately abort.
          controller.abort()
        ) : (
          // Signal not already aborted, so setup a listener to abort when it
          // does.
          options2.signal.addEventListener(
            "abort",
            () => {
              controller.abort();
            },
            {
              // Prevent a memory leak if the user configured abort controller
              // is long lasting, or controls multiple things.
              once: true
            }
          )
        );
      options2.signal = controller.signal;
    }
    const runtimeFetch = customFetch || fetch;
    return new Observable((observer) => {
      let cleaningUp;
      runtimeFetch(uri, options2).then((response) => {
        operation.setContext({ response });
        return response;
      }).then(parseAndCheckHttpResponse(operation)).then((result) => {
        observer.next(result);
        observer.complete();
      }).catch((error) => {
        if (!cleaningUp) {
          if (error.result && error.result.errors && error.result.data)
            observer.next(error.result);
          observer.error(error);
        }
      });
      return () => {
        cleaningUp = true;
        if (typeof controller !== "boolean") controller.abort();
      };
    });
  });
}
const sseLink = {};
const SSELinkExports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: sseLink
}, Symbol.toStringTag, { value: "Module" }));
const { SSELink, isSubscription, isLiveQuery } = SSELinkExports;
const ApolloProviderWithFetchConfig = ({ config, children, useAuth: useAuth2 = useNoAuth, logLevel }) => {
  core$2.setLogVerbosity(logLevel);
  const { getToken, type: authProviderType } = useAuth2();
  const data = {
    mostRecentRequest: void 0,
    mostRecentResponse: void 0
  };
  const updateDataApolloLink = new ApolloLink((operation, forward) => {
    const { operationName: operationName2, query, variables } = operation;
    data.mostRecentRequest = {};
    data.mostRecentRequest.operationName = operationName2;
    data.mostRecentRequest.operationKind = query == null ? void 0 : query.kind.toString();
    data.mostRecentRequest.variables = variables;
    data.mostRecentRequest.query = query && print_1(operation.query);
    return forward(operation).map((result) => {
      data.mostRecentResponse = result;
      return result;
    });
  });
  const withToken = setContext_1(async () => {
    const token = await getToken();
    return { token };
  });
  const { headers, uri } = useFetchConfig();
  const authMiddleware = new ApolloLink((operation, forward) => {
    const { token } = operation.getContext();
    const authHeaders = token ? {
      "auth-provider": authProviderType,
      authorization: `Bearer ${token}`
    } : {};
    operation.setContext(() => ({
      headers: {
        ...operation.getContext().headers,
        ...headers,
        // Duped auth headers, because we may remove the `FetchConfigProvider` at a later date.
        ...authHeaders
      }
    }));
    return forward(operation);
  });
  const { httpLinkConfig, link: redwoodApolloLink, ...rest } = config ?? {};
  const uploadLink = createUploadLink({
    uri,
    ...httpLinkConfig
    // The upload link types don't match the ApolloLink types, even though it comes from Apollo
    // because they use ESM imports and we're using the default ones.
  });
  const uploadOrSSELink = typeof SSELink !== "undefined" ? split(
    ({ query }) => {
      const definition = getMainDefinition_1(query);
      return isSubscription(definition) || isLiveQuery(definition);
    },
    new SSELink({
      url: uri,
      auth: { authProviderType, tokenFn: getToken },
      httpLinkConfig,
      headers
    }),
    uploadLink
  ) : uploadLink;
  const terminatingLink = split(
    ({ query }) => {
      var _a3;
      const documentQuery = query;
      return ((_a3 = documentQuery == null ? void 0 : documentQuery["__meta__"]) == null ? void 0 : _a3["hash"]) !== void 0;
    },
    createPersistedQueryLink_1({
      generateHash: (document2) => document2["__meta__"]["hash"]
    }).concat(uploadOrSSELink),
    uploadOrSSELink
  );
  const redwoodApolloLinks = [
    { name: "withToken", link: withToken },
    { name: "authMiddleware", link: authMiddleware },
    { name: "updateDataApolloLink", link: updateDataApolloLink },
    { name: "httpLink", link: terminatingLink }
  ];
  let link = redwoodApolloLink;
  link ?? (link = ApolloLink.from(redwoodApolloLinks.map((l3) => l3.link)));
  if (typeof link === "function") {
    link = link(redwoodApolloLinks);
  }
  const client = new ApolloClient({
    // Default options for every Cell. Better to specify them here than in `beforeQuery` where it's too easy to overwrite them.
    // See https://www.apollographql.com/docs/react/api/core/ApolloClient/#example-defaultoptions-object.
    defaultOptions: {
      watchQuery: {
        // The `fetchPolicy` we expect:
        //
        // > Apollo Client executes the full query against both the cache and your GraphQL server.
        // > The query automatically updates if the result of the server-side query modifies cached fields.
        //
        // See https://www.apollographql.com/docs/react/data/queries/#cache-and-network.
        fetchPolicy: "cache-and-network",
        // So that Cells rerender when refetching.
        // See https://www.apollographql.com/docs/react/data/queries/#inspecting-loading-states.
        notifyOnNetworkStatusChange: true
      }
    },
    link,
    ...rest
  });
  const extendErrorAndRethrow = (error, _errorInfo) => {
    error["mostRecentRequest"] = data.mostRecentRequest;
    error["mostRecentResponse"] = data.mostRecentResponse;
    throw error;
  };
  return /* @__PURE__ */ React$2.createElement(ApolloProvider, { client }, /* @__PURE__ */ React$2.createElement(ErrorBoundary, { onError: extendErrorAndRethrow }, children));
};
class ErrorBoundary extends React$2.Component {
  componentDidCatch(...args) {
    this.setState({});
    this.props.onError(...args);
  }
  render() {
    return this.props.children;
  }
}
const RedwoodApolloProvider = ({
  graphQLClientConfig,
  fragments,
  useAuth: useAuth2 = useNoAuth,
  logLevel = "debug",
  children
}) => {
  const { cacheConfig, ...config } = graphQLClientConfig ?? {};
  if (fragments) {
    fragmentRegistry.register(...fragments);
  }
  const cache2 = new InMemoryCache({
    fragments: fragmentRegistry,
    possibleTypes: cacheConfig == null ? void 0 : cacheConfig.possibleTypes,
    ...cacheConfig
  }).restore((globalThis == null ? void 0 : globalThis.__REDWOOD__APOLLO_STATE) ?? {});
  return /* @__PURE__ */ React$2.createElement(FetchConfigProvider, { useAuth: useAuth2 }, /* @__PURE__ */ React$2.createElement(
    ApolloProviderWithFetchConfig,
    {
      config: { cache: cache2, ...config },
      useAuth: useAuth2,
      logLevel
    },
    /* @__PURE__ */ React$2.createElement(
      GraphQLHooksProvider,
      {
        useQuery: useQuery_1,
        useMutation: useMutation_1,
        useSubscription: useSubscription_1,
        useBackgroundQuery: useBackgroundQuery_1,
        useReadQuery: useReadQuery_1,
        useSuspenseQuery: useSuspenseQuery_1
      },
      children
    )
  ));
};
const FatalErrorPage = () => /* @__PURE__ */ jsxRuntimeExports.jsxs("main", { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: {
    __html: `
              html, body {
                margin: 0;
              }
              html * {
                box-sizing: border-box;
              }
              main {
                display: flex;
                align-items: center;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
                text-align: center;
                background-color: #E2E8F0;
                height: 100vh;
              }
              section {
                background-color: white;
                border-radius: 0.25rem;
                width: 32rem;
                padding: 1rem;
                margin: 0 auto;
                box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
              }
              section > * + * {
                margin-top: 10px;
              }
              h1 {
                font-size: 2rem;
                margin: 0;
                font-weight: 500;
                line-height: 1;
                color: #2D3748;
              }
            `
  } }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Something went wrong" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "We've been notified and we'll look into it" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Please refresh the page" })
  ] })
] });
const FatalErrorPage$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: FatalErrorPage
}, Symbol.toStringTag, { value: "Module" }));
const scriptRel = "modulepreload";
const assetsURL = function(dep2) {
  return "/" + dep2;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = (cspNonceMeta == null ? void 0 : cspNonceMeta.nonce) || (cspNonceMeta == null ? void 0 : cspNonceMeta.getAttribute("nonce"));
    promise = Promise.allSettled(
      deps.map((dep2) => {
        dep2 = assetsURL(dep2);
        if (dep2 in seen) return;
        seen[dep2] = true;
        const isCss = dep2.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep2}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep2;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep2}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const createHistory = () => {
  const listeners = {};
  const blockers = [];
  let beforeUnloadListener = null;
  const history = {
    listen: (listener) => {
      const listenerId = "RW_HISTORY_LISTENER_ID_" + Date.now();
      listeners[listenerId] = listener;
      globalThis.addEventListener("popstate", listener);
      return listenerId;
    },
    navigate: (to2, options2 = {
      scroll: true
    }) => {
      const performNavigation = () => {
        var _a3, _b2, _c2, _d;
        const { pathname, search, hash } = new URL(
          ((_a3 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _a3.origin) + to2
        );
        if (((_b2 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _b2.pathname) !== pathname || ((_c2 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _c2.search) !== search || ((_d = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _d.hash) !== hash) {
          if (options2 == null ? void 0 : options2.replace) {
            globalThis.history.replaceState({}, "", to2);
          } else {
            globalThis.history.pushState({}, "", to2);
          }
        }
        for (const listener of Object.values(listeners)) {
          listener(void 0, options2);
        }
      };
      if (blockers.length > 0) {
        processBlockers(0, performNavigation);
      } else {
        performNavigation();
      }
    },
    back: () => {
      const performBack = () => {
        globalThis.history.back();
        for (const listener of Object.values(listeners)) {
          listener();
        }
      };
      if (blockers.length > 0) {
        processBlockers(0, performBack);
      } else {
        performBack();
      }
    },
    remove: (listenerId) => {
      if (listeners[listenerId]) {
        const listener = listeners[listenerId];
        globalThis.removeEventListener("popstate", listener);
        delete listeners[listenerId];
      } else {
        console.warn(
          "History Listener with ID: " + listenerId + " does not exist."
        );
      }
    },
    block: (id2, callback) => {
      const existingBlockerIndex = blockers.findIndex(
        (blocker) => blocker.id === id2
      );
      if (existingBlockerIndex !== -1) {
        blockers[existingBlockerIndex] = { id: id2, callback };
      } else {
        blockers.push({ id: id2, callback });
        if (blockers.length === 1) {
          addBeforeUnloadListener();
        }
      }
    },
    unblock: (id2) => {
      const index2 = blockers.findIndex((blocker) => blocker.id === id2);
      if (index2 !== -1) {
        blockers.splice(index2, 1);
        if (blockers.length === 0) {
          removeBeforeUnloadListener();
        }
      }
    }
  };
  const processBlockers = (index2, navigate2) => {
    if (index2 < blockers.length) {
      blockers[index2].callback({
        retry: () => processBlockers(index2 + 1, navigate2)
      });
    } else {
      navigate2();
    }
  };
  const addBeforeUnloadListener = () => {
    if (!beforeUnloadListener) {
      beforeUnloadListener = (event) => {
        if (blockers.length > 0) {
          event.preventDefault();
        }
      };
      globalThis.addEventListener("beforeunload", beforeUnloadListener);
    }
  };
  const removeBeforeUnloadListener = () => {
    if (beforeUnloadListener) {
      globalThis.removeEventListener("beforeunload", beforeUnloadListener);
      beforeUnloadListener = null;
    }
  };
  return history;
};
const gHistory = createHistory();
const { navigate } = gHistory;
const Link = reactExports.forwardRef(({ to: to2, onClick, options: options2, ...rest }, ref) => /* @__PURE__ */ React$2.createElement(
  "a",
  {
    href: to2,
    ref,
    ...rest,
    onClick: (event) => {
      if (event.button !== 0 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
        return;
      }
      event.preventDefault();
      if (onClick) {
        const result = onClick(event);
        if (typeof result !== "boolean" || result) {
          navigate(to2, options2);
        }
      } else {
        navigate(to2, options2);
      }
    }
  }
));
function createNamedContext(name, defaultValue2) {
  const Ctx2 = reactExports.createContext(defaultValue2);
  Ctx2.displayName = name;
  return Ctx2;
}
const LocationContext = createNamedContext("Location");
class LocationProvider extends React$2.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "HISTORY_LISTENER_ID");
    __publicField(this, "state", {
      context: this.getContext()
    });
  }
  getContext() {
    let windowLocation;
    if (typeof window !== "undefined") {
      const { pathname } = window.location;
      switch (this.props.trailingSlashes) {
        case "never":
          if (pathname.endsWith("/")) {
            window.history.replaceState(
              {},
              "",
              pathname.substr(0, pathname.length - 1)
            );
          }
          break;
        case "always":
          if (!pathname.endsWith("/")) {
            window.history.replaceState({}, "", pathname + "/");
          }
          break;
      }
      windowLocation = new URL(window.location.href);
    }
    return this.props.location || this.context || windowLocation;
  }
  // componentDidMount() is not called during server rendering (aka SSR and
  // prerendering)
  componentDidMount() {
    this.HISTORY_LISTENER_ID = gHistory.listen((_2, options2) => {
      const context2 = this.getContext();
      this.setState((lastState) => {
        var _a3, _b2;
        if (((context2 == null ? void 0 : context2.pathname) !== ((_a3 = lastState == null ? void 0 : lastState.context) == null ? void 0 : _a3.pathname) || (context2 == null ? void 0 : context2.search) !== ((_b2 = lastState == null ? void 0 : lastState.context) == null ? void 0 : _b2.search)) && (options2 == null ? void 0 : options2.scroll) === true) {
          globalThis == null ? void 0 : globalThis.scrollTo(0, 0);
        }
        return { context: context2 };
      });
    });
  }
  componentWillUnmount() {
    if (this.HISTORY_LISTENER_ID) {
      gHistory.remove(this.HISTORY_LISTENER_ID);
    }
  }
  render() {
    return /* @__PURE__ */ React$2.createElement(LocationContext.Provider, { value: this.state.context }, this.props.children);
  }
}
// When prerendering, there might be more than one level of location
// providers. Use the values from the one above.
// (this is basically the class component version of `useLocation()`)
__publicField(LocationProvider, "contextType", LocationContext);
const useLocation = () => {
  const location2 = React$2.useContext(LocationContext);
  if (location2 === void 0) {
    throw new Error("useLocation must be used within a LocationProvider");
  }
  return location2;
};
function paramsForRoute(route) {
  const params = [...route.matchAll(/\{([^}]+)\}/g)];
  return params.map((match) => match[1]).map((match) => {
    const parts = match.split(":");
    let name = parts[0];
    if (name.endsWith("...")) {
      name = name.slice(0, -3);
    }
    let type = parts[1];
    if (!type) {
      type = match.endsWith("...") ? "Glob" : "String";
    }
    return [name, type, `{${match}}`];
  });
}
const coreParamTypes = {
  String: {
    match: /[^/]+/
  },
  Int: {
    match: /\d+/,
    parse: Number
  },
  Float: {
    match: /[-+]?(?:\d*\.?\d+|\d+\.?\d*)(?:[eE][-+]?\d+)?/,
    parse: Number
  },
  Boolean: {
    match: /true|false/,
    parse: (boolAsString) => boolAsString === "true"
  },
  Glob: {
    match: /.*/
  }
};
function matchPath(routeDefinition, pathname, {
  userParamTypes,
  matchSubPaths
} = {
  userParamTypes: {},
  matchSubPaths: false
}) {
  const allParamTypes = { ...coreParamTypes, ...userParamTypes };
  const { matchRegex, routeParams: routeParamsDefinition } = getRouteRegexAndParams(routeDefinition, {
    matchSubPaths,
    allParamTypes
  });
  const matches = [...pathname.matchAll(matchRegex)];
  if (matches.length === 0) {
    return { match: false };
  }
  const providedParams = matches[0].slice(1);
  if (routeParamsDefinition.length > 0) {
    const params = providedParams.reduce(
      (acc, value, index2) => {
        const [name, transformName] = routeParamsDefinition[index2];
        const typeInfo = allParamTypes[transformName];
        let transformedValue = value;
        if (typeof (typeInfo == null ? void 0 : typeInfo.parse) === "function") {
          transformedValue = typeInfo.parse(value);
        }
        return {
          ...acc,
          [name]: transformedValue
        };
      },
      {}
    );
    return { match: true, params };
  }
  return { match: true };
}
function getRouteRegexAndParams(route, {
  matchSubPaths = false,
  allParamTypes = coreParamTypes
} = {}) {
  var _a3;
  let typeMatchingRoute = route;
  const routeParams = paramsForRoute(route);
  for (const [_name, type, match] of routeParams) {
    const matcher = (_a3 = allParamTypes[type]) == null ? void 0 : _a3.match;
    const typeRegexp = (matcher == null ? void 0 : matcher.source) || "[^/]+";
    typeMatchingRoute = typeMatchingRoute.replace(match, `(${typeRegexp})`);
  }
  const matchRegex = matchSubPaths ? new RegExp(`^${typeMatchingRoute}(?:/.*)?$`, "g") : new RegExp(`^${typeMatchingRoute}$`, "g");
  const matchRegexString = matchSubPaths ? `^${typeMatchingRoute}(?:/.*)?$` : `^${typeMatchingRoute}$`;
  return {
    matchRegex,
    routeParams,
    matchRegexString
  };
}
function parseSearch(search) {
  const searchParams = new URLSearchParams(search);
  return [...searchParams.keys()].reduce(
    (params, key) => ({
      ...params,
      [key]: searchParams.get(key)
    }),
    {}
  );
}
function validatePath(path, routeName) {
  if (!path.startsWith("/")) {
    throw new Error(
      `Route path for ${routeName} does not begin with a slash: "${path}"`
    );
  }
  if (path.includes(" ")) {
    throw new Error(`Route path for ${routeName} contains spaces: "${path}"`);
  }
  if (/{(?:ref|key)(?::|})/.test(path)) {
    throw new Error(
      [
        `Route for ${routeName} contains ref or key as a path parameter: "${path}"`,
        "`ref` and `key` shouldn't be used as path parameters because they're special React props.",
        "You can fix this by renaming the path parameter."
      ].join("\n")
    );
  }
  if (path.length > 2e3) {
    throw new Error(
      `Route path for ${routeName} is too long to process at ${path.length} characters, limit is 2000 characters.`
    );
  }
  const matches = path.matchAll(/\{([^}]+)\}/g);
  const memo = {};
  for (const match of matches) {
    const param = match[1].split(":")[0];
    if (memo[param]) {
      throw new Error(`Route path contains duplicate parameter: "${path}"`);
    } else {
      memo[param] = true;
    }
  }
}
function replaceParams(route, args = {}) {
  const params = paramsForRoute(route);
  let path = route;
  params.forEach((param) => {
    const [name, _type, match] = param;
    const value = args[name];
    if (value !== void 0) {
      path = path.replace(match, value);
    } else {
      throw new Error(
        `Missing parameter '${name}' for route '${route}' when generating a navigation URL.`
      );
    }
  });
  const paramNames = params.map((param) => param[0]);
  const extraArgKeys = Object.keys(args).filter((x2) => !paramNames.includes(x2)).filter((x2) => args[x2] !== void 0 && args[x2] !== null);
  if (extraArgKeys.length) {
    const extraArgs = Object.fromEntries(
      extraArgKeys.map((key) => [key, `${args[key]}`])
    );
    path += `?${new URLSearchParams(extraArgs).toString()}`;
  }
  return path;
}
function flattenSearchParams(queryString) {
  const searchParams = [];
  for (const [key, value] of Object.entries(parseSearch(queryString))) {
    searchParams.push({ [key]: value });
  }
  return searchParams;
}
function inIframe() {
  try {
    return (global == null ? void 0 : global.self) !== (global == null ? void 0 : global.top);
  } catch {
    return true;
  }
}
const useMatch = (routePath, options2) => {
  const location2 = useLocation();
  if (!location2) {
    return { match: false };
  }
  if (options2 == null ? void 0 : options2.searchParams) {
    const locationParams = new URLSearchParams(location2.search);
    const hasUnmatched = options2.searchParams.some((param) => {
      if (typeof param === "string") {
        return !locationParams.has(param);
      } else {
        return Object.keys(param).some(
          (key) => param[key] != locationParams.get(key)
        );
      }
    });
    if (hasUnmatched) {
      return { match: false };
    }
  }
  const matchInfo = matchPath(routePath, location2.pathname, {
    matchSubPaths: options2 == null ? void 0 : options2.matchSubPaths
  });
  if (!matchInfo.match) {
    return { match: false };
  }
  const routeParams = Object.entries((options2 == null ? void 0 : options2.routeParams) || {});
  if (routeParams.length > 0) {
    if (!isMatchWithParams(matchInfo) || !matchInfo.params) {
      return { match: false };
    }
    const isParamMatch = routeParams.every(([key, value]) => {
      return matchInfo.params[key] === value;
    });
    if (!isParamMatch) {
      return { match: false };
    }
  }
  return matchInfo;
};
function isMatchWithParams(match) {
  return match !== null && typeof match === "object" && "params" in match;
}
reactExports.forwardRef(
  ({
    to: to2,
    activeClassName,
    activeMatchParams,
    matchSubPaths,
    className,
    onClick,
    ...rest
  }, ref) => {
    const [pathname, queryString] = to2.split("?");
    const searchParams = activeMatchParams || flattenSearchParams(queryString);
    const matchInfo = useMatch(pathname, {
      searchParams,
      matchSubPaths
    });
    return /* @__PURE__ */ React$2.createElement(
      Link,
      {
        ref,
        to: to2,
        onClick,
        className: matchInfo.match ? activeClassName : className,
        ...rest
      }
    );
  }
);
const Redirect = ({ to: to2, options: options2 }) => {
  reactExports.useEffect(() => {
    navigate(to2, options2);
  }, [to2, options2]);
  return null;
};
const PageLoadingContext = createNamedContext("PageLoading");
const PageLoadingContextProvider = ({
  children,
  delay = 1e3
}) => {
  const [loading, setPageLoadingContext] = reactExports.useState(false);
  return /* @__PURE__ */ React$2.createElement(
    PageLoadingContext.Provider,
    {
      value: { loading, setPageLoadingContext, delay }
    },
    children
  );
};
const usePageLoadingContext = () => {
  const pageLoadingContext = reactExports.useContext(PageLoadingContext);
  if (!pageLoadingContext) {
    throw new Error(
      "usePageLoadingContext must be used within a PageLoadingContext provider"
    );
  }
  return pageLoadingContext;
};
const ParamsContext = createNamedContext("Params");
const ParamsProvider = ({ allParams, children }) => {
  return /* @__PURE__ */ React$2.createElement(
    ParamsContext.Provider,
    {
      value: {
        params: {
          ...allParams
        }
      }
    },
    children
  );
};
const useParams = () => {
  const paramsContext = reactExports.useContext(ParamsContext);
  if (paramsContext === void 0) {
    throw new Error("useParams must be used within a ParamsProvider");
  }
  return paramsContext.params;
};
const getAnnouncement = () => {
  var _a3;
  const routeAnnouncement = (_a3 = globalThis == null ? void 0 : globalThis.document.querySelectorAll(
    "[data-redwood-route-announcement]"
  )) == null ? void 0 : _a3[0];
  if (routeAnnouncement == null ? void 0 : routeAnnouncement.textContent) {
    return routeAnnouncement.textContent;
  }
  const pageHeading = globalThis == null ? void 0 : globalThis.document.querySelector(`h1`);
  if (pageHeading == null ? void 0 : pageHeading.textContent) {
    return pageHeading.textContent;
  }
  if (globalThis == null ? void 0 : globalThis.document.title) {
    return document.title;
  }
  return `new page at ${globalThis == null ? void 0 : globalThis.location.pathname}`;
};
const getFocus = () => {
  var _a3;
  const routeFocus = (_a3 = globalThis == null ? void 0 : globalThis.document.querySelectorAll(
    "[data-redwood-route-focus]"
  )) == null ? void 0 : _a3[0];
  if (!(routeFocus == null ? void 0 : routeFocus.children.length) || routeFocus.children[0].tabIndex < 0) {
    return null;
  }
  return routeFocus.children[0];
};
const resetFocus = () => {
  globalThis == null ? void 0 : globalThis.document.body.setAttribute("tabindex", "-1");
  globalThis == null ? void 0 : globalThis.document.body.focus();
  globalThis == null ? void 0 : globalThis.document.body.removeAttribute("tabindex");
};
let isPrerendered = false;
if (typeof window !== "undefined") {
  const redwoodAppElement2 = document.getElementById("redwood-app");
  if (redwoodAppElement2 && redwoodAppElement2.children.length > 0) {
    isPrerendered = true;
  }
}
let firstLoad = true;
const Fallback = ({ children }) => {
  const { loading, setPageLoadingContext, delay } = usePageLoadingContext();
  reactExports.useEffect(() => {
    const timer = setTimeout(() => {
      setPageLoadingContext(true);
    }, delay);
    return () => {
      clearTimeout(timer);
      setPageLoadingContext(false);
    };
  }, [delay, setPageLoadingContext]);
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null, loading ? children : null);
};
const ActiveRouteLoader = ({
  spec,
  params,
  whileLoadingPage
}) => {
  const announcementRef = reactExports.useRef(null);
  const usePrerenderLoader = (
    // Prerendering doesn't work with Streaming/SSR yet. So we disable it.
    !globalThis.RWJS_EXP_STREAMING_SSR && (globalThis.__REDWOOD__PRERENDERING || isPrerendered && firstLoad)
  );
  const LazyRouteComponent = usePrerenderLoader ? spec.prerenderLoader(spec.name).default : spec.LazyComponent;
  if (firstLoad) {
    firstLoad = false;
  }
  reactExports.useEffect(() => {
    if (inIframe()) {
      return;
    }
    if (announcementRef.current) {
      announcementRef.current.innerText = getAnnouncement();
    }
    const routeFocus = getFocus();
    if (!routeFocus) {
      resetFocus();
    } else {
      routeFocus.focus();
    }
  }, [spec, params]);
  if (params) {
    delete params["ref"];
    delete params["key"];
  }
  return /* @__PURE__ */ React$2.createElement(reactExports.Suspense, { fallback: /* @__PURE__ */ React$2.createElement(Fallback, null, whileLoadingPage == null ? void 0 : whileLoadingPage()) }, /* @__PURE__ */ React$2.createElement(LazyRouteComponent, { ...params }), /* @__PURE__ */ React$2.createElement(
    "div",
    {
      id: "redwood-announcer",
      style: {
        position: "absolute",
        top: 0,
        width: 1,
        height: 1,
        padding: 0,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        border: 0
      },
      role: "alert",
      "aria-live": "assertive",
      "aria-atomic": "true",
      ref: announcementRef
    }
  ));
};
function Route(_props) {
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null);
}
function isNodeTypeRoute(node) {
  return reactExports.isValidElement(node) && node.type === Route;
}
function isString(value) {
  return typeof value === "string";
}
function isStandardRoute(node) {
  return !node.props.notfound && !node.props.redirect;
}
function isRedirectRoute(node) {
  return !!node.props.redirect;
}
function isNotFoundRoute(node) {
  return !!node.props.notfound;
}
function isValidRoute(node) {
  const isValidRouteElement = isNodeTypeRoute(node);
  if (isValidRouteElement) {
    const notFoundOrRedirect = node.props.notfound || node.props.redirect;
    const requiredKeys = [
      !node.props.notfound && "path",
      // redirects don't need an actual page, but notfound and standard do
      !node.props.redirect && "page",
      // Redirects can have names, but aren't required to
      !notFoundOrRedirect && "name"
    ].filter(isString);
    const missingKeys = requiredKeys.filter((key) => !(key in node.props));
    if (missingKeys.length > 0) {
      const stringToHelpIdentify = node.props.name || node.props.path ? `for "${node.props.name || node.props.path}" ` : "";
      throw new Error(
        `Route element ${stringToHelpIdentify}is missing required props: ` + missingKeys.join(", ")
      );
    }
  }
  return isValidRouteElement;
}
function Set$1(props) {
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null, props.children);
}
function Private(props) {
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null, props.children);
}
function PrivateSet(props) {
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null, props.children);
}
const isSetNode = (node) => {
  return React$2.isValidElement(node) && (node.type === Set$1 || node.type === PrivateSet || node.type === Private) && // Don't even bother including Sets without children. They're useless.
  node.props.children;
};
const isPrivateSetNode = (node) => {
  return React$2.isValidElement(node) && node.type === PrivateSet;
};
const isPrivateNode = (node) => {
  return React$2.isValidElement(node) && node.type === Private;
};
function analyzeRoutes(children, { currentPathName, userParamTypes }) {
  const pathRouteMap = {};
  const namedRoutesMap = {};
  let hasRootRoute = false;
  let NotFoundPage2;
  let activeRoutePath;
  const recurseThroughRouter = ({
    nodes,
    whileLoadingPageFromSet,
    sets: previousSets = []
  }) => {
    let nextSetId = 0;
    nodes.forEach((node) => {
      if (isValidRoute(node)) {
        const route = node;
        if (isNotFoundRoute(route)) {
          NotFoundPage2 = route.props.page;
          return;
        }
        if (route.props.path === "/") {
          hasRootRoute = true;
        }
        if (isRedirectRoute(route)) {
          const { name, redirect, path } = route.props;
          validatePath(path, name || path);
          const { match } = matchPath(path, currentPathName, {
            userParamTypes
          });
          if (match && !activeRoutePath) {
            activeRoutePath = path;
          }
          pathRouteMap[path] = {
            redirect,
            name: name || null,
            path,
            page: null,
            // Redirects don't need pages. We set this to null for consistency
            sets: previousSets
          };
          if (name) {
            namedRoutesMap[name] = (args = {}) => replaceParams(path, args);
          }
        }
        if (isStandardRoute(route)) {
          const { name, path, page } = route.props;
          validatePath(path, name);
          const { match } = matchPath(path, currentPathName, {
            userParamTypes
          });
          if (match && !activeRoutePath) {
            activeRoutePath = path;
          }
          pathRouteMap[path] = {
            redirect: null,
            name,
            path,
            whileLoadingPage: route.props.whileLoadingPage || whileLoadingPageFromSet,
            page,
            sets: previousSets
          };
          namedRoutesMap[name] = (args = {}) => replaceParams(path, args);
        }
      }
      if (isSetNode(node)) {
        const {
          children: children2,
          whileLoadingPage: whileLoadingPageFromCurrentSet,
          wrap: wrapFromCurrentSet,
          ...otherPropsFromCurrentSet
        } = node.props;
        let wrapperComponentsArray = [];
        if (wrapFromCurrentSet) {
          wrapperComponentsArray = Array.isArray(wrapFromCurrentSet) ? wrapFromCurrentSet : [wrapFromCurrentSet];
        }
        nextSetId = nextSetId + 1;
        recurseThroughRouter({
          nodes: reactExports.Children.toArray(children2),
          // When there's a whileLoadingPage prop on a Set, we pass it down to all its children
          // If the parent node was also a Set with whileLoadingPage, we pass it down. The child's whileLoadingPage
          // will always take precedence over the parent's
          whileLoadingPageFromSet: whileLoadingPageFromCurrentSet || whileLoadingPageFromSet,
          sets: [
            ...previousSets,
            {
              id: createSetId(nextSetId, previousSets),
              wrappers: wrapperComponentsArray,
              isPrivate: isPrivateSetNode(node) || // The following two conditions can be removed when we remove
              // the deprecated private prop
              isPrivateNode(node) || !!otherPropsFromCurrentSet.private,
              props: otherPropsFromCurrentSet
            }
          ]
        });
      }
    });
  };
  recurseThroughRouter({ nodes: reactExports.Children.toArray(children) });
  return {
    pathRouteMap,
    namedRoutesMap,
    hasRootRoute,
    NotFoundPage: NotFoundPage2,
    activeRoutePath
  };
}
function createSetId(nextSetId, previousSets) {
  var _a3;
  const firstLevel = previousSets.length === 0;
  if (firstLevel) {
    return nextSetId.toString();
  }
  return ((_a3 = previousSets.at(-1)) == null ? void 0 : _a3.id) + "." + nextSetId;
}
const namedRoutes = {};
const RouterStateContext = reactExports.createContext(void 0);
const RouterContextProvider = ({
  useAuth: useAuth2,
  paramTypes,
  routes,
  activeRouteName,
  children
}) => {
  const state = reactExports.useMemo(
    () => ({
      useAuth: useAuth2 || useNoAuth,
      paramTypes,
      routes,
      activeRouteName
    }),
    [useAuth2, paramTypes, routes, activeRouteName]
  );
  return /* @__PURE__ */ React$2.createElement(RouterStateContext.Provider, { value: state }, children);
};
const useRouterState = () => {
  const context2 = reactExports.useContext(RouterStateContext);
  if (context2 === void 0) {
    throw new Error(
      "useRouterState must be used within a RouterContextProvider"
    );
  }
  return context2;
};
const AuthenticatedRoute = ({
  unauthenticated,
  roles,
  whileLoadingAuth,
  children
}) => {
  const routerState = useRouterState();
  const {
    loading: authLoading,
    isAuthenticated,
    hasRole
  } = routerState.useAuth();
  const unauthorized = reactExports.useCallback(() => {
    return !(isAuthenticated && (!roles || hasRole(roles)));
  }, [isAuthenticated, roles, hasRole]);
  if (unauthorized()) {
    if (authLoading) {
      return (whileLoadingAuth == null ? void 0 : whileLoadingAuth()) || null;
    } else {
      const currentLocation = globalThis.location.pathname + encodeURIComponent(globalThis.location.search);
      const generatedRoutesMap = namedRoutes;
      if (!generatedRoutesMap[unauthenticated]) {
        throw new Error(`We could not find a route named ${unauthenticated}`);
      }
      let unauthenticatedPath;
      try {
        unauthenticatedPath = generatedRoutesMap[unauthenticated]();
      } catch (e2) {
        if (e2 instanceof Error && /Missing parameter .* for route/.test(e2.message)) {
          throw new Error(
            `Redirecting to route "${unauthenticated}" would require route parameters, which currently is not supported. Please choose a different route`
          );
        }
        throw new Error(
          `Could not redirect to the route named ${unauthenticated}`
        );
      }
      return /* @__PURE__ */ React$2.createElement(Redirect, { to: `${unauthenticatedPath}?redirectTo=${currentLocation}` });
    }
  }
  return /* @__PURE__ */ React$2.createElement(React$2.Fragment, null, children);
};
function isSpec(specOrPage) {
  return specOrPage.LazyComponent !== void 0;
}
function normalizePage(specOrPage) {
  if (isSpec(specOrPage)) {
    return specOrPage;
  }
  return {
    name: specOrPage.name,
    prerenderLoader: () => ({ default: specOrPage }),
    LazyComponent: specOrPage
  };
}
const Router = ({
  useAuth: useAuth2,
  paramTypes,
  pageLoadingDelay,
  trailingSlashes = "never",
  children
}) => {
  return (
    // Level 1/3 (outer-most)
    // Wrap it in the provider so that useLocation can be used
    /* @__PURE__ */ React$2.createElement(LocationProvider, { trailingSlashes }, /* @__PURE__ */ React$2.createElement(
      LocationAwareRouter,
      {
        useAuth: useAuth2,
        paramTypes,
        pageLoadingDelay
      },
      children
    ))
  );
};
const LocationAwareRouter = ({
  useAuth: useAuth2,
  paramTypes,
  pageLoadingDelay,
  children
}) => {
  const location2 = useLocation();
  const analyzeRoutesResult = reactExports.useMemo(() => {
    return analyzeRoutes(children, {
      currentPathName: location2.pathname,
      // @TODO We haven't handled this with SSR/Streaming yet.
      // May need a babel plugin to extract userParamTypes from Routes.tsx
      userParamTypes: paramTypes
    });
  }, [location2.pathname, children, paramTypes]);
  const {
    pathRouteMap,
    hasRootRoute,
    namedRoutesMap,
    NotFoundPage: NotFoundPage2,
    activeRoutePath
  } = analyzeRoutesResult;
  !hasRootRoute && location2.pathname === "/";
  Object.assign(namedRoutes, namedRoutesMap);
  if (!activeRoutePath) {
    if (NotFoundPage2) {
      return /* @__PURE__ */ React$2.createElement(
        RouterContextProvider,
        {
          useAuth: useAuth2,
          paramTypes,
          routes: analyzeRoutesResult
        },
        /* @__PURE__ */ React$2.createElement(ParamsProvider, null, /* @__PURE__ */ React$2.createElement(PageLoadingContextProvider, { delay: pageLoadingDelay }, /* @__PURE__ */ React$2.createElement(
          ActiveRouteLoader,
          {
            spec: normalizePage(NotFoundPage2),
            path: location2.pathname
          }
        )))
      );
    }
    return null;
  }
  const { path, page, name, redirect, whileLoadingPage, sets } = pathRouteMap[activeRoutePath];
  if (!path) {
    throw new Error(`Route "${name}" needs to specify a path`);
  }
  validatePath(path, name || path);
  const { params: pathParams } = matchPath(path, location2.pathname, {
    userParamTypes: paramTypes
  });
  const searchParams = parseSearch(location2.search);
  const allParams = { ...searchParams, ...pathParams };
  let redirectPath = void 0;
  if (redirect) {
    if (redirect.startsWith("/")) {
      redirectPath = replaceParams(redirect, allParams);
    } else {
      const redirectRouteObject = Object.values(pathRouteMap).find(
        (route) => route.name === redirect
      );
      if (!redirectRouteObject) {
        throw new Error(
          `Redirect target route "${redirect}" does not exist for route "${name}"`
        );
      }
      redirectPath = replaceParams(redirectRouteObject.path, allParams);
    }
  }
  return /* @__PURE__ */ React$2.createElement(
    RouterContextProvider,
    {
      useAuth: useAuth2,
      paramTypes,
      routes: analyzeRoutesResult,
      activeRouteName: name
    },
    /* @__PURE__ */ React$2.createElement(ParamsProvider, { allParams }, /* @__PURE__ */ React$2.createElement(PageLoadingContextProvider, { delay: pageLoadingDelay }, redirectPath && /* @__PURE__ */ React$2.createElement(Redirect, { to: redirectPath }), !redirectPath && page && /* @__PURE__ */ React$2.createElement(WrappedPage, { sets }, /* @__PURE__ */ React$2.createElement(
      ActiveRouteLoader,
      {
        path,
        spec: normalizePage(page),
        params: allParams,
        whileLoadingPage
      }
    ))))
  );
};
const WrappedPage = reactExports.memo(({ sets, children }) => {
  if (!sets || sets.length === 0) {
    return children;
  }
  return sets.reduceRight((acc, set) => {
    let wrapped = set.wrappers.reduceRight((acc2, Wrapper, index2) => {
      return React$2.createElement(
        Wrapper,
        { ...set.props, key: set.id + "-" + index2 },
        acc2
      );
    }, acc);
    if (set.isPrivate) {
      const unauthenticated = set.props.unauthenticated;
      if (!unauthenticated || typeof unauthenticated !== "string") {
        throw new Error(
          "You must specify an `unauthenticated` route when using PrivateSet"
        );
      }
      wrapped = /* @__PURE__ */ React$2.createElement(AuthenticatedRoute, { ...set.props, unauthenticated }, wrapped);
    }
    return wrapped;
  }, children);
});
const defaultId = "reach-skip-nav";
const SkipNavLink = reactExports.forwardRef(function SkipNavLink2({ as: Comp = "a", children = "Skip to content", contentId, ...props }, forwardedRef) {
  const id2 = contentId || defaultId;
  return /* @__PURE__ */ reactExports.createElement(
    Comp,
    {
      ...props,
      ref: forwardedRef,
      href: `#${id2}`,
      "data-reach-skip-link": "",
      "data-reach-skip-nav-link": ""
    },
    children
  );
});
SkipNavLink.displayName = "SkipNavLink";
const SkipNavContent = reactExports.forwardRef(function SkipNavContent2({ as: Comp = "div", id: idProp, ...props }, forwardedRef) {
  const id2 = idProp || defaultId;
  return /* @__PURE__ */ reactExports.createElement(
    Comp,
    {
      ...props,
      ref: forwardedRef,
      id: id2,
      "data-reach-skip-nav-content": ""
    }
  );
});
SkipNavContent.displayName = "SkipNavContent";
const $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document !== "undefined" ? React$2.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(fn2) {
  const ref = reactExports.useRef(null);
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    ref.current = fn2;
  }, [
    fn2
  ]);
  return reactExports.useCallback((...args) => {
    const f3 = ref.current;
    return f3 === null || f3 === void 0 ? void 0 : f3(...args);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (el2) => {
  var _el_ownerDocument;
  return (_el_ownerDocument = el2 === null || el2 === void 0 ? void 0 : el2.ownerDocument) !== null && _el_ownerDocument !== void 0 ? _el_ownerDocument : document;
};
const $431fbd86ca7dc216$export$f21a1ffae260145a = (el2) => {
  if (el2 && "window" in el2 && el2.window === el2) return el2;
  const doc = $431fbd86ca7dc216$export$b204af158042fbac(el2);
  return doc.defaultView || window;
};
function $431fbd86ca7dc216$var$isNode(value) {
  return value !== null && typeof value === "object" && "nodeType" in value && typeof value.nodeType === "number";
}
function $431fbd86ca7dc216$export$af51f0f06c0f328a(node) {
  return $431fbd86ca7dc216$var$isNode(node) && node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in node;
}
let $f4e2df6bd15f8569$var$_shadowDOM = false;
function $f4e2df6bd15f8569$export$98658e8c59125e6a() {
  return $f4e2df6bd15f8569$var$_shadowDOM;
}
function $d4ee10de306f2510$export$4282f70798064fe0(node, otherNode) {
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return otherNode && node ? node.contains(otherNode) : false;
  if (!node || !otherNode) return false;
  let currentNode = otherNode;
  while (currentNode !== null) {
    if (currentNode === node) return true;
    if (currentNode.tagName === "SLOT" && currentNode.assignedSlot)
      currentNode = currentNode.assignedSlot.parentNode;
    else if ($431fbd86ca7dc216$export$af51f0f06c0f328a(currentNode))
      currentNode = currentNode.host;
    else currentNode = currentNode.parentNode;
  }
  return false;
}
const $d4ee10de306f2510$export$cd4e5573fbe2b576 = (doc = document) => {
  var _activeElement_shadowRoot;
  if (!$f4e2df6bd15f8569$export$98658e8c59125e6a()) return doc.activeElement;
  let activeElement = doc.activeElement;
  while (activeElement && "shadowRoot" in activeElement && ((_activeElement_shadowRoot = activeElement.shadowRoot) === null || _activeElement_shadowRoot === void 0 ? void 0 : _activeElement_shadowRoot.activeElement)) activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
};
function $d4ee10de306f2510$export$e58f029f0fbfdb29(event) {
  if ($f4e2df6bd15f8569$export$98658e8c59125e6a() && event.target.shadowRoot) {
    if (event.composedPath) return event.composedPath()[0];
  }
  return event.target;
}
function $c87311424ea30a05$var$testUserAgent(re2) {
  var _window_navigator_userAgentData;
  if (typeof window === "undefined" || window.navigator == null) return false;
  return ((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.brands.some((brand) => re2.test(brand.brand))) || re2.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(re2) {
  var _window_navigator_userAgentData;
  return typeof window !== "undefined" && window.navigator != null ? re2.test(((_window_navigator_userAgentData = window.navigator["userAgentData"]) === null || _window_navigator_userAgentData === void 0 ? void 0 : _window_navigator_userAgentData.platform) || window.navigator.platform) : false;
}
function $c87311424ea30a05$var$cached(fn2) {
  let res = null;
  return () => {
    if (res == null) res = fn2();
    return res;
  };
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
});
const $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $03deb23ff14920c4$export$4eaf04e54aa8eed6() {
  let globalListeners = reactExports.useRef(/* @__PURE__ */ new Map());
  let addGlobalListener = reactExports.useCallback((eventTarget, type, listener, options2) => {
    let fn2 = (options2 === null || options2 === void 0 ? void 0 : options2.once) ? (...args) => {
      globalListeners.current.delete(listener);
      listener(...args);
    } : listener;
    globalListeners.current.set(listener, {
      type,
      eventTarget,
      fn: fn2,
      options: options2
    });
    eventTarget.addEventListener(type, fn2, options2);
  }, []);
  let removeGlobalListener = reactExports.useCallback((eventTarget, type, listener, options2) => {
    var _globalListeners_current_get;
    let fn2 = ((_globalListeners_current_get = globalListeners.current.get(listener)) === null || _globalListeners_current_get === void 0 ? void 0 : _globalListeners_current_get.fn) || listener;
    eventTarget.removeEventListener(type, fn2, options2);
    globalListeners.current.delete(listener);
  }, []);
  let removeAllGlobalListeners = reactExports.useCallback(() => {
    globalListeners.current.forEach((value, key) => {
      removeGlobalListener(value.eventTarget, value.type, key, value.options);
    });
  }, [
    removeGlobalListener
  ]);
  reactExports.useEffect(() => {
    return removeAllGlobalListeners;
  }, [
    removeAllGlobalListeners
  ]);
  return {
    addGlobalListener,
    removeGlobalListener,
    removeAllGlobalListeners
  };
}
function $6a7db85432448f7f$export$60278871457622de(event) {
  if (event.mozInputSource === 0 && event.isTrusted) return true;
  if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === "click" && event.buttons === 1;
  return event.detail === 0 && !event.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = true;
    this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation();
    this.isPropagationStopped = () => true;
  }
  isPropagationStopped() {
    return false;
  }
  persist() {
  }
  constructor(type, nativeEvent) {
    this.nativeEvent = nativeEvent;
    this.target = nativeEvent.target;
    this.currentTarget = nativeEvent.currentTarget;
    this.relatedTarget = nativeEvent.relatedTarget;
    this.bubbles = nativeEvent.bubbles;
    this.cancelable = nativeEvent.cancelable;
    this.defaultPrevented = nativeEvent.defaultPrevented;
    this.eventPhase = nativeEvent.eventPhase;
    this.isTrusted = nativeEvent.isTrusted;
    this.timeStamp = nativeEvent.timeStamp;
    this.type = type;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {
  let stateRef = reactExports.useRef({
    isFocused: false,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const state = stateRef.current;
    return () => {
      if (state.observer) {
        state.observer.disconnect();
        state.observer = null;
      }
    };
  }, []);
  let dispatchBlur = $8ae05eaa5c114e9c$export$7f54fc3180508a52((e2) => {
    onBlur === null || onBlur === void 0 ? void 0 : onBlur(e2);
  });
  return reactExports.useCallback((e2) => {
    if (e2.target instanceof HTMLButtonElement || e2.target instanceof HTMLInputElement || e2.target instanceof HTMLTextAreaElement || e2.target instanceof HTMLSelectElement) {
      stateRef.current.isFocused = true;
      let target = e2.target;
      let onBlurHandler = (e3) => {
        stateRef.current.isFocused = false;
        if (target.disabled)
          dispatchBlur(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", e3));
        if (stateRef.current.observer) {
          stateRef.current.observer.disconnect();
          stateRef.current.observer = null;
        }
      };
      target.addEventListener("focusout", onBlurHandler, {
        once: true
      });
      stateRef.current.observer = new MutationObserver(() => {
        if (stateRef.current.isFocused && target.disabled) {
          var _stateRef_current_observer;
          (_stateRef_current_observer = stateRef.current.observer) === null || _stateRef_current_observer === void 0 ? void 0 : _stateRef_current_observer.disconnect();
          let relatedTargetEl = target === document.activeElement ? null : document.activeElement;
          target.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: relatedTargetEl
          }));
          target.dispatchEvent(new FocusEvent("focusout", {
            bubbles: true,
            relatedTarget: relatedTargetEl
          }));
        }
      });
      stateRef.current.observer.observe(target, {
        attributes: true,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    dispatchBlur
  ]);
}
let $8a9cb279dc87e130$export$fda7da73ab5d4c48 = false;
let $507fabe10e71c6fb$var$currentModality = null;
let $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set();
let $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map();
let $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
let $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: true,
  Escape: true
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e2) {
  for (let handler of $507fabe10e71c6fb$var$changeHandlers) handler(modality, e2);
}
function $507fabe10e71c6fb$var$isValidKey(e2) {
  return !(e2.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && e2.altKey || e2.ctrlKey || e2.key === "Control" || e2.key === "Shift" || e2.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(e2) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
  if ($507fabe10e71c6fb$var$isValidKey(e2)) {
    $507fabe10e71c6fb$var$currentModality = "keyboard";
    $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", e2);
  }
}
function $507fabe10e71c6fb$var$handlePointerEvent(e2) {
  $507fabe10e71c6fb$var$currentModality = "pointer";
  if (e2.type === "mousedown" || e2.type === "pointerdown") {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", e2);
  }
}
function $507fabe10e71c6fb$var$handleClickEvent(e2) {
  if ($6a7db85432448f7f$export$60278871457622de(e2)) {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    $507fabe10e71c6fb$var$currentModality = "virtual";
  }
}
function $507fabe10e71c6fb$var$handleFocusEvent(e2) {
  if (e2.target === window || e2.target === document || $8a9cb279dc87e130$export$fda7da73ab5d4c48 || !e2.isTrusted) return;
  if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {
    $507fabe10e71c6fb$var$currentModality = "virtual";
    $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", e2);
  }
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = false;
  $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(element) {
  if (typeof window === "undefined" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(element))) return;
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let focus = windowObject.HTMLElement.prototype.focus;
  windowObject.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;
    focus.apply(this, arguments);
  };
  documentObject.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  windowObject.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element);
  }, {
    once: true
  });
  $507fabe10e71c6fb$export$d90243b58daecda7.set(windowObject, {
    focus
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (element, loadListener) => {
  const windowObject = $431fbd86ca7dc216$export$f21a1ffae260145a(element);
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  if (loadListener) documentObject.removeEventListener("DOMContentLoaded", loadListener);
  if (!$507fabe10e71c6fb$export$d90243b58daecda7.has(windowObject)) return;
  windowObject.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(windowObject).focus;
  documentObject.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, true);
  documentObject.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, true);
  windowObject.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, true);
  windowObject.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, false);
  if (typeof PointerEvent !== "undefined") {
    documentObject.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  } else {
    documentObject.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, true);
    documentObject.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, true);
  }
  $507fabe10e71c6fb$export$d90243b58daecda7.delete(windowObject);
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(element) {
  const documentObject = $431fbd86ca7dc216$export$b204af158042fbac(element);
  let loadListener;
  if (documentObject.readyState !== "loading") $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
  else {
    loadListener = () => {
      $507fabe10e71c6fb$var$setupGlobalFocusEvents(element);
    };
    documentObject.addEventListener("DOMContentLoaded", loadListener);
  }
  return () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(element, loadListener);
}
if (typeof document !== "undefined") $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e2) {
  let document1 = $431fbd86ca7dc216$export$b204af158042fbac(e2 === null || e2 === void 0 ? void 0 : e2.target);
  const IHTMLInputElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLInputElement : HTMLInputElement;
  const IHTMLTextAreaElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLTextAreaElement : HTMLTextAreaElement;
  const IHTMLElement = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).HTMLElement : HTMLElement;
  const IKeyboardEvent = typeof window !== "undefined" ? $431fbd86ca7dc216$export$f21a1ffae260145a(e2 === null || e2 === void 0 ? void 0 : e2.target).KeyboardEvent : KeyboardEvent;
  isTextInput = isTextInput || document1.activeElement instanceof IHTMLInputElement && !$507fabe10e71c6fb$var$nonTextInputTypes.has(document1.activeElement.type) || document1.activeElement instanceof IHTMLTextAreaElement || document1.activeElement instanceof IHTMLElement && document1.activeElement.isContentEditable;
  return !(isTextInput && modality === "keyboard" && e2 instanceof IKeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e2.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn2, deps, opts) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents();
  reactExports.useEffect(() => {
    let handler = (modality, e2) => {
      if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(opts === null || opts === void 0 ? void 0 : opts.isTextInput), modality, e2)) return;
      fn2($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    $507fabe10e71c6fb$var$changeHandlers.add(handler);
    return () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(handler);
    };
  }, deps);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {
  let { isDisabled, onFocus: onFocusProp, onBlur: onBlurProp, onFocusChange } = props;
  const onBlur = reactExports.useCallback((e2) => {
    if (e2.target === e2.currentTarget) {
      if (onBlurProp) onBlurProp(e2);
      if (onFocusChange) onFocusChange(false);
      return true;
    }
  }, [
    onBlurProp,
    onFocusChange
  ]);
  const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  const onFocus = reactExports.useCallback((e2) => {
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = ownerDocument ? $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument) : $d4ee10de306f2510$export$cd4e5573fbe2b576();
    if (e2.target === e2.currentTarget && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusProp) onFocusProp(e2);
      if (onFocusChange) onFocusChange(true);
      onSyntheticFocus(e2);
    }
  }, [
    onFocusChange,
    onFocusProp,
    onSyntheticFocus
  ]);
  return {
    focusProps: {
      onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : void 0,
      onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : void 0
    }
  };
}
function $9ab94262bd0047c7$export$420e68273165f4ec(props) {
  let { isDisabled, onBlurWithin, onFocusWithin, onFocusWithinChange } = props;
  let state = reactExports.useRef({
    isFocusWithin: false
  });
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let onBlur = reactExports.useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    if (state.current.isFocusWithin && !e2.currentTarget.contains(e2.relatedTarget)) {
      state.current.isFocusWithin = false;
      removeAllGlobalListeners();
      if (onBlurWithin) onBlurWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(false);
    }
  }, [
    onBlurWithin,
    onFocusWithinChange,
    state,
    removeAllGlobalListeners
  ]);
  let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);
  let onFocus = reactExports.useCallback((e2) => {
    if (!e2.currentTarget.contains(e2.target)) return;
    const ownerDocument = $431fbd86ca7dc216$export$b204af158042fbac(e2.target);
    const activeElement = $d4ee10de306f2510$export$cd4e5573fbe2b576(ownerDocument);
    if (!state.current.isFocusWithin && activeElement === $d4ee10de306f2510$export$e58f029f0fbfdb29(e2.nativeEvent)) {
      if (onFocusWithin) onFocusWithin(e2);
      if (onFocusWithinChange) onFocusWithinChange(true);
      state.current.isFocusWithin = true;
      onSyntheticFocus(e2);
      let currentTarget = e2.currentTarget;
      addGlobalListener(ownerDocument, "focus", (e3) => {
        if (state.current.isFocusWithin && !$d4ee10de306f2510$export$4282f70798064fe0(currentTarget, e3.target)) {
          let event = new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", new ownerDocument.defaultView.FocusEvent("blur", {
            relatedTarget: e3.target
          }));
          event.target = currentTarget;
          event.currentTarget = currentTarget;
          onBlur(event);
        }
      }, {
        capture: true
      });
    }
  }, [
    onFocusWithin,
    onFocusWithinChange,
    onSyntheticFocus,
    addGlobalListener,
    onBlur
  ]);
  if (isDisabled) return {
    focusWithinProps: {
      // These cannot be null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  };
  return {
    focusWithinProps: {
      onFocus,
      onBlur
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
let $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;
  setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(e2) {
  if (e2.pointerType === "touch") $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (typeof document === "undefined") return;
  if (typeof PointerEvent !== "undefined") document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
  else document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  $6179b936705e76d3$var$hoverCount++;
  return () => {
    $6179b936705e76d3$var$hoverCount--;
    if ($6179b936705e76d3$var$hoverCount > 0) return;
    if (typeof PointerEvent !== "undefined") document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent);
    else document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);
  };
}
function $6179b936705e76d3$export$ae780daf29e6d456(props) {
  let { onHoverStart, onHoverChange, onHoverEnd, isDisabled } = props;
  let [isHovered, setHovered] = reactExports.useState(false);
  let state = reactExports.useRef({
    isHovered: false,
    ignoreEmulatedMouseEvents: false,
    pointerType: "",
    target: null
  }).current;
  reactExports.useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { addGlobalListener, removeAllGlobalListeners } = $03deb23ff14920c4$export$4eaf04e54aa8eed6();
  let { hoverProps, triggerHoverEnd } = reactExports.useMemo(() => {
    let triggerHoverStart = (event, pointerType) => {
      state.pointerType = pointerType;
      if (isDisabled || pointerType === "touch" || state.isHovered || !event.currentTarget.contains(event.target)) return;
      state.isHovered = true;
      let target = event.currentTarget;
      state.target = target;
      addGlobalListener($431fbd86ca7dc216$export$b204af158042fbac(event.target), "pointerover", (e2) => {
        if (state.isHovered && state.target && !$d4ee10de306f2510$export$4282f70798064fe0(state.target, e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      }, {
        capture: true
      });
      if (onHoverStart) onHoverStart({
        type: "hoverstart",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(true);
      setHovered(true);
    };
    let triggerHoverEnd2 = (event, pointerType) => {
      let target = state.target;
      state.pointerType = "";
      state.target = null;
      if (pointerType === "touch" || !state.isHovered || !target) return;
      state.isHovered = false;
      removeAllGlobalListeners();
      if (onHoverEnd) onHoverEnd({
        type: "hoverend",
        target,
        pointerType
      });
      if (onHoverChange) onHoverChange(false);
      setHovered(false);
    };
    let hoverProps2 = {};
    if (typeof PointerEvent !== "undefined") {
      hoverProps2.onPointerEnter = (e2) => {
        if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e2.pointerType === "mouse") return;
        triggerHoverStart(e2, e2.pointerType);
      };
      hoverProps2.onPointerLeave = (e2) => {
        if (!isDisabled && e2.currentTarget.contains(e2.target)) triggerHoverEnd2(e2, e2.pointerType);
      };
    } else {
      hoverProps2.onTouchStart = () => {
        state.ignoreEmulatedMouseEvents = true;
      };
      hoverProps2.onMouseEnter = (e2) => {
        if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e2, "mouse");
        state.ignoreEmulatedMouseEvents = false;
      };
      hoverProps2.onMouseLeave = (e2) => {
        if (!isDisabled && e2.currentTarget.contains(e2.target)) triggerHoverEnd2(e2, "mouse");
      };
    }
    return {
      hoverProps: hoverProps2,
      triggerHoverEnd: triggerHoverEnd2
    };
  }, [
    onHoverStart,
    onHoverChange,
    onHoverEnd,
    isDisabled,
    state,
    addGlobalListener,
    removeAllGlobalListeners
  ]);
  reactExports.useEffect(() => {
    if (isDisabled) triggerHoverEnd({
      currentTarget: state.target
    }, state.pointerType);
  }, [
    isDisabled
  ]);
  return {
    hoverProps,
    isHovered
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(props = {}) {
  let { autoFocus = false, isTextInput, within } = props;
  let state = reactExports.useRef({
    isFocused: false,
    isFocusVisible: autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  });
  let [isFocused, setFocused] = reactExports.useState(false);
  let [isFocusVisibleState, setFocusVisible] = reactExports.useState(() => state.current.isFocused && state.current.isFocusVisible);
  let updateState = reactExports.useCallback(() => setFocusVisible(state.current.isFocused && state.current.isFocusVisible), []);
  let onFocusChange = reactExports.useCallback((isFocused2) => {
    state.current.isFocused = isFocused2;
    setFocused(isFocused2);
    updateState();
  }, [
    updateState
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((isFocusVisible) => {
    state.current.isFocusVisible = isFocusVisible;
    updateState();
  }, [], {
    isTextInput
  });
  let { focusProps } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: within,
    onFocusChange
  });
  let { focusWithinProps } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !within,
    onFocusWithinChange: onFocusChange
  });
  return {
    isFocused,
    isFocusVisible: isFocusVisibleState,
    focusProps: within ? focusWithinProps : focusProps
  };
}
var i$6 = Object.defineProperty;
var d$5 = (t2, e2, n2) => e2 in t2 ? i$6(t2, e2, { enumerable: true, configurable: true, writable: true, value: n2 }) : t2[e2] = n2;
var r$3 = (t2, e2, n2) => (d$5(t2, typeof e2 != "symbol" ? e2 + "" : e2, n2), n2);
let o$6 = class o {
  constructor() {
    r$3(this, "current", this.detect());
    r$3(this, "handoffState", "pending");
    r$3(this, "currentId", 0);
  }
  set(e2) {
    this.current !== e2 && (this.handoffState = "pending", this.currentId = 0, this.current = e2);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
let s$7 = new o$6();
function u$7(r2) {
  return s$7.isServer ? null : r2 instanceof Node ? r2.ownerDocument : r2 != null && r2.hasOwnProperty("current") && r2.current instanceof Node ? r2.current.ownerDocument : document;
}
function t$4(e2) {
  typeof queueMicrotask == "function" ? queueMicrotask(e2) : Promise.resolve().then(e2).catch((o3) => setTimeout(() => {
    throw o3;
  }));
}
function o$5() {
  let n2 = [], r2 = { addEventListener(e2, t2, s2, a3) {
    return e2.addEventListener(t2, s2, a3), r2.add(() => e2.removeEventListener(t2, s2, a3));
  }, requestAnimationFrame(...e2) {
    let t2 = requestAnimationFrame(...e2);
    return r2.add(() => cancelAnimationFrame(t2));
  }, nextFrame(...e2) {
    return r2.requestAnimationFrame(() => r2.requestAnimationFrame(...e2));
  }, setTimeout(...e2) {
    let t2 = setTimeout(...e2);
    return r2.add(() => clearTimeout(t2));
  }, microTask(...e2) {
    let t2 = { current: true };
    return t$4(() => {
      t2.current && e2[0]();
    }), r2.add(() => {
      t2.current = false;
    });
  }, style(e2, t2, s2) {
    let a3 = e2.style.getPropertyValue(t2);
    return Object.assign(e2.style, { [t2]: s2 }), this.add(() => {
      Object.assign(e2.style, { [t2]: a3 });
    });
  }, group(e2) {
    let t2 = o$5();
    return e2(t2), this.add(() => t2.dispose());
  }, add(e2) {
    return n2.includes(e2) || n2.push(e2), () => {
      let t2 = n2.indexOf(e2);
      if (t2 >= 0) for (let s2 of n2.splice(t2, 1)) s2();
    };
  }, dispose() {
    for (let e2 of n2.splice(0)) e2();
  } };
  return r2;
}
function p$4() {
  let [e2] = reactExports.useState(o$5);
  return reactExports.useEffect(() => () => e2.dispose(), [e2]), e2;
}
let n$6 = (e2, t2) => {
  s$7.isServer ? reactExports.useEffect(e2, t2) : reactExports.useLayoutEffect(e2, t2);
};
function s$6(e2) {
  let r2 = reactExports.useRef(e2);
  return n$6(() => {
    r2.current = e2;
  }, [e2]), r2;
}
let o$4 = function(t2) {
  let e2 = s$6(t2);
  return React$2.useCallback((...r2) => e2.current(...r2), [e2]);
};
function E$3(e2) {
  let t2 = e2.width / 2, n2 = e2.height / 2;
  return { top: e2.clientY - n2, right: e2.clientX + t2, bottom: e2.clientY + n2, left: e2.clientX - t2 };
}
function P$4(e2, t2) {
  return !(!e2 || !t2 || e2.right < t2.left || e2.left > t2.right || e2.bottom < t2.top || e2.top > t2.bottom);
}
function w$4({ disabled: e2 = false } = {}) {
  let t2 = reactExports.useRef(null), [n2, l3] = reactExports.useState(false), r2 = p$4(), o3 = o$4(() => {
    t2.current = null, l3(false), r2.dispose();
  }), f3 = o$4((s2) => {
    if (r2.dispose(), t2.current === null) {
      t2.current = s2.currentTarget, l3(true);
      {
        let i2 = u$7(s2.currentTarget);
        r2.addEventListener(i2, "pointerup", o3, false), r2.addEventListener(i2, "pointermove", (c2) => {
          if (t2.current) {
            let p3 = E$3(c2);
            l3(P$4(p3, t2.current.getBoundingClientRect()));
          }
        }, false), r2.addEventListener(i2, "pointercancel", o3, false);
      }
    }
  });
  return { pressed: n2, pressProps: e2 ? {} : { onPointerDown: f3, onPointerUp: o3, onClick: o3 } };
}
function t$3(...r2) {
  return Array.from(new Set(r2.flatMap((n2) => typeof n2 == "string" ? n2.split(" ") : []))).filter(Boolean).join(" ");
}
function u$6(r2, n2, ...a3) {
  if (r2 in n2) {
    let e2 = n2[r2];
    return typeof e2 == "function" ? e2(...a3) : e2;
  }
  let t2 = new Error(`Tried to handle "${r2}" but there is no handler defined. Only defined handlers are: ${Object.keys(n2).map((e2) => `"${e2}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t2, u$6), t2;
}
var O$4 = ((a3) => (a3[a3.None = 0] = "None", a3[a3.RenderStrategy = 1] = "RenderStrategy", a3[a3.Static = 2] = "Static", a3))(O$4 || {}), A$3 = ((e2) => (e2[e2.Unmount = 0] = "Unmount", e2[e2.Hidden = 1] = "Hidden", e2))(A$3 || {});
function L$2() {
  let n2 = U$3();
  return reactExports.useCallback((r2) => C$3({ mergeRefs: n2, ...r2 }), [n2]);
}
function C$3({ ourProps: n2, theirProps: r2, slot: e2, defaultTag: a3, features: s2, visible: t2 = true, name: l3, mergeRefs: i2 }) {
  i2 = i2 != null ? i2 : $$2;
  let o3 = P$3(r2, n2);
  if (t2) return F$3(o3, e2, a3, l3, i2);
  let y2 = s2 != null ? s2 : 0;
  if (y2 & 2) {
    let { static: f3 = false, ...u3 } = o3;
    if (f3) return F$3(u3, e2, a3, l3, i2);
  }
  if (y2 & 1) {
    let { unmount: f3 = true, ...u3 } = o3;
    return u$6(f3 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return F$3({ ...u3, hidden: true, style: { display: "none" } }, e2, a3, l3, i2);
    } });
  }
  return F$3(o3, e2, a3, l3, i2);
}
function F$3(n2, r2 = {}, e2, a3, s2) {
  let { as: t2 = e2, children: l3, refName: i2 = "ref", ...o3 } = h$4(n2, ["unmount", "static"]), y2 = n2.ref !== void 0 ? { [i2]: n2.ref } : {}, f3 = typeof l3 == "function" ? l3(r2) : l3;
  "className" in o3 && o3.className && typeof o3.className == "function" && (o3.className = o3.className(r2)), o3["aria-labelledby"] && o3["aria-labelledby"] === o3.id && (o3["aria-labelledby"] = void 0);
  let u3 = {};
  if (r2) {
    let d3 = false, p3 = [];
    for (let [c2, T2] of Object.entries(r2)) typeof T2 == "boolean" && (d3 = true), T2 === true && p3.push(c2.replace(/([A-Z])/g, (g2) => `-${g2.toLowerCase()}`));
    if (d3) {
      u3["data-headlessui-state"] = p3.join(" ");
      for (let c2 of p3) u3[`data-${c2}`] = "";
    }
  }
  if (t2 === reactExports.Fragment && (Object.keys(m$4(o3)).length > 0 || Object.keys(m$4(u3)).length > 0)) if (!reactExports.isValidElement(f3) || Array.isArray(f3) && f3.length > 1) {
    if (Object.keys(m$4(o3)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${a3} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(o3)).concat(Object.keys(m$4(u3))).map((d3) => `  - ${d3}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d3) => `  - ${d3}`).join(`
`)].join(`
`));
  } else {
    let d3 = f3.props, p3 = d3 == null ? void 0 : d3.className, c2 = typeof p3 == "function" ? (...R2) => t$3(p3(...R2), o3.className) : t$3(p3, o3.className), T2 = c2 ? { className: c2 } : {}, g2 = P$3(f3.props, m$4(h$4(o3, ["ref"])));
    for (let R2 in u3) R2 in g2 && delete u3[R2];
    return reactExports.cloneElement(f3, Object.assign({}, g2, u3, y2, { ref: s2(H$3(f3), y2.ref) }, T2));
  }
  return reactExports.createElement(t2, Object.assign({}, h$4(o3, ["ref"]), t2 !== reactExports.Fragment && y2, t2 !== reactExports.Fragment && u3), f3);
}
function U$3() {
  let n2 = reactExports.useRef([]), r2 = reactExports.useCallback((e2) => {
    for (let a3 of n2.current) a3 != null && (typeof a3 == "function" ? a3(e2) : a3.current = e2);
  }, []);
  return (...e2) => {
    if (!e2.every((a3) => a3 == null)) return n2.current = e2, r2;
  };
}
function $$2(...n2) {
  return n2.every((r2) => r2 == null) ? void 0 : (r2) => {
    for (let e2 of n2) e2 != null && (typeof e2 == "function" ? e2(r2) : e2.current = r2);
  };
}
function P$3(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  if (r2.disabled || r2["aria-disabled"]) for (let s2 in e2) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(s2) && (e2[s2] = [(t2) => {
    var l3;
    return (l3 = t2 == null ? void 0 : t2.preventDefault) == null ? void 0 : l3.call(t2);
  }]);
  for (let s2 in e2) Object.assign(r2, { [s2](t2, ...l3) {
    let i2 = e2[s2];
    for (let o3 of i2) {
      if ((t2 instanceof Event || (t2 == null ? void 0 : t2.nativeEvent) instanceof Event) && t2.defaultPrevented) return;
      o3(t2, ...l3);
    }
  } });
  return r2;
}
function _$3(...n2) {
  if (n2.length === 0) return {};
  if (n2.length === 1) return n2[0];
  let r2 = {}, e2 = {};
  for (let s2 of n2) for (let t2 in s2) t2.startsWith("on") && typeof s2[t2] == "function" ? (e2[t2] != null || (e2[t2] = []), e2[t2].push(s2[t2])) : r2[t2] = s2[t2];
  for (let s2 in e2) Object.assign(r2, { [s2](...t2) {
    let l3 = e2[s2];
    for (let i2 of l3) i2 == null || i2(...t2);
  } });
  return r2;
}
function K$1(n2) {
  var r2;
  return Object.assign(reactExports.forwardRef(n2), { displayName: (r2 = n2.displayName) != null ? r2 : n2.name });
}
function m$4(n2) {
  let r2 = Object.assign({}, n2);
  for (let e2 in r2) r2[e2] === void 0 && delete r2[e2];
  return r2;
}
function h$4(n2, r2 = []) {
  let e2 = Object.assign({}, n2);
  for (let a3 of r2) a3 in e2 && delete e2[a3];
  return e2;
}
function H$3(n2) {
  return React$2.version.split(".")[0] >= "19" ? n2.props.ref : n2.ref;
}
let a$9 = "span";
var s$5 = ((e2) => (e2[e2.None = 1] = "None", e2[e2.Focusable = 2] = "Focusable", e2[e2.Hidden = 4] = "Hidden", e2))(s$5 || {});
function l$4(t2, r2) {
  var n2;
  let { features: d3 = 1, ...e2 } = t2, o3 = { ref: r2, "aria-hidden": (d3 & 2) === 2 ? true : (n2 = e2["aria-hidden"]) != null ? n2 : void 0, hidden: (d3 & 4) === 4 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(d3 & 4) === 4 && (d3 & 2) !== 2 && { display: "none" } } };
  return L$2()({ ourProps: o3, theirProps: e2, slot: {}, defaultTag: a$9, name: "Hidden" });
}
let f$6 = K$1(l$4);
function r$2(n2) {
  let e2 = n2.parentElement, l3 = null;
  for (; e2 && !(e2 instanceof HTMLFieldSetElement); ) e2 instanceof HTMLLegendElement && (l3 = e2), e2 = e2.parentElement;
  let t2 = (e2 == null ? void 0 : e2.getAttribute("disabled")) === "";
  return t2 && i$5(l3) ? false : t2;
}
function i$5(n2) {
  if (!n2) return false;
  let e2 = n2.previousElementSibling;
  for (; e2 !== null; ) {
    if (e2 instanceof HTMLLegendElement) return false;
    e2 = e2.previousElementSibling;
  }
  return true;
}
let u$5 = Symbol();
function T$4(t2, n2 = true) {
  return Object.assign(t2, { [u$5]: n2 });
}
function y$4(...t2) {
  let n2 = reactExports.useRef(t2);
  reactExports.useEffect(() => {
    n2.current = t2;
  }, [t2]);
  let c2 = o$4((e2) => {
    for (let o3 of n2.current) o3 != null && (typeof o3 == "function" ? o3(e2) : o3.current = e2);
  });
  return t2.every((e2) => e2 == null || (e2 == null ? void 0 : e2[u$5])) ? void 0 : c2;
}
var o$3 = ((r2) => (r2.Space = " ", r2.Enter = "Enter", r2.Escape = "Escape", r2.Backspace = "Backspace", r2.Delete = "Delete", r2.ArrowLeft = "ArrowLeft", r2.ArrowUp = "ArrowUp", r2.ArrowRight = "ArrowRight", r2.ArrowDown = "ArrowDown", r2.Home = "Home", r2.End = "End", r2.PageUp = "PageUp", r2.PageDown = "PageDown", r2.Tab = "Tab", r2))(o$3 || {});
let e$4 = reactExports.createContext(() => {
});
function C$2({ value: t2, children: o3 }) {
  return React$2.createElement(e$4.Provider, { value: t2 }, o3);
}
function f$5(e2) {
  if (e2 === null) return { width: 0, height: 0 };
  let { width: t2, height: r2 } = e2.getBoundingClientRect();
  return { width: t2, height: r2 };
}
function d$4(e2, t2 = false) {
  let [r2, u3] = reactExports.useReducer(() => ({}), {}), i2 = reactExports.useMemo(() => f$5(e2), [e2, r2]);
  return n$6(() => {
    if (!e2) return;
    let n2 = new ResizeObserver(u3);
    return n2.observe(e2), () => {
      n2.disconnect();
    };
  }, [e2]), t2 ? { width: `${i2.width}px`, height: `${i2.height}px` } : i2;
}
let a$8 = class a extends Map {
  constructor(t2) {
    super();
    this.factory = t2;
  }
  get(t2) {
    let e2 = super.get(t2);
    return e2 === void 0 && (e2 = this.factory(t2), this.set(t2, e2)), e2;
  }
};
function a$7(o3, r2) {
  let t2 = o3(), n2 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t2;
  }, subscribe(e2) {
    return n2.add(e2), () => n2.delete(e2);
  }, dispatch(e2, ...s2) {
    let i2 = r2[e2].call(t2, ...s2);
    i2 && (t2 = i2, n2.forEach((c2) => c2()));
  } };
}
function o$2(t2) {
  return reactExports.useSyncExternalStore(t2.subscribe, t2.getSnapshot, t2.getSnapshot);
}
let p$3 = new a$8(() => a$7(() => [], { ADD(r2) {
  return this.includes(r2) ? this : [...this, r2];
}, REMOVE(r2) {
  let e2 = this.indexOf(r2);
  if (e2 === -1) return this;
  let t2 = this.slice();
  return t2.splice(e2, 1), t2;
} }));
function x$2(r2, e2) {
  let t2 = p$3.get(e2), i2 = reactExports.useId(), h3 = o$2(t2);
  if (n$6(() => {
    if (r2) return t2.dispatch("ADD", i2), () => t2.dispatch("REMOVE", i2);
  }, [t2, r2]), !r2) return false;
  let s2 = h3.indexOf(i2), o3 = h3.length;
  return s2 === -1 && (s2 = o3, o3 += 1), s2 === o3 - 1;
}
function m$3(s2, n2, l3) {
  let i2 = s$6((t2) => {
    let e2 = t2.getBoundingClientRect();
    e2.x === 0 && e2.y === 0 && e2.width === 0 && e2.height === 0 && l3();
  });
  reactExports.useEffect(() => {
    if (!s2) return;
    let t2 = n2 === null ? null : n2 instanceof HTMLElement ? n2 : n2.current;
    if (!t2) return;
    let e2 = o$5();
    if (typeof ResizeObserver != "undefined") {
      let r2 = new ResizeObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    if (typeof IntersectionObserver != "undefined") {
      let r2 = new IntersectionObserver(() => i2.current(t2));
      r2.observe(t2), e2.add(() => r2.disconnect());
    }
    return () => e2.dispose();
  }, [n2, i2, s2]);
}
let f$4 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e2) => `${e2}:not([tabindex='-1'])`).join(","), p$2 = ["[data-autofocus]"].map((e2) => `${e2}:not([tabindex='-1'])`).join(",");
var F$2 = ((n2) => (n2[n2.First = 1] = "First", n2[n2.Previous = 2] = "Previous", n2[n2.Next = 4] = "Next", n2[n2.Last = 8] = "Last", n2[n2.WrapAround = 16] = "WrapAround", n2[n2.NoScroll = 32] = "NoScroll", n2[n2.AutoFocus = 64] = "AutoFocus", n2))(F$2 || {}), T$3 = ((o3) => (o3[o3.Error = 0] = "Error", o3[o3.Overflow = 1] = "Overflow", o3[o3.Success = 2] = "Success", o3[o3.Underflow = 3] = "Underflow", o3))(T$3 || {}), y$3 = ((t2) => (t2[t2.Previous = -1] = "Previous", t2[t2.Next = 1] = "Next", t2))(y$3 || {});
function b$4(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(f$4)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$3(e2 = document.body) {
  return e2 == null ? [] : Array.from(e2.querySelectorAll(p$2)).sort((r2, t2) => Math.sign((r2.tabIndex || Number.MAX_SAFE_INTEGER) - (t2.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$3 = ((t2) => (t2[t2.Strict = 0] = "Strict", t2[t2.Loose = 1] = "Loose", t2))(h$3 || {});
function A$2(e2, r2 = 0) {
  var t2;
  return e2 === ((t2 = u$7(e2)) == null ? void 0 : t2.body) ? false : u$6(r2, { [0]() {
    return e2.matches(f$4);
  }, [1]() {
    let u3 = e2;
    for (; u3 !== null; ) {
      if (u3.matches(f$4)) return true;
      u3 = u3.parentElement;
    }
    return false;
  } });
}
var H$2 = ((t2) => (t2[t2.Keyboard = 0] = "Keyboard", t2[t2.Mouse = 1] = "Mouse", t2))(H$2 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e2) => {
  e2.metaKey || e2.altKey || e2.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e2) => {
  e2.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e2.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function I$3(e2) {
  e2 == null || e2.focus({ preventScroll: true });
}
let w$3 = ["textarea", "input"].join(",");
function O$3(e2) {
  var r2, t2;
  return (t2 = (r2 = e2 == null ? void 0 : e2.matches) == null ? void 0 : r2.call(e2, w$3)) != null ? t2 : false;
}
function _$2(e2, r2 = (t2) => t2) {
  return e2.slice().sort((t2, u3) => {
    let o3 = r2(t2), c2 = r2(u3);
    if (o3 === null || c2 === null) return 0;
    let l3 = o3.compareDocumentPosition(c2);
    return l3 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : l3 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$4(e2, r2) {
  return P$2(b$4(), r2, { relativeTo: e2 });
}
function P$2(e2, r2, { sorted: t2 = true, relativeTo: u3 = null, skipElements: o3 = [] } = {}) {
  let c2 = Array.isArray(e2) ? e2.length > 0 ? e2[0].ownerDocument : document : e2.ownerDocument, l3 = Array.isArray(e2) ? t2 ? _$2(e2) : e2 : r2 & 64 ? S$3(e2) : b$4(e2);
  o3.length > 0 && l3.length > 1 && (l3 = l3.filter((s2) => !o3.some((a3) => a3 != null && "current" in a3 ? (a3 == null ? void 0 : a3.current) === s2 : a3 === s2))), u3 = u3 != null ? u3 : c2.activeElement;
  let n2 = (() => {
    if (r2 & 5) return 1;
    if (r2 & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x2 = (() => {
    if (r2 & 1) return 0;
    if (r2 & 2) return Math.max(0, l3.indexOf(u3)) - 1;
    if (r2 & 4) return Math.max(0, l3.indexOf(u3)) + 1;
    if (r2 & 8) return l3.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), M2 = r2 & 32 ? { preventScroll: true } : {}, m3 = 0, d3 = l3.length, i2;
  do {
    if (m3 >= d3 || m3 + d3 <= 0) return 0;
    let s2 = x2 + m3;
    if (r2 & 16) s2 = (s2 + d3) % d3;
    else {
      if (s2 < 0) return 3;
      if (s2 >= d3) return 1;
    }
    i2 = l3[s2], i2 == null || i2.focus(M2), m3 += n2;
  } while (i2 !== c2.activeElement);
  return r2 & 6 && O$3(i2) && i2.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$4() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$5() {
  return t$2() || i$4();
}
function i$3(t2, e2, o3, n2) {
  let u3 = s$6(o3);
  reactExports.useEffect(() => {
    if (!t2) return;
    function r2(m3) {
      u3.current(m3);
    }
    return document.addEventListener(e2, r2, n2), () => document.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
function s$4(t2, e2, o3, n2) {
  let i2 = s$6(o3);
  reactExports.useEffect(() => {
    if (!t2) return;
    function r2(d3) {
      i2.current(d3);
    }
    return window.addEventListener(e2, r2, n2), () => window.removeEventListener(e2, r2, n2);
  }, [t2, e2, n2]);
}
const E$2 = 30;
function R$3(p3, f3, C2) {
  let u3 = x$2(p3, "outside-click"), m3 = s$6(C2), s2 = reactExports.useCallback(function(e2, n2) {
    if (e2.defaultPrevented) return;
    let r2 = n2(e2);
    if (r2 === null || !r2.getRootNode().contains(r2) || !r2.isConnected) return;
    let h3 = function l3(o3) {
      return typeof o3 == "function" ? l3(o3()) : Array.isArray(o3) || o3 instanceof Set ? o3 : [o3];
    }(f3);
    for (let l3 of h3) if (l3 !== null && (l3.contains(r2) || e2.composed && e2.composedPath().includes(l3))) return;
    return !A$2(r2, h$3.Loose) && r2.tabIndex !== -1 && e2.preventDefault(), m3.current(e2, r2);
  }, [m3, f3]), i2 = reactExports.useRef(null);
  i$3(u3, "pointerdown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, true), i$3(u3, "mousedown", (t2) => {
    var e2, n2;
    i2.current = ((n2 = (e2 = t2.composedPath) == null ? void 0 : e2.call(t2)) == null ? void 0 : n2[0]) || t2.target;
  }, true), i$3(u3, "click", (t2) => {
    n$5() || i2.current && (s2(t2, () => i2.current), i2.current = null);
  }, true);
  let a3 = reactExports.useRef({ x: 0, y: 0 });
  i$3(u3, "touchstart", (t2) => {
    a3.current.x = t2.touches[0].clientX, a3.current.y = t2.touches[0].clientY;
  }, true), i$3(u3, "touchend", (t2) => {
    let e2 = { x: t2.changedTouches[0].clientX, y: t2.changedTouches[0].clientY };
    if (!(Math.abs(e2.x - a3.current.x) >= E$2 || Math.abs(e2.y - a3.current.y) >= E$2)) return s2(t2, () => t2.target instanceof HTMLElement ? t2.target : null);
  }, true), s$4(u3, "blur", (t2) => s2(t2, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}
function n$4(...e2) {
  return reactExports.useMemo(() => u$7(...e2), [...e2]);
}
function E$1(n2, e2, a3, t2) {
  let i2 = s$6(a3);
  reactExports.useEffect(() => {
    n2 = n2 != null ? n2 : window;
    function r2(o3) {
      i2.current(o3);
    }
    return n2.addEventListener(e2, r2, t2), () => n2.removeEventListener(e2, r2, t2);
  }, [n2, e2, t2]);
}
function e$3(t2, u3) {
  return reactExports.useMemo(() => {
    var n2;
    if (t2.type) return t2.type;
    let r2 = (n2 = t2.as) != null ? n2 : "button";
    if (typeof r2 == "string" && r2.toLowerCase() === "button" || (u3 == null ? void 0 : u3.tagName) === "BUTTON" && !u3.hasAttribute("type")) return "button";
  }, [t2.type, t2.as, u3]);
}
function d$3() {
  let r2;
  return { before({ doc: e2 }) {
    var l3;
    let o3 = e2.documentElement, t2 = (l3 = e2.defaultView) != null ? l3 : window;
    r2 = Math.max(0, t2.innerWidth - o3.clientWidth);
  }, after({ doc: e2, d: o3 }) {
    let t2 = e2.documentElement, l3 = Math.max(0, t2.clientWidth - t2.offsetWidth), n2 = Math.max(0, r2 - l3);
    o3.style(t2, "paddingRight", `${n2}px`);
  } };
}
function d$2() {
  return t$2() ? { before({ doc: r2, d: n2, meta: c2 }) {
    function o3(a3) {
      return c2.containers.flatMap((l3) => l3()).some((l3) => l3.contains(a3));
    }
    n2.microTask(() => {
      var s2;
      if (window.getComputedStyle(r2.documentElement).scrollBehavior !== "auto") {
        let t2 = o$5();
        t2.style(r2.documentElement, "scrollBehavior", "auto"), n2.add(() => n2.microTask(() => t2.dispose()));
      }
      let a3 = (s2 = window.scrollY) != null ? s2 : window.pageYOffset, l3 = null;
      n2.addEventListener(r2, "click", (t2) => {
        if (t2.target instanceof HTMLElement) try {
          let e2 = t2.target.closest("a");
          if (!e2) return;
          let { hash: f3 } = new URL(e2.href), i2 = r2.querySelector(f3);
          i2 && !o3(i2) && (l3 = i2);
        } catch {
        }
      }, true), n2.addEventListener(r2, "touchstart", (t2) => {
        if (t2.target instanceof HTMLElement) if (o3(t2.target)) {
          let e2 = t2.target;
          for (; e2.parentElement && o3(e2.parentElement); ) e2 = e2.parentElement;
          n2.style(e2, "overscrollBehavior", "contain");
        } else n2.style(t2.target, "touchAction", "none");
      }), n2.addEventListener(r2, "touchmove", (t2) => {
        if (t2.target instanceof HTMLElement) {
          if (t2.target.tagName === "INPUT") return;
          if (o3(t2.target)) {
            let e2 = t2.target;
            for (; e2.parentElement && e2.dataset.headlessuiPortal !== "" && !(e2.scrollHeight > e2.clientHeight || e2.scrollWidth > e2.clientWidth); ) e2 = e2.parentElement;
            e2.dataset.headlessuiPortal === "" && t2.preventDefault();
          } else t2.preventDefault();
        }
      }, { passive: false }), n2.add(() => {
        var e2;
        let t2 = (e2 = window.scrollY) != null ? e2 : window.pageYOffset;
        a3 !== t2 && window.scrollTo(0, a3), l3 && l3.isConnected && (l3.scrollIntoView({ block: "nearest" }), l3 = null);
      });
    });
  } } : {};
}
function r$1() {
  return { before({ doc: e2, d: o3 }) {
    o3.style(e2.documentElement, "overflow", "hidden");
  } };
}
function m$2(e2) {
  let n2 = {};
  for (let t2 of e2) Object.assign(n2, t2(n2));
  return n2;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(e2, n2) {
  var o3;
  let t2 = (o3 = this.get(e2)) != null ? o3 : { doc: e2, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return t2.count++, t2.meta.add(n2), this.set(e2, t2), this;
}, POP(e2, n2) {
  let t2 = this.get(e2);
  return t2 && (t2.count--, t2.meta.delete(n2)), this;
}, SCROLL_PREVENT({ doc: e2, d: n2, meta: t2 }) {
  let o3 = { doc: e2, d: n2, meta: m$2(t2) }, c2 = [d$2(), d$3(), r$1()];
  c2.forEach(({ before: r2 }) => r2 == null ? void 0 : r2(o3)), c2.forEach(({ after: r2 }) => r2 == null ? void 0 : r2(o3));
}, SCROLL_ALLOW({ d: e2 }) {
  e2.dispose();
}, TEARDOWN({ doc: e2 }) {
  this.delete(e2);
} });
a$6.subscribe(() => {
  let e2 = a$6.getSnapshot(), n2 = /* @__PURE__ */ new Map();
  for (let [t2] of e2) n2.set(t2, t2.documentElement.style.overflow);
  for (let t2 of e2.values()) {
    let o3 = n2.get(t2.doc) === "hidden", c2 = t2.count !== 0;
    (c2 && !o3 || !c2 && o3) && a$6.dispatch(t2.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t2), t2.count === 0 && a$6.dispatch("TEARDOWN", t2);
  }
});
function a$5(r2, e2, n2 = () => ({ containers: [] })) {
  let f3 = o$2(a$6), o3 = e2 ? f3.get(e2) : void 0, i2 = o3 ? o3.count > 0 : false;
  return n$6(() => {
    if (!(!e2 || !r2)) return a$6.dispatch("PUSH", e2, n2), () => a$6.dispatch("POP", e2, n2);
  }, [r2, e2]), i2;
}
function f$3(e2, c2, n2 = () => [document.body]) {
  let r2 = x$2(e2, "scroll-lock");
  a$5(r2, c2, (t2) => {
    var o3;
    return { containers: [...(o3 = t2.containers) != null ? o3 : [], n2] };
  });
}
function c$4(u3 = 0) {
  let [t2, l3] = reactExports.useState(u3), g2 = reactExports.useCallback((e2) => l3(e2), [t2]), s2 = reactExports.useCallback((e2) => l3((a3) => a3 | e2), [t2]), m3 = reactExports.useCallback((e2) => (t2 & e2) === e2, [t2]), n2 = reactExports.useCallback((e2) => l3((a3) => a3 & ~e2), [l3]), F2 = reactExports.useCallback((e2) => l3((a3) => a3 ^ e2), [l3]);
  return { flags: t2, setFlag: g2, addFlag: s2, hasFlag: m3, removeFlag: n2, toggleFlag: F2 };
}
var define_process_env_default = {};
var T$2, b$3;
typeof process != "undefined" && typeof globalThis != "undefined" && typeof Element != "undefined" && ((T$2 = process == null ? void 0 : define_process_env_default) == null ? void 0 : T$2["NODE_ENV"]) === "test" && typeof ((b$3 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$3.getAnimations) == "undefined" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L$1 = ((r2) => (r2[r2.None = 0] = "None", r2[r2.Closed = 1] = "Closed", r2[r2.Enter = 2] = "Enter", r2[r2.Leave = 4] = "Leave", r2))(L$1 || {});
function R$2(t2) {
  let n2 = {};
  for (let e2 in t2) t2[e2] === true && (n2[`data-${e2}`] = "");
  return n2;
}
function x$1(t2, n2, e2, i2) {
  let [r2, o3] = reactExports.useState(e2), { hasFlag: s2, addFlag: a3, removeFlag: l3 } = c$4(t2 && r2 ? 3 : 0), u3 = reactExports.useRef(false), f3 = reactExports.useRef(false), E2 = p$4();
  return n$6(() => {
    var d3;
    if (t2) {
      if (e2 && o3(true), !n2) {
        e2 && a3(3);
        return;
      }
      return (d3 = i2 == null ? void 0 : i2.start) == null || d3.call(i2, e2), C$1(n2, { inFlight: u3, prepare() {
        f3.current ? f3.current = false : f3.current = u3.current, u3.current = true, !f3.current && (e2 ? (a3(3), l3(4)) : (a3(4), l3(2)));
      }, run() {
        f3.current ? e2 ? (l3(3), a3(4)) : (l3(4), a3(3)) : e2 ? l3(1) : a3(1);
      }, done() {
        var p3;
        f3.current && typeof n2.getAnimations == "function" && n2.getAnimations().length > 0 || (u3.current = false, l3(7), e2 || o3(false), (p3 = i2 == null ? void 0 : i2.end) == null || p3.call(i2, e2));
      } });
    }
  }, [t2, e2, n2, E2]), t2 ? [r2, { closed: s2(1), enter: s2(2), leave: s2(4), transition: s2(2) || s2(4) }] : [e2, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C$1(t2, { prepare: n2, run: e2, done: i2, inFlight: r2 }) {
  let o3 = o$5();
  return j$3(t2, { prepare: n2, inFlight: r2 }), o3.nextFrame(() => {
    e2(), o3.requestAnimationFrame(() => {
      o3.add(M$4(t2, i2));
    });
  }), o3.dispose;
}
function M$4(t2, n2) {
  var o3, s2;
  let e2 = o$5();
  if (!t2) return e2.dispose;
  let i2 = false;
  e2.add(() => {
    i2 = true;
  });
  let r2 = (s2 = (o3 = t2.getAnimations) == null ? void 0 : o3.call(t2).filter((a3) => a3 instanceof CSSTransition)) != null ? s2 : [];
  return r2.length === 0 ? (n2(), e2.dispose) : (Promise.allSettled(r2.map((a3) => a3.finished)).then(() => {
    i2 || n2();
  }), e2.dispose);
}
function j$3(t2, { inFlight: n2, prepare: e2 }) {
  if (n2 != null && n2.current) {
    e2();
    return;
  }
  let i2 = t2.style.transition;
  t2.style.transition = "none", e2(), t2.offsetHeight, t2.style.transition = i2;
}
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version: version2
      } = _ref;
      return brand + "/" + version2;
    }).join(" ");
  }
  return navigator.userAgent;
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr2;
      return isStart ? lr2 : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options2) {
  var _await$platform$isEle;
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options2, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options2) => ({
  name: "arrow",
  options: options2,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options2, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "flip",
    options: options2,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options2, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a3, b2) => a3.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d3) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d3.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b2) => a3[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "hide",
    options: options2,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options2, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options2) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options2, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options2) {
  if (options2 === void 0) {
    options2 = 0;
  }
  return {
    name: "offset",
    options: options2,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options2);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "shift",
    options: options2,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    options: options2,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options2, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  return {
    name: "size",
    options: options2,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options2, state);
      const overflow = await detectOverflow$1(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill2) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill2) {
    return polyfill2(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill2) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill2);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill2);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b2) {
  return a3.x === b2.x && a3.y === b2.y && a3.width === b2.width && a3.height === b2.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e2) {
      io2 = new IntersectionObserver(handleObserve, options2);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const detectOverflow = detectOverflow$1;
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options2) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options2
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index$1 = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual(a3, b2) {
  if (a3 === b2) {
    return true;
  }
  if (typeof a3 !== typeof b2) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a3 && b2 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual(a3[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index$1(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating$1(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options2;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index$1(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index$1(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index$1(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options2) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options: options2,
    fn(state) {
      const {
        element,
        padding
      } = typeof options2 === "function" ? options2(state) : options2;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options2, deps) => ({
  ...offset$1(options2),
  options: [options2, deps]
});
const shift = (options2, deps) => ({
  ...shift$1(options2),
  options: [options2, deps]
});
const limitShift = (options2, deps) => ({
  ...limitShift$1(options2),
  options: [options2, deps]
});
const flip = (options2, deps) => ({
  ...flip$1(options2),
  options: [options2, deps]
});
const size = (options2, deps) => ({
  ...size$1(options2),
  options: [options2, deps]
});
const hide = (options2, deps) => ({
  ...hide$1(options2),
  options: [options2, deps]
});
const arrow = (options2, deps) => ({
  ...arrow$1(options2),
  options: [options2, deps]
});
const SafeReact = {
  ...React$3
};
const useInsertionEffect = SafeReact.useInsertionEffect;
const useSafeInsertionEffect = useInsertionEffect || ((fn2) => fn2());
function useEffectEvent(callback) {
  const ref = reactExports.useRef(() => {
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
let serverHandoffComplete = false;
let count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id2, setId] = reactExports.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id2 == null) {
      setId(genId());
    }
  }, []);
  reactExports.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id2;
}
const useReactId = SafeReact.useId;
const useId = useReactId || useFloatingId;
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      var _map$get2;
      map.set(event, ((_map$get2 = map.get(event)) == null ? void 0 : _map$get2.filter((l3) => l3 !== listener)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ reactExports.createContext(null);
const FloatingTreeContext = /* @__PURE__ */ reactExports.createContext(null);
const useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = reactExports.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
const useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
const FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(options2) {
  const {
    open = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options2;
  const floatingId = useId();
  const dataRef = reactExports.useRef({});
  const [events] = reactExports.useState(() => createPubSub());
  const nested = useFloatingParentNodeId() != null;
  const [positionReference, setPositionReference] = reactExports.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open2, event, reason) => {
    dataRef.current.openEvent = open2 ? event : void 0;
    events.emit("openchange", {
      open: open2,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open2, event, reason);
  });
  const refs = reactExports.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = reactExports.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return reactExports.useMemo(() => ({
    dataRef,
    open,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    nodeId
  } = options2;
  const internalRootContext = useFloatingRootContext({
    ...options2,
    elements: {
      reference: null,
      floating: null,
      ...options2.elements
    }
  });
  const rootContext = options2.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = reactExports.useState(null);
  const [positionReference, _setPositionReference] = reactExports.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = reactExports.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating$1({
    ...options2,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = reactExports.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = reactExports.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = reactExports.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = reactExports.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context2 = reactExports.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context2;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context2;
    }
  });
  return reactExports.useMemo(() => ({
    ...position,
    context: context2,
    refs,
    elements
  }), [position, refs, elements, context2]);
}
const ACTIVE_KEY = "active";
const SELECTED_KEY = "selected";
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _2,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn2) => fn2(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = reactExports.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return reactExports.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getArgsWithCustomFloatingHeight(state, height) {
  return {
    ...state,
    rects: {
      ...state.rects,
      floating: {
        ...state.rects.floating,
        height
      }
    }
  };
}
const inner = (props) => ({
  name: "inner",
  options: props,
  async fn(state) {
    const {
      listRef,
      overflowRef,
      onFallbackChange,
      offset: innerOffset = 0,
      index: index2 = 0,
      minItemsVisible = 4,
      referenceOverflowThreshold = 0,
      scrollRef,
      ...detectOverflowOptions
    } = evaluate(props, state);
    const {
      rects,
      elements: {
        floating
      }
    } = state;
    const item = listRef.current[index2];
    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;
    const clientTop = floating.clientTop || scrollEl.clientTop;
    const floatingIsBordered = floating.clientTop !== 0;
    const scrollElIsBordered = scrollEl.clientTop !== 0;
    const floatingIsScrollEl = floating === scrollEl;
    if (!item) {
      return {};
    }
    const nextArgs = {
      ...state,
      ...await offset(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state)
    };
    const overflow = await detectOverflow(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);
    const refOverflow = await detectOverflow(nextArgs, {
      ...detectOverflowOptions,
      elementContext: "reference"
    });
    const diffY = max(0, overflow.top);
    const nextY = nextArgs.y + diffY;
    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;
    const rounder = isScrollable ? (v2) => v2 : round;
    const maxHeight = rounder(max(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - max(0, overflow.bottom)));
    scrollEl.style.maxHeight = maxHeight + "px";
    scrollEl.scrollTop = diffY;
    if (onFallbackChange) {
      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * min(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;
      reactDomExports.flushSync(() => onFallbackChange(shouldFallback));
    }
    if (overflowRef) {
      overflowRef.current = await detectOverflow(getArgsWithCustomFloatingHeight({
        ...nextArgs,
        y: nextY
      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);
    }
    return {
      y: nextY
    };
  }
});
function useInnerOffset(context2, props) {
  const {
    open,
    elements
  } = context2;
  const {
    enabled = true,
    overflowRef,
    scrollRef,
    onChange: unstable_onChange
  } = props;
  const onChange = useEffectEvent(unstable_onChange);
  const controlledScrollingRef = reactExports.useRef(false);
  const prevScrollTopRef = reactExports.useRef(null);
  const initialOverflowRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!enabled) return;
    function onWheel(e2) {
      if (e2.ctrlKey || !el2 || overflowRef.current == null) {
        return;
      }
      const dY = e2.deltaY;
      const isAtTop = overflowRef.current.top >= -0.5;
      const isAtBottom = overflowRef.current.bottom >= -0.5;
      const remainingScroll = el2.scrollHeight - el2.clientHeight;
      const sign = dY < 0 ? -1 : 1;
      const method = dY < 0 ? "max" : "min";
      if (el2.scrollHeight <= el2.clientHeight) {
        return;
      }
      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {
        e2.preventDefault();
        reactDomExports.flushSync(() => {
          onChange((d3) => d3 + Math[method](dY, remainingScroll * sign));
        });
      } else if (/firefox/i.test(getUserAgent())) {
        el2.scrollTop += dY;
      }
    }
    const el2 = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
    if (open && el2) {
      el2.addEventListener("wheel", onWheel);
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el2.scrollTop;
        if (overflowRef.current != null) {
          initialOverflowRef.current = {
            ...overflowRef.current
          };
        }
      });
      return () => {
        prevScrollTopRef.current = null;
        initialOverflowRef.current = null;
        el2.removeEventListener("wheel", onWheel);
      };
    }
  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);
  const floating = reactExports.useMemo(() => ({
    onKeyDown() {
      controlledScrollingRef.current = true;
    },
    onWheel() {
      controlledScrollingRef.current = false;
    },
    onPointerMove() {
      controlledScrollingRef.current = false;
    },
    onScroll() {
      const el2 = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;
      if (!overflowRef.current || !el2 || !controlledScrollingRef.current) {
        return;
      }
      if (prevScrollTopRef.current !== null) {
        const scrollDiff = el2.scrollTop - prevScrollTopRef.current;
        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {
          reactDomExports.flushSync(() => onChange((d3) => d3 + scrollDiff));
        }
      }
      requestAnimationFrame(() => {
        prevScrollTopRef.current = el2.scrollTop;
      });
    }
  }), [elements.floating, onChange, overflowRef, scrollRef]);
  return reactExports.useMemo(() => enabled ? {
    floating
  } : {}, [enabled, floating]);
}
let y$2 = reactExports.createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$2.displayName = "FloatingContext";
let H$1 = reactExports.createContext(null);
H$1.displayName = "PlacementContext";
function xe$1(e2) {
  return reactExports.useMemo(() => e2 ? typeof e2 == "string" ? { to: e2 } : e2 : null, [e2]);
}
function ye$1() {
  return reactExports.useContext(y$2).setReference;
}
function Fe$1() {
  return reactExports.useContext(y$2).getReferenceProps;
}
function be$2() {
  let { getFloatingProps: e2, slot: t2 } = reactExports.useContext(y$2);
  return reactExports.useCallback((...n2) => Object.assign({}, e2(...n2), { "data-anchor": t2.anchor }), [e2, t2]);
}
function Re$1(e2 = null) {
  e2 === false && (e2 = null), typeof e2 == "string" && (e2 = { to: e2 });
  let t2 = reactExports.useContext(H$1), n2 = reactExports.useMemo(() => e2, [JSON.stringify(e2, (r2, o3) => {
    var u3;
    return (u3 = o3 == null ? void 0 : o3.outerHTML) != null ? u3 : o3;
  })]);
  n$6(() => {
    t2 == null || t2(n2 != null ? n2 : null);
  }, [t2, n2]);
  let l3 = reactExports.useContext(y$2);
  return reactExports.useMemo(() => [l3.setFloating, e2 ? l3.styles : {}], [l3.setFloating, e2, l3.styles]);
}
let q$1 = 4;
function Me$1({ children: e2, enabled: t2 = true }) {
  let [n2, l3] = reactExports.useState(null), [r2, o3] = reactExports.useState(0), u3 = reactExports.useRef(null), [f3, s2] = reactExports.useState(null);
  pe$1(f3);
  let i2 = t2 && n2 !== null && f3 !== null, { to: F2 = "bottom", gap: E2 = 0, offset: v2 = 0, padding: c2 = 0, inner: P3 } = ce(n2, f3), [a3, p3 = "center"] = F2.split(" ");
  n$6(() => {
    i2 && o3(0);
  }, [i2]);
  let { refs: b2, floatingStyles: w2, context: g2 } = useFloating({ open: i2, placement: a3 === "selection" ? p3 === "center" ? "bottom" : `bottom-${p3}` : p3 === "center" ? `${a3}` : `${a3}-${p3}`, strategy: "absolute", transform: false, middleware: [offset({ mainAxis: a3 === "selection" ? 0 : E2, crossAxis: v2 }), shift({ padding: c2 }), a3 !== "selection" && flip({ padding: c2 }), a3 === "selection" && P3 ? inner({ ...P3, padding: c2, overflowRef: u3, offset: r2, minItemsVisible: q$1, referenceOverflowThreshold: c2, onFallbackChange(h3) {
    var O2, W2;
    if (!h3) return;
    let d3 = g2.elements.floating;
    if (!d3) return;
    let T2 = parseFloat(getComputedStyle(d3).scrollPaddingBottom) || 0, $2 = Math.min(q$1, d3.childElementCount), L2 = 0, N2 = 0;
    for (let m3 of (W2 = (O2 = g2.elements.floating) == null ? void 0 : O2.childNodes) != null ? W2 : []) if (m3 instanceof HTMLElement) {
      let x2 = m3.offsetTop, k2 = x2 + m3.clientHeight + T2, S2 = d3.scrollTop, U2 = S2 + d3.clientHeight;
      if (x2 >= S2 && k2 <= U2) $2--;
      else {
        N2 = Math.max(0, Math.min(k2, U2) - Math.max(x2, S2)), L2 = m3.clientHeight;
        break;
      }
    }
    $2 >= 1 && o3((m3) => {
      let x2 = L2 * $2 - N2 + T2;
      return m3 >= x2 ? m3 : x2;
    });
  } }) : null, size({ padding: c2, apply({ availableWidth: h3, availableHeight: d3, elements: T2 }) {
    Object.assign(T2.floating.style, { overflow: "auto", maxWidth: `${h3}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${d3}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [I2 = a3, B2 = p3] = g2.placement.split("-");
  a3 === "selection" && (I2 = "selection");
  let G2 = reactExports.useMemo(() => ({ anchor: [I2, B2].filter(Boolean).join(" ") }), [I2, B2]), K2 = useInnerOffset(g2, { overflowRef: u3, onChange: o3 }), { getReferenceProps: Q2, getFloatingProps: X2 } = useInteractions([K2]), Y2 = o$4((h3) => {
    s2(h3), b2.setFloating(h3);
  });
  return reactExports.createElement(H$1.Provider, { value: l3 }, reactExports.createElement(y$2.Provider, { value: { setFloating: Y2, setReference: b2.setReference, styles: w2, getReferenceProps: Q2, getFloatingProps: X2, slot: G2 } }, e2));
}
function pe$1(e2) {
  n$6(() => {
    if (!e2) return;
    let t2 = new MutationObserver(() => {
      let n2 = window.getComputedStyle(e2).maxHeight, l3 = parseFloat(n2);
      if (isNaN(l3)) return;
      let r2 = parseInt(n2);
      isNaN(r2) || l3 !== r2 && (e2.style.maxHeight = `${Math.ceil(l3)}px`);
    });
    return t2.observe(e2, { attributes: true, attributeFilter: ["style"] }), () => {
      t2.disconnect();
    };
  }, [e2]);
}
function ce(e2, t2) {
  var o3, u3, f3;
  let n2 = V$2((o3 = e2 == null ? void 0 : e2.gap) != null ? o3 : "var(--anchor-gap, 0)", t2), l3 = V$2((u3 = e2 == null ? void 0 : e2.offset) != null ? u3 : "var(--anchor-offset, 0)", t2), r2 = V$2((f3 = e2 == null ? void 0 : e2.padding) != null ? f3 : "var(--anchor-padding, 0)", t2);
  return { ...e2, gap: n2, offset: l3, padding: r2 };
}
function V$2(e2, t2, n2 = void 0) {
  let l3 = p$4(), r2 = o$4((s2, i2) => {
    if (s2 == null) return [n2, null];
    if (typeof s2 == "number") return [s2, null];
    if (typeof s2 == "string") {
      if (!i2) return [n2, null];
      let F2 = J$3(s2, i2);
      return [F2, (E2) => {
        let v2 = D$2(s2);
        {
          let c2 = v2.map((P3) => window.getComputedStyle(i2).getPropertyValue(P3));
          l3.requestAnimationFrame(function P3() {
            l3.nextFrame(P3);
            let a3 = false;
            for (let [b2, w2] of v2.entries()) {
              let g2 = window.getComputedStyle(i2).getPropertyValue(w2);
              if (c2[b2] !== g2) {
                c2[b2] = g2, a3 = true;
                break;
              }
            }
            if (!a3) return;
            let p3 = J$3(s2, i2);
            F2 !== p3 && (E2(p3), F2 = p3);
          });
        }
        return l3.dispose;
      }];
    }
    return [n2, null];
  }), o3 = reactExports.useMemo(() => r2(e2, t2)[0], [e2, t2]), [u3 = o3, f3] = reactExports.useState();
  return n$6(() => {
    let [s2, i2] = r2(e2, t2);
    if (f3(s2), !!i2) return i2(f3);
  }, [e2, t2]), u3;
}
function D$2(e2) {
  let t2 = /var\((.*)\)/.exec(e2);
  if (t2) {
    let n2 = t2[1].indexOf(",");
    if (n2 === -1) return [t2[1]];
    let l3 = t2[1].slice(0, n2).trim(), r2 = t2[1].slice(n2 + 1).trim();
    return r2 ? [l3, ...D$2(r2)] : [l3];
  }
  return [];
}
function J$3(e2, t2) {
  let n2 = document.createElement("div");
  t2.appendChild(n2), n2.style.setProperty("margin-top", "0px", "important"), n2.style.setProperty("margin-top", e2, "important");
  let l3 = parseFloat(window.getComputedStyle(n2).marginTop) || 0;
  return t2.removeChild(n2), l3;
}
let n$3 = reactExports.createContext(null);
n$3.displayName = "OpenClosedContext";
var i$2 = ((e2) => (e2[e2.Open = 1] = "Open", e2[e2.Closed = 2] = "Closed", e2[e2.Closing = 4] = "Closing", e2[e2.Opening = 8] = "Opening", e2))(i$2 || {});
function u$4() {
  return reactExports.useContext(n$3);
}
function c$3({ value: o3, children: t2 }) {
  return React$2.createElement(n$3.Provider, { value: o3 }, t2);
}
function s$3({ children: o3 }) {
  return React$2.createElement(n$3.Provider, { value: null }, o3);
}
function c$2(t2) {
  let r2 = o$4(t2), e2 = reactExports.useRef(false);
  reactExports.useEffect(() => (e2.current = false, () => {
    e2.current = true, t$4(() => {
      e2.current && r2();
    });
  }), [r2]);
}
function s$2() {
  let r2 = typeof document == "undefined";
  return "useSyncExternalStore" in React$3 ? ((o3) => o3.useSyncExternalStore)(React$3)(() => () => {
  }, () => false, () => !r2) : false;
}
function l$3() {
  let r2 = s$2(), [e2, n2] = reactExports.useState(s$7.isHandoffComplete);
  return e2 && s$7.isHandoffComplete === false && n2(false), reactExports.useEffect(() => {
    e2 !== true && n2(true);
  }, [e2]), reactExports.useEffect(() => s$7.handoff(), []), r2 ? false : e2;
}
let e$2 = reactExports.createContext(false);
function a$4() {
  return reactExports.useContext(e$2);
}
function l$2(o3) {
  return React$2.createElement(e$2.Provider, { value: o3.force }, o3.children);
}
function N$1(u3) {
  let r2 = a$4(), n2 = reactExports.useContext(v$2), e2 = n$4(u3), [o3, l3] = reactExports.useState(() => {
    var t2;
    if (!r2 && n2 !== null) return (t2 = n2.current) != null ? t2 : null;
    if (s$7.isServer) return null;
    let p3 = e2 == null ? void 0 : e2.getElementById("headlessui-portal-root");
    if (p3) return p3;
    if (e2 === null) return null;
    let a3 = e2.createElement("div");
    return a3.setAttribute("id", "headlessui-portal-root"), e2.body.appendChild(a3);
  });
  return reactExports.useEffect(() => {
    o3 !== null && (e2 != null && e2.body.contains(o3) || e2 == null || e2.body.appendChild(o3));
  }, [o3, e2]), reactExports.useEffect(() => {
    r2 || n2 !== null && l3(n2.current);
  }, [n2, l3, r2]), o3;
}
let M$3 = reactExports.Fragment, S$2 = K$1(function(r2, n2) {
  let e2 = r2, o3 = reactExports.useRef(null), l3 = y$4(T$4((i2) => {
    o3.current = i2;
  }), n2), p3 = n$4(o3), a3 = N$1(o3), [t2] = reactExports.useState(() => {
    var i2;
    return s$7.isServer ? null : (i2 = p3 == null ? void 0 : p3.createElement("div")) != null ? i2 : null;
  }), s2 = reactExports.useContext(y$1), b2 = l$3();
  n$6(() => {
    !a3 || !t2 || a3.contains(t2) || (t2.setAttribute("data-headlessui-portal", ""), a3.appendChild(t2));
  }, [a3, t2]), n$6(() => {
    if (t2 && s2) return s2.register(t2);
  }, [s2, t2]), c$2(() => {
    var i2;
    !a3 || !t2 || (t2 instanceof Node && a3.contains(t2) && a3.removeChild(t2), a3.childNodes.length <= 0 && ((i2 = a3.parentElement) == null || i2.removeChild(a3)));
  });
  let H2 = L$2();
  return b2 ? !a3 || !t2 ? null : reactDomExports.createPortal(H2({ ourProps: { ref: l3 }, theirProps: e2, slot: {}, defaultTag: M$3, name: "Portal" }), t2) : null;
});
function j$2(u3, r2) {
  let n2 = y$4(r2), { enabled: e2 = true, ...o3 } = u3, l3 = L$2();
  return e2 ? React$2.createElement(S$2, { ...o3, ref: n2 }) : l3({ ourProps: { ref: n2 }, theirProps: o3, slot: {}, defaultTag: M$3, name: "Portal" });
}
let W$2 = reactExports.Fragment, v$2 = reactExports.createContext(null);
function I$2(u3, r2) {
  let { target: n2, ...e2 } = u3, l3 = { ref: y$4(r2) }, p3 = L$2();
  return React$2.createElement(v$2.Provider, { value: n2 }, p3({ ourProps: l3, theirProps: e2, defaultTag: W$2, name: "Popover.Group" }));
}
let y$1 = reactExports.createContext(null);
function te$1() {
  let u3 = reactExports.useContext(y$1), r2 = reactExports.useRef([]), n2 = o$4((l3) => (r2.current.push(l3), u3 && u3.register(l3), () => e2(l3))), e2 = o$4((l3) => {
    let p3 = r2.current.indexOf(l3);
    p3 !== -1 && r2.current.splice(p3, 1), u3 && u3.unregister(l3);
  }), o3 = reactExports.useMemo(() => ({ register: n2, unregister: e2, portals: r2 }), [n2, e2, r2]);
  return [r2, reactExports.useMemo(() => function({ children: p3 }) {
    return React$2.createElement(y$1.Provider, { value: o3 }, p3);
  }, [o3])];
}
let J$2 = K$1(j$2), X$3 = K$1(I$2), re$1 = Object.assign(J$2, { Group: X$3 });
function R$1({ defaultContainers: l3 = [], portals: n2, mainTreeNode: o3 } = {}) {
  let r2 = n$4(o3), u3 = o$4(() => {
    var i2, c2;
    let t2 = [];
    for (let e2 of l3) e2 !== null && (e2 instanceof HTMLElement ? t2.push(e2) : "current" in e2 && e2.current instanceof HTMLElement && t2.push(e2.current));
    if (n2 != null && n2.current) for (let e2 of n2.current) t2.push(e2);
    for (let e2 of (i2 = r2 == null ? void 0 : r2.querySelectorAll("html > *, body > *")) != null ? i2 : []) e2 !== document.body && e2 !== document.head && e2 instanceof HTMLElement && e2.id !== "headlessui-portal-root" && (o3 && (e2.contains(o3) || e2.contains((c2 = o3 == null ? void 0 : o3.getRootNode()) == null ? void 0 : c2.host)) || t2.some((m3) => e2.contains(m3)) || t2.push(e2));
    return t2;
  });
  return { resolveContainers: u3, contains: o$4((t2) => u3().some((i2) => i2.contains(t2))) };
}
let a$3 = reactExports.createContext(null);
function O$2({ children: l3, node: n2 }) {
  let [o3, r2] = reactExports.useState(null), u3 = b$2(n2 != null ? n2 : o3);
  return React$2.createElement(a$3.Provider, { value: u3 }, l3, u3 === null && React$2.createElement(f$6, { features: s$5.Hidden, ref: (t2) => {
    var i2, c2;
    if (t2) {
      for (let e2 of (c2 = (i2 = u$7(t2)) == null ? void 0 : i2.querySelectorAll("html > *, body > *")) != null ? c2 : []) if (e2 !== document.body && e2 !== document.head && e2 instanceof HTMLElement && e2 != null && e2.contains(t2)) {
        r2(e2);
        break;
      }
    }
  } }));
}
function b$2(l3 = null) {
  var n2;
  return (n2 = reactExports.useContext(a$3)) != null ? n2 : l3;
}
function f$2() {
  let e2 = reactExports.useRef(false);
  return n$6(() => (e2.current = true, () => {
    e2.current = false;
  }), []), e2;
}
var a$2 = ((r2) => (r2[r2.Forwards = 0] = "Forwards", r2[r2.Backwards = 1] = "Backwards", r2))(a$2 || {});
function u$3() {
  let e2 = reactExports.useRef(0);
  return s$4(true, "keydown", (r2) => {
    r2.key === "Tab" && (e2.current = r2.shiftKey ? 1 : 0);
  }, true), e2;
}
function ue$2(e2) {
  var t2;
  return !!(e2.enter || e2.enterFrom || e2.enterTo || e2.leave || e2.leaveFrom || e2.leaveTo) || ((t2 = e2.as) != null ? t2 : de$1) !== reactExports.Fragment || React$2.Children.count(e2.children) === 1;
}
let w$2 = reactExports.createContext(null);
w$2.displayName = "TransitionContext";
var _e = ((n2) => (n2.Visible = "visible", n2.Hidden = "hidden", n2))(_e || {});
function De() {
  let e2 = reactExports.useContext(w$2);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
function He() {
  let e2 = reactExports.useContext(M$2);
  if (e2 === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e2;
}
let M$2 = reactExports.createContext(null);
M$2.displayName = "NestingContext";
function U$2(e2) {
  return "children" in e2 ? U$2(e2.children) : e2.current.filter(({ el: t2 }) => t2.current !== null).filter(({ state: t2 }) => t2 === "visible").length > 0;
}
function Te$1(e2, t2) {
  let n2 = s$6(e2), l3 = reactExports.useRef([]), S2 = f$2(), R2 = p$4(), d3 = o$4((o3, i2 = A$3.Hidden) => {
    let a3 = l3.current.findIndex(({ el: s2 }) => s2 === o3);
    a3 !== -1 && (u$6(i2, { [A$3.Unmount]() {
      l3.current.splice(a3, 1);
    }, [A$3.Hidden]() {
      l3.current[a3].state = "hidden";
    } }), R2.microTask(() => {
      var s2;
      !U$2(l3) && S2.current && ((s2 = n2.current) == null || s2.call(n2));
    }));
  }), y2 = o$4((o3) => {
    let i2 = l3.current.find(({ el: a3 }) => a3 === o3);
    return i2 ? i2.state !== "visible" && (i2.state = "visible") : l3.current.push({ el: o3, state: "visible" }), () => d3(o3, A$3.Unmount);
  }), p3 = reactExports.useRef([]), c2 = reactExports.useRef(Promise.resolve()), C2 = reactExports.useRef({ enter: [], leave: [] }), h3 = o$4((o3, i2, a3) => {
    p3.current.splice(0), t2 && (t2.chains.current[i2] = t2.chains.current[i2].filter(([s2]) => s2 !== o3)), t2 == null || t2.chains.current[i2].push([o3, new Promise((s2) => {
      p3.current.push(s2);
    })]), t2 == null || t2.chains.current[i2].push([o3, new Promise((s2) => {
      Promise.all(C2.current[i2].map(([r2, f3]) => f3)).then(() => s2());
    })]), i2 === "enter" ? c2.current = c2.current.then(() => t2 == null ? void 0 : t2.wait.current).then(() => a3(i2)) : a3(i2);
  }), g2 = o$4((o3, i2, a3) => {
    Promise.all(C2.current[i2].splice(0).map(([s2, r2]) => r2)).then(() => {
      var s2;
      (s2 = p3.current.shift()) == null || s2();
    }).then(() => a3(i2));
  });
  return reactExports.useMemo(() => ({ children: l3, register: y2, unregister: d3, onStart: h3, onStop: g2, wait: c2, chains: C2 }), [y2, d3, l3, h3, g2, C2, c2]);
}
let de$1 = reactExports.Fragment, fe$1 = O$4.RenderStrategy;
function Ae$1(e2, t2) {
  var ee2, te2;
  let { transition: n2 = true, beforeEnter: l3, afterEnter: S2, beforeLeave: R2, afterLeave: d3, enter: y2, enterFrom: p3, enterTo: c2, entered: C2, leave: h3, leaveFrom: g2, leaveTo: o3, ...i2 } = e2, [a3, s2] = reactExports.useState(null), r2 = reactExports.useRef(null), f3 = ue$2(e2), j2 = y$4(...f3 ? [r2, t2, s2] : t2 === null ? [] : [t2]), H2 = (ee2 = i2.unmount) == null || ee2 ? A$3.Unmount : A$3.Hidden, { show: u3, appear: z2, initial: K2 } = De(), [v2, G2] = reactExports.useState(u3 ? "visible" : "hidden"), Q2 = He(), { register: A2, unregister: I2 } = Q2;
  n$6(() => A2(r2), [A2, r2]), n$6(() => {
    if (H2 === A$3.Hidden && r2.current) {
      if (u3 && v2 !== "visible") {
        G2("visible");
        return;
      }
      return u$6(v2, { ["hidden"]: () => I2(r2), ["visible"]: () => A2(r2) });
    }
  }, [v2, r2, A2, I2, u3, H2]);
  let B2 = l$3();
  n$6(() => {
    if (f3 && B2 && v2 === "visible" && r2.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [r2, v2, B2, f3]);
  let ce2 = K2 && !z2, Y2 = z2 && u3 && K2, W2 = reactExports.useRef(false), L2 = Te$1(() => {
    W2.current || (G2("hidden"), I2(r2));
  }, Q2), Z3 = o$4((k2) => {
    W2.current = true;
    let F2 = k2 ? "enter" : "leave";
    L2.onStart(r2, F2, (_2) => {
      _2 === "enter" ? l3 == null || l3() : _2 === "leave" && (R2 == null || R2());
    });
  }), $2 = o$4((k2) => {
    let F2 = k2 ? "enter" : "leave";
    W2.current = false, L2.onStop(r2, F2, (_2) => {
      _2 === "enter" ? S2 == null || S2() : _2 === "leave" && (d3 == null || d3());
    }), F2 === "leave" && !U$2(L2) && (G2("hidden"), I2(r2));
  });
  reactExports.useEffect(() => {
    f3 && n2 || (Z3(u3), $2(u3));
  }, [u3, f3, n2]);
  let pe2 = /* @__PURE__ */ (() => !(!n2 || !f3 || !B2 || ce2))(), [, T2] = x$1(pe2, a3, u3, { start: Z3, end: $2 }), Ce2 = m$4({ ref: j2, className: ((te2 = t$3(i2.className, Y2 && y2, Y2 && p3, T2.enter && y2, T2.enter && T2.closed && p3, T2.enter && !T2.closed && c2, T2.leave && h3, T2.leave && !T2.closed && g2, T2.leave && T2.closed && o3, !T2.transition && u3 && C2)) == null ? void 0 : te2.trim()) || void 0, ...R$2(T2) }), N2 = 0;
  v2 === "visible" && (N2 |= i$2.Open), v2 === "hidden" && (N2 |= i$2.Closed), T2.enter && (N2 |= i$2.Opening), T2.leave && (N2 |= i$2.Closing);
  let he2 = L$2();
  return React$2.createElement(M$2.Provider, { value: L2 }, React$2.createElement(c$3, { value: N2 }, he2({ ourProps: Ce2, theirProps: i2, defaultTag: de$1, features: fe$1, visible: v2 === "visible", name: "Transition.Child" })));
}
function Ie$1(e2, t2) {
  let { show: n2, appear: l3 = false, unmount: S2 = true, ...R2 } = e2, d3 = reactExports.useRef(null), y2 = ue$2(e2), p3 = y$4(...y2 ? [d3, t2] : t2 === null ? [] : [t2]);
  l$3();
  let c2 = u$4();
  if (n2 === void 0 && c2 !== null && (n2 = (c2 & i$2.Open) === i$2.Open), n2 === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [C2, h3] = reactExports.useState(n2 ? "visible" : "hidden"), g2 = Te$1(() => {
    n2 || h3("hidden");
  }), [o3, i2] = reactExports.useState(true), a3 = reactExports.useRef([n2]);
  n$6(() => {
    o3 !== false && a3.current[a3.current.length - 1] !== n2 && (a3.current.push(n2), i2(false));
  }, [a3, n2]);
  let s2 = reactExports.useMemo(() => ({ show: n2, appear: l3, initial: o3 }), [n2, l3, o3]);
  n$6(() => {
    n2 ? h3("visible") : !U$2(g2) && d3.current !== null && h3("hidden");
  }, [n2, g2]);
  let r2 = { unmount: S2 }, f3 = o$4(() => {
    var u3;
    o3 && i2(false), (u3 = e2.beforeEnter) == null || u3.call(e2);
  }), j2 = o$4(() => {
    var u3;
    o3 && i2(false), (u3 = e2.beforeLeave) == null || u3.call(e2);
  }), H2 = L$2();
  return React$2.createElement(M$2.Provider, { value: g2 }, React$2.createElement(w$2.Provider, { value: s2 }, H2({ ourProps: { ...r2, as: reactExports.Fragment, children: React$2.createElement(me, { ref: p3, ...r2, ...R2, beforeEnter: f3, beforeLeave: j2 }) }, theirProps: {}, defaultTag: reactExports.Fragment, features: fe$1, visible: C2 === "visible", name: "Transition" })));
}
function Le(e2, t2) {
  let n2 = reactExports.useContext(w$2) !== null, l3 = u$4() !== null;
  return React$2.createElement(React$2.Fragment, null, !n2 && l3 ? React$2.createElement(X$2, { ref: t2, ...e2 }) : React$2.createElement(me, { ref: t2, ...e2 }));
}
let X$2 = K$1(Ie$1), me = K$1(Ae$1), Fe = K$1(Le), ze = Object.assign(X$2, { Child: Fe, Root: X$2 });
var lt = ((f3) => (f3[f3.Open = 0] = "Open", f3[f3.Closed = 1] = "Closed", f3))(lt || {}), at = ((p3) => (p3[p3.TogglePopover = 0] = "TogglePopover", p3[p3.ClosePopover = 1] = "ClosePopover", p3[p3.SetButton = 2] = "SetButton", p3[p3.SetButtonId = 3] = "SetButtonId", p3[p3.SetPanel = 4] = "SetPanel", p3[p3.SetPanelId = 5] = "SetPanelId", p3))(at || {});
let pt = { [0]: (o3) => ({ ...o3, popoverState: u$6(o3.popoverState, { [0]: 1, [1]: 0 }), __demoMode: false }), [1](o3) {
  return o3.popoverState === 1 ? o3 : { ...o3, popoverState: 1, __demoMode: false };
}, [2](o3, a3) {
  return o3.button === a3.button ? o3 : { ...o3, button: a3.button };
}, [3](o3, a3) {
  return o3.buttonId === a3.buttonId ? o3 : { ...o3, buttonId: a3.buttonId };
}, [4](o3, a3) {
  return o3.panel === a3.panel ? o3 : { ...o3, panel: a3.panel };
}, [5](o3, a3) {
  return o3.panelId === a3.panelId ? o3 : { ...o3, panelId: a3.panelId };
} }, Ee$1 = reactExports.createContext(null);
Ee$1.displayName = "PopoverContext";
function se$1(o3) {
  let a3 = reactExports.useContext(Ee$1);
  if (a3 === null) {
    let f3 = new Error(`<${o3} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f3, se$1), f3;
  }
  return a3;
}
let ue$1 = reactExports.createContext(null);
ue$1.displayName = "PopoverAPIContext";
function be$1(o3) {
  let a3 = reactExports.useContext(ue$1);
  if (a3 === null) {
    let f3 = new Error(`<${o3} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(f3, be$1), f3;
  }
  return a3;
}
let ge$1 = reactExports.createContext(null);
ge$1.displayName = "PopoverGroupContext";
function Me() {
  return reactExports.useContext(ge$1);
}
let ie = reactExports.createContext(null);
ie.displayName = "PopoverPanelContext";
function st() {
  return reactExports.useContext(ie);
}
function ut(o3, a3) {
  return u$6(a3.type, pt, o3, a3);
}
let it = "div";
function dt(o3, a3) {
  var J2;
  let { __demoMode: f3 = false, ...C2 } = o3, T2 = reactExports.useRef(null), S2 = y$4(a3, T$4((t2) => {
    T2.current = t2;
  })), p3 = reactExports.useRef([]), l3 = reactExports.useReducer(ut, { __demoMode: f3, popoverState: f3 ? 0 : 1, buttons: p3, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: reactExports.createRef(), afterPanelSentinel: reactExports.createRef(), afterButtonSentinel: reactExports.createRef() }), [{ popoverState: c2, button: d3, buttonId: r2, panel: s2, panelId: R2, beforePanelSentinel: m3, afterPanelSentinel: h3, afterButtonSentinel: P3 }, n2] = l3, v2 = n$4((J2 = T2.current) != null ? J2 : d3), g2 = reactExports.useMemo(() => {
    if (!d3 || !s2) return false;
    for (let E2 of document.querySelectorAll("body > *")) if (Number(E2 == null ? void 0 : E2.contains(d3)) ^ Number(E2 == null ? void 0 : E2.contains(s2))) return true;
    let t2 = b$4(), e2 = t2.indexOf(d3), u3 = (e2 + t2.length - 1) % t2.length, i2 = (e2 + 1) % t2.length, A2 = t2[u3], x2 = t2[i2];
    return !s2.contains(A2) && !s2.contains(x2);
  }, [d3, s2]), _2 = s$6(r2), L2 = s$6(R2), I2 = reactExports.useMemo(() => ({ buttonId: _2, panelId: L2, close: () => n2({ type: 1 }) }), [_2, L2, n2]), M2 = Me(), k2 = M2 == null ? void 0 : M2.registerPopover, B2 = o$4(() => {
    var t2;
    return (t2 = M2 == null ? void 0 : M2.isFocusWithinPopoverGroup()) != null ? t2 : (v2 == null ? void 0 : v2.activeElement) && ((d3 == null ? void 0 : d3.contains(v2.activeElement)) || (s2 == null ? void 0 : s2.contains(v2.activeElement)));
  });
  reactExports.useEffect(() => k2 == null ? void 0 : k2(I2), [k2, I2]);
  let [U2, O2] = te$1(), N2 = b$2(d3), w2 = R$1({ mainTreeNode: N2, portals: U2, defaultContainers: [d3, s2] });
  E$1(v2 == null ? void 0 : v2.defaultView, "focus", (t2) => {
    var e2, u3, i2, A2, x2, E2;
    t2.target !== window && t2.target instanceof HTMLElement && c2 === 0 && (B2() || d3 && s2 && (w2.contains(t2.target) || (u3 = (e2 = m3.current) == null ? void 0 : e2.contains) != null && u3.call(e2, t2.target) || (A2 = (i2 = h3.current) == null ? void 0 : i2.contains) != null && A2.call(i2, t2.target) || (E2 = (x2 = P3.current) == null ? void 0 : x2.contains) != null && E2.call(x2, t2.target) || n2({ type: 1 })));
  }, true), R$3(c2 === 0, w2.resolveContainers, (t2, e2) => {
    n2({ type: 1 }), A$2(e2, h$3.Loose) || (t2.preventDefault(), d3 == null || d3.focus());
  });
  let F2 = o$4((t2) => {
    n2({ type: 1 });
    let e2 = (() => t2 ? t2 instanceof HTMLElement ? t2 : "current" in t2 && t2.current instanceof HTMLElement ? t2.current : d3 : d3)();
    e2 == null || e2.focus();
  }), Q2 = reactExports.useMemo(() => ({ close: F2, isPortalled: g2 }), [F2, g2]), K2 = reactExports.useMemo(() => ({ open: c2 === 0, close: F2 }), [c2, F2]), Z3 = { ref: S2 }, $2 = L$2();
  return React$2.createElement(O$2, { node: N2 }, React$2.createElement(Me$1, null, React$2.createElement(ie.Provider, { value: null }, React$2.createElement(Ee$1.Provider, { value: l3 }, React$2.createElement(ue$1.Provider, { value: Q2 }, React$2.createElement(C$2, { value: F2 }, React$2.createElement(c$3, { value: u$6(c2, { [0]: i$2.Open, [1]: i$2.Closed }) }, React$2.createElement(O2, null, $2({ ourProps: Z3, theirProps: C2, slot: K2, defaultTag: it, name: "Popover" })))))))));
}
let Pt = "button";
function ft(o3, a3) {
  let f3 = reactExports.useId(), { id: C2 = `headlessui-popover-button-${f3}`, disabled: T2 = false, autoFocus: S2 = false, ...p3 } = o3, [l3, c2] = se$1("Popover.Button"), { isPortalled: d3 } = be$1("Popover.Button"), r2 = reactExports.useRef(null), s2 = `headlessui-focus-sentinel-${reactExports.useId()}`, R2 = Me(), m3 = R2 == null ? void 0 : R2.closeOthers, P3 = st() !== null;
  reactExports.useEffect(() => {
    if (!P3) return c2({ type: 3, buttonId: C2 }), () => {
      c2({ type: 3, buttonId: null });
    };
  }, [P3, C2, c2]);
  let [n2] = reactExports.useState(() => Symbol()), v2 = y$4(r2, a3, ye$1(), o$4((e2) => {
    if (!P3) {
      if (e2) l3.buttons.current.push(n2);
      else {
        let u3 = l3.buttons.current.indexOf(n2);
        u3 !== -1 && l3.buttons.current.splice(u3, 1);
      }
      l3.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e2 && c2({ type: 2, button: e2 });
    }
  })), g2 = y$4(r2, a3), _2 = n$4(r2), L2 = o$4((e2) => {
    var u3, i2, A2;
    if (P3) {
      if (l3.popoverState === 1) return;
      switch (e2.key) {
        case o$3.Space:
        case o$3.Enter:
          e2.preventDefault(), (i2 = (u3 = e2.target).click) == null || i2.call(u3), c2({ type: 1 }), (A2 = l3.button) == null || A2.focus();
          break;
      }
    } else switch (e2.key) {
      case o$3.Space:
      case o$3.Enter:
        e2.preventDefault(), e2.stopPropagation(), l3.popoverState === 1 && (m3 == null || m3(l3.buttonId)), c2({ type: 0 });
        break;
      case o$3.Escape:
        if (l3.popoverState !== 0) return m3 == null ? void 0 : m3(l3.buttonId);
        if (!r2.current || _2 != null && _2.activeElement && !r2.current.contains(_2.activeElement)) return;
        e2.preventDefault(), e2.stopPropagation(), c2({ type: 1 });
        break;
    }
  }), I2 = o$4((e2) => {
    P3 || e2.key === o$3.Space && e2.preventDefault();
  }), M2 = o$4((e2) => {
    var u3, i2;
    r$2(e2.currentTarget) || T2 || (P3 ? (c2({ type: 1 }), (u3 = l3.button) == null || u3.focus()) : (e2.preventDefault(), e2.stopPropagation(), l3.popoverState === 1 && (m3 == null || m3(l3.buttonId)), c2({ type: 0 }), (i2 = l3.button) == null || i2.focus()));
  }), k2 = o$4((e2) => {
    e2.preventDefault(), e2.stopPropagation();
  }), { isFocusVisible: B2, focusProps: U2 } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: S2 }), { isHovered: O2, hoverProps: N2 } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: T2 }), { pressed: w2, pressProps: Y2 } = w$4({ disabled: T2 }), F2 = l3.popoverState === 0, Q2 = reactExports.useMemo(() => ({ open: F2, active: w2 || F2, disabled: T2, hover: O2, focus: B2, autofocus: S2 }), [F2, O2, B2, w2, T2, S2]), K2 = e$3(o3, l3.button), Z3 = P3 ? _$3({ ref: g2, type: K2, onKeyDown: L2, onClick: M2, disabled: T2 || void 0, autoFocus: S2 }, U2, N2, Y2) : _$3({ ref: v2, id: l3.buttonId, type: K2, "aria-expanded": l3.popoverState === 0, "aria-controls": l3.panel ? l3.panelId : void 0, disabled: T2 || void 0, autoFocus: S2, onKeyDown: L2, onKeyUp: I2, onClick: M2, onMouseDown: k2 }, U2, N2, Y2), $2 = u$3(), J2 = o$4(() => {
    let e2 = l3.panel;
    if (!e2) return;
    function u3() {
      u$6($2.current, { [a$2.Forwards]: () => P$2(e2, F$2.First), [a$2.Backwards]: () => P$2(e2, F$2.Last) }) === T$3.Error && P$2(b$4().filter((A2) => A2.dataset.headlessuiFocusGuard !== "true"), u$6($2.current, { [a$2.Forwards]: F$2.Next, [a$2.Backwards]: F$2.Previous }), { relativeTo: l3.button });
    }
    u3();
  }), t2 = L$2();
  return React$2.createElement(React$2.Fragment, null, t2({ ourProps: Z3, theirProps: p3, slot: Q2, defaultTag: Pt, name: "Popover.Button" }), F2 && !P3 && d3 && React$2.createElement(f$6, { id: s2, ref: l3.afterButtonSentinel, features: s$5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: J2 }));
}
let ct = "div", vt = O$4.RenderStrategy | O$4.Static;
function Oe(o3, a3) {
  let f3 = reactExports.useId(), { id: C2 = `headlessui-popover-backdrop-${f3}`, transition: T2 = false, ...S2 } = o3, [{ popoverState: p3 }, l3] = se$1("Popover.Backdrop"), [c2, d3] = reactExports.useState(null), r2 = y$4(a3, d3), s2 = u$4(), [R2, m3] = x$1(T2, c2, s2 !== null ? (s2 & i$2.Open) === i$2.Open : p3 === 0), h3 = o$4((g2) => {
    if (r$2(g2.currentTarget)) return g2.preventDefault();
    l3({ type: 1 });
  }), P3 = reactExports.useMemo(() => ({ open: p3 === 0 }), [p3]), n2 = { ref: r2, id: C2, "aria-hidden": true, onClick: h3, ...R$2(m3) };
  return L$2()({ ourProps: n2, theirProps: S2, slot: P3, defaultTag: ct, features: vt, visible: R2, name: "Popover.Backdrop" });
}
let Tt = "div", mt = O$4.RenderStrategy | O$4.Static;
function yt(o3, a3) {
  let f3 = reactExports.useId(), { id: C2 = `headlessui-popover-panel-${f3}`, focus: T2 = false, anchor: S2, portal: p3 = false, modal: l3 = false, transition: c2 = false, ...d3 } = o3, [r2, s2] = se$1("Popover.Panel"), { close: R2, isPortalled: m3 } = be$1("Popover.Panel"), h3 = `headlessui-focus-sentinel-before-${f3}`, P3 = `headlessui-focus-sentinel-after-${f3}`, n2 = reactExports.useRef(null), v2 = xe$1(S2), [g2, _2] = Re$1(v2), L2 = be$2();
  v2 && (p3 = true);
  let [I2, M2] = reactExports.useState(null), k2 = y$4(n2, a3, v2 ? g2 : null, o$4((t2) => s2({ type: 4, panel: t2 })), M2), B2 = n$4(n2);
  n$6(() => (s2({ type: 5, panelId: C2 }), () => {
    s2({ type: 5, panelId: null });
  }), [C2, s2]);
  let U2 = u$4(), [O2, N2] = x$1(c2, I2, U2 !== null ? (U2 & i$2.Open) === i$2.Open : r2.popoverState === 0);
  m$3(O2, r2.button, () => {
    s2({ type: 1 });
  });
  let w2 = r2.__demoMode ? false : l3 && O2;
  f$3(w2, B2);
  let Y2 = o$4((t2) => {
    var e2;
    switch (t2.key) {
      case o$3.Escape:
        if (r2.popoverState !== 0 || !n2.current || B2 != null && B2.activeElement && !n2.current.contains(B2.activeElement)) return;
        t2.preventDefault(), t2.stopPropagation(), s2({ type: 1 }), (e2 = r2.button) == null || e2.focus();
        break;
    }
  });
  reactExports.useEffect(() => {
    var t2;
    o3.static || r2.popoverState === 1 && ((t2 = o3.unmount) == null || t2) && s2({ type: 4, panel: null });
  }, [r2.popoverState, o3.unmount, o3.static, s2]), reactExports.useEffect(() => {
    if (r2.__demoMode || !T2 || r2.popoverState !== 0 || !n2.current) return;
    let t2 = B2 == null ? void 0 : B2.activeElement;
    n2.current.contains(t2) || P$2(n2.current, F$2.First);
  }, [r2.__demoMode, T2, n2.current, r2.popoverState]);
  let F2 = reactExports.useMemo(() => ({ open: r2.popoverState === 0, close: R2 }), [r2.popoverState, R2]), Q2 = _$3(v2 ? L2() : {}, { ref: k2, id: C2, onKeyDown: Y2, onBlur: T2 && r2.popoverState === 0 ? (t2) => {
    var u3, i2, A2, x2, E2;
    let e2 = t2.relatedTarget;
    e2 && n2.current && ((u3 = n2.current) != null && u3.contains(e2) || (s2({ type: 1 }), ((A2 = (i2 = r2.beforePanelSentinel.current) == null ? void 0 : i2.contains) != null && A2.call(i2, e2) || (E2 = (x2 = r2.afterPanelSentinel.current) == null ? void 0 : x2.contains) != null && E2.call(x2, e2)) && e2.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1, style: { ...d3.style, ..._2, "--button-width": d$4(r2.button, true).width }, ...R$2(N2) }), K2 = u$3(), Z3 = o$4(() => {
    let t2 = n2.current;
    if (!t2) return;
    function e2() {
      u$6(K2.current, { [a$2.Forwards]: () => {
        var i2;
        P$2(t2, F$2.First) === T$3.Error && ((i2 = r2.afterPanelSentinel.current) == null || i2.focus());
      }, [a$2.Backwards]: () => {
        var u3;
        (u3 = r2.button) == null || u3.focus({ preventScroll: true });
      } });
    }
    e2();
  }), $2 = o$4(() => {
    let t2 = n2.current;
    if (!t2) return;
    function e2() {
      u$6(K2.current, { [a$2.Forwards]: () => {
        if (!r2.button) return;
        let u3 = b$4(), i2 = u3.indexOf(r2.button), A2 = u3.slice(0, i2 + 1), E2 = [...u3.slice(i2 + 1), ...A2];
        for (let de2 of E2.slice()) if (de2.dataset.headlessuiFocusGuard === "true" || I2 != null && I2.contains(de2)) {
          let Se2 = E2.indexOf(de2);
          Se2 !== -1 && E2.splice(Se2, 1);
        }
        P$2(E2, F$2.First, { sorted: false });
      }, [a$2.Backwards]: () => {
        var i2;
        P$2(t2, F$2.Previous) === T$3.Error && ((i2 = r2.button) == null || i2.focus());
      } });
    }
    e2();
  }), J2 = L$2();
  return React$2.createElement(s$3, null, React$2.createElement(ie.Provider, { value: C2 }, React$2.createElement(ue$1.Provider, { value: { close: R2, isPortalled: m3 } }, React$2.createElement(re$1, { enabled: p3 ? o3.static || O2 : false }, O2 && m3 && React$2.createElement(f$6, { id: h3, ref: r2.beforePanelSentinel, features: s$5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: Z3 }), J2({ ourProps: Q2, theirProps: d3, slot: F2, defaultTag: Tt, features: mt, visible: O2, name: "Popover.Panel" }), O2 && m3 && React$2.createElement(f$6, { id: P3, ref: r2.afterPanelSentinel, features: s$5.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: $2 })))));
}
let Et = "div";
function bt(o3, a3) {
  let f3 = reactExports.useRef(null), C2 = y$4(f3, a3), [T2, S2] = reactExports.useState([]), p3 = o$4((P3) => {
    S2((n2) => {
      let v2 = n2.indexOf(P3);
      if (v2 !== -1) {
        let g2 = n2.slice();
        return g2.splice(v2, 1), g2;
      }
      return n2;
    });
  }), l3 = o$4((P3) => (S2((n2) => [...n2, P3]), () => p3(P3))), c2 = o$4(() => {
    var v2;
    let P3 = u$7(f3);
    if (!P3) return false;
    let n2 = P3.activeElement;
    return (v2 = f3.current) != null && v2.contains(n2) ? true : T2.some((g2) => {
      var _2, L2;
      return ((_2 = P3.getElementById(g2.buttonId.current)) == null ? void 0 : _2.contains(n2)) || ((L2 = P3.getElementById(g2.panelId.current)) == null ? void 0 : L2.contains(n2));
    });
  }), d3 = o$4((P3) => {
    for (let n2 of T2) n2.buttonId.current !== P3 && n2.close();
  }), r2 = reactExports.useMemo(() => ({ registerPopover: l3, unregisterPopover: p3, isFocusWithinPopoverGroup: c2, closeOthers: d3 }), [l3, p3, c2, d3]), s2 = reactExports.useMemo(() => ({}), []), R2 = o3, m3 = { ref: C2 }, h3 = L$2();
  return React$2.createElement(O$2, null, React$2.createElement(ge$1.Provider, { value: r2 }, h3({ ourProps: m3, theirProps: R2, slot: s2, defaultTag: Et, name: "Popover.Group" })));
}
let gt = K$1(dt), St = K$1(ft), At = K$1(Oe), Ct = K$1(Oe), Rt = K$1(yt), Bt = K$1(bt), lo = Object.assign(gt, { Button: St, Backdrop: Ct, Overlay: At, Panel: Rt, Group: Bt });
function e$1(e2, t2) {
  var i2 = {};
  for (var o22 in e2) Object.prototype.hasOwnProperty.call(e2, o22) && t2.indexOf(o22) < 0 && (i2[o22] = e2[o22]);
  if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
    var n2 = 0;
    for (o22 = Object.getOwnPropertySymbols(e2); n2 < o22.length; n2++) t2.indexOf(o22[n2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, o22[n2]) && (i2[o22[n2]] = e2[o22[n2]]);
  }
  return i2;
}
"function" == typeof SuppressedError && SuppressedError;
var t$1 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function i$1(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function o$1(e2, t2) {
  return e2(t2 = { exports: {} }, t2.exports), t2.exports;
}
var n$2 = o$1(function(e2, t2) {
  Object.defineProperty(t2, "__esModule", { value: true });
  var i2 = function() {
    function e3() {
      var e4 = this;
      this.locked = /* @__PURE__ */ new Map(), this.addToLocked = function(t3, i3) {
        var o22 = e4.locked.get(t3);
        void 0 === o22 ? void 0 === i3 ? e4.locked.set(t3, []) : e4.locked.set(t3, [i3]) : void 0 !== i3 && (o22.unshift(i3), e4.locked.set(t3, o22));
      }, this.isLocked = function(t3) {
        return e4.locked.has(t3);
      }, this.lock = function(t3) {
        return new Promise(function(i3, o22) {
          e4.isLocked(t3) ? e4.addToLocked(t3, i3) : (e4.addToLocked(t3), i3());
        });
      }, this.unlock = function(t3) {
        var i3 = e4.locked.get(t3);
        if (void 0 !== i3 && 0 !== i3.length) {
          var o22 = i3.pop();
          e4.locked.set(t3, i3), void 0 !== o22 && setTimeout(o22, 0);
        } else e4.locked.delete(t3);
      };
    }
    return e3.getInstance = function() {
      return void 0 === e3.instance && (e3.instance = new e3()), e3.instance;
    }, e3;
  }();
  t2.default = function() {
    return i2.getInstance();
  };
});
i$1(n$2);
var a$1 = i$1(o$1(function(e2, i2) {
  var o22 = t$1 && t$1.__awaiter || function(e3, t2, i3, o3) {
    return new (i3 || (i3 = Promise))(function(n2, a3) {
      function r3(e4) {
        try {
          c3(o3.next(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function s3(e4) {
        try {
          c3(o3.throw(e4));
        } catch (e5) {
          a3(e5);
        }
      }
      function c3(e4) {
        e4.done ? n2(e4.value) : new i3(function(t3) {
          t3(e4.value);
        }).then(r3, s3);
      }
      c3((o3 = o3.apply(e3, t2 || [])).next());
    });
  }, a22 = t$1 && t$1.__generator || function(e3, t2) {
    var i3, o3, n2, a3, r3 = { label: 0, sent: function() {
      if (1 & n2[0]) throw n2[1];
      return n2[1];
    }, trys: [], ops: [] };
    return a3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (a3[Symbol.iterator] = function() {
      return this;
    }), a3;
    function s3(a4) {
      return function(s4) {
        return function(a5) {
          if (i3) throw new TypeError("Generator is already executing.");
          for (; r3; ) try {
            if (i3 = 1, o3 && (n2 = 2 & a5[0] ? o3.return : a5[0] ? o3.throw || ((n2 = o3.return) && n2.call(o3), 0) : o3.next) && !(n2 = n2.call(o3, a5[1])).done) return n2;
            switch (o3 = 0, n2 && (a5 = [2 & a5[0], n2.value]), a5[0]) {
              case 0:
              case 1:
                n2 = a5;
                break;
              case 4:
                return r3.label++, { value: a5[1], done: false };
              case 5:
                r3.label++, o3 = a5[1], a5 = [0];
                continue;
              case 7:
                a5 = r3.ops.pop(), r3.trys.pop();
                continue;
              default:
                if (!(n2 = r3.trys, (n2 = n2.length > 0 && n2[n2.length - 1]) || 6 !== a5[0] && 2 !== a5[0])) {
                  r3 = 0;
                  continue;
                }
                if (3 === a5[0] && (!n2 || a5[1] > n2[0] && a5[1] < n2[3])) {
                  r3.label = a5[1];
                  break;
                }
                if (6 === a5[0] && r3.label < n2[1]) {
                  r3.label = n2[1], n2 = a5;
                  break;
                }
                if (n2 && r3.label < n2[2]) {
                  r3.label = n2[2], r3.ops.push(a5);
                  break;
                }
                n2[2] && r3.ops.pop(), r3.trys.pop();
                continue;
            }
            a5 = t2.call(e3, r3);
          } catch (e4) {
            a5 = [6, e4], o3 = 0;
          } finally {
            i3 = n2 = 0;
          }
          if (5 & a5[0]) throw a5[1];
          return { value: a5[0] ? a5[1] : void 0, done: true };
        }([a4, s4]);
      };
    }
  }, r2 = t$1;
  Object.defineProperty(i2, "__esModule", { value: true });
  var s2 = "browser-tabs-lock-key", c2 = { key: function(e3) {
    return o22(r2, void 0, void 0, function() {
      return a22(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, getItem: function(e3) {
    return o22(r2, void 0, void 0, function() {
      return a22(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, clear: function() {
    return o22(r2, void 0, void 0, function() {
      return a22(this, function(e3) {
        return [2, window.localStorage.clear()];
      });
    });
  }, removeItem: function(e3) {
    return o22(r2, void 0, void 0, function() {
      return a22(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, setItem: function(e3, t2) {
    return o22(r2, void 0, void 0, function() {
      return a22(this, function(e4) {
        throw new Error("Unsupported");
      });
    });
  }, keySync: function(e3) {
    return window.localStorage.key(e3);
  }, getItemSync: function(e3) {
    return window.localStorage.getItem(e3);
  }, clearSync: function() {
    return window.localStorage.clear();
  }, removeItemSync: function(e3) {
    return window.localStorage.removeItem(e3);
  }, setItemSync: function(e3, t2) {
    return window.localStorage.setItem(e3, t2);
  } };
  function d22(e3) {
    return new Promise(function(t2) {
      return setTimeout(t2, e3);
    });
  }
  function u22(e3) {
    for (var t2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", i3 = "", o3 = 0; o3 < e3; o3++) {
      i3 += t2[Math.floor(Math.random() * t2.length)];
    }
    return i3;
  }
  var l22 = function() {
    function e3(t2) {
      this.acquiredIatSet = /* @__PURE__ */ new Set(), this.storageHandler = void 0, this.id = Date.now().toString() + u22(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), this.storageHandler = t2, void 0 === e3.waiters && (e3.waiters = []);
    }
    return e3.prototype.acquireLock = function(t2, i3) {
      return void 0 === i3 && (i3 = 5e3), o22(this, void 0, void 0, function() {
        var o3, n2, r3, l3, h22, p22, m22;
        return a22(this, function(a3) {
          switch (a3.label) {
            case 0:
              o3 = Date.now() + u22(4), n2 = Date.now() + i3, r3 = s2 + "-" + t2, l3 = void 0 === this.storageHandler ? c2 : this.storageHandler, a3.label = 1;
            case 1:
              return Date.now() < n2 ? [4, d22(30)] : [3, 8];
            case 2:
              return a3.sent(), null !== l3.getItemSync(r3) ? [3, 5] : (h22 = this.id + "-" + t2 + "-" + o3, [4, d22(Math.floor(25 * Math.random()))]);
            case 3:
              return a3.sent(), l3.setItemSync(r3, JSON.stringify({ id: this.id, iat: o3, timeoutKey: h22, timeAcquired: Date.now(), timeRefreshed: Date.now() })), [4, d22(30)];
            case 4:
              return a3.sent(), null !== (p22 = l3.getItemSync(r3)) && (m22 = JSON.parse(p22)).id === this.id && m22.iat === o3 ? (this.acquiredIatSet.add(o3), this.refreshLockWhileAcquired(r3, o3), [2, true]) : [3, 7];
            case 5:
              return e3.lockCorrector(void 0 === this.storageHandler ? c2 : this.storageHandler), [4, this.waitForSomethingToChange(n2)];
            case 6:
              a3.sent(), a3.label = 7;
            case 7:
              return o3 = Date.now() + u22(4), [3, 1];
            case 8:
              return [2, false];
          }
        });
      });
    }, e3.prototype.refreshLockWhileAcquired = function(e4, t2) {
      return o22(this, void 0, void 0, function() {
        var i3 = this;
        return a22(this, function(r3) {
          return setTimeout(function() {
            return o22(i3, void 0, void 0, function() {
              var i4, o3, r4;
              return a22(this, function(a3) {
                switch (a3.label) {
                  case 0:
                    return [4, n$2.default().lock(t2)];
                  case 1:
                    return a3.sent(), this.acquiredIatSet.has(t2) ? (i4 = void 0 === this.storageHandler ? c2 : this.storageHandler, null === (o3 = i4.getItemSync(e4)) ? (n$2.default().unlock(t2), [2]) : ((r4 = JSON.parse(o3)).timeRefreshed = Date.now(), i4.setItemSync(e4, JSON.stringify(r4)), n$2.default().unlock(t2), this.refreshLockWhileAcquired(e4, t2), [2])) : (n$2.default().unlock(t2), [2]);
                }
              });
            });
          }, 1e3), [2];
        });
      });
    }, e3.prototype.waitForSomethingToChange = function(t2) {
      return o22(this, void 0, void 0, function() {
        return a22(this, function(i3) {
          switch (i3.label) {
            case 0:
              return [4, new Promise(function(i4) {
                var o3 = false, n2 = Date.now(), a3 = false;
                function r3() {
                  if (a3 || (window.removeEventListener("storage", r3), e3.removeFromWaiting(r3), clearTimeout(s3), a3 = true), !o3) {
                    o3 = true;
                    var t3 = 50 - (Date.now() - n2);
                    t3 > 0 ? setTimeout(i4, t3) : i4(null);
                  }
                }
                window.addEventListener("storage", r3), e3.addToWaiting(r3);
                var s3 = setTimeout(r3, Math.max(0, t2 - Date.now()));
              })];
            case 1:
              return i3.sent(), [2];
          }
        });
      });
    }, e3.addToWaiting = function(t2) {
      this.removeFromWaiting(t2), void 0 !== e3.waiters && e3.waiters.push(t2);
    }, e3.removeFromWaiting = function(t2) {
      void 0 !== e3.waiters && (e3.waiters = e3.waiters.filter(function(e4) {
        return e4 !== t2;
      }));
    }, e3.notifyWaiters = function() {
      void 0 !== e3.waiters && e3.waiters.slice().forEach(function(e4) {
        return e4();
      });
    }, e3.prototype.releaseLock = function(e4) {
      return o22(this, void 0, void 0, function() {
        return a22(this, function(t2) {
          switch (t2.label) {
            case 0:
              return [4, this.releaseLock__private__(e4)];
            case 1:
              return [2, t2.sent()];
          }
        });
      });
    }, e3.prototype.releaseLock__private__ = function(t2) {
      return o22(this, void 0, void 0, function() {
        var i3, o3, r3, d3;
        return a22(this, function(a3) {
          switch (a3.label) {
            case 0:
              return i3 = void 0 === this.storageHandler ? c2 : this.storageHandler, o3 = s2 + "-" + t2, null === (r3 = i3.getItemSync(o3)) ? [2] : (d3 = JSON.parse(r3)).id !== this.id ? [3, 2] : [4, n$2.default().lock(d3.iat)];
            case 1:
              a3.sent(), this.acquiredIatSet.delete(d3.iat), i3.removeItemSync(o3), n$2.default().unlock(d3.iat), e3.notifyWaiters(), a3.label = 2;
            case 2:
              return [2];
          }
        });
      });
    }, e3.lockCorrector = function(t2) {
      for (var i3 = Date.now() - 5e3, o3 = t2, n2 = [], a3 = 0; ; ) {
        var r3 = o3.keySync(a3);
        if (null === r3) break;
        n2.push(r3), a3++;
      }
      for (var c3 = false, d3 = 0; d3 < n2.length; d3++) {
        var u3 = n2[d3];
        if (u3.includes(s2)) {
          var l3 = o3.getItemSync(u3);
          if (null !== l3) {
            var h22 = JSON.parse(l3);
            (void 0 === h22.timeRefreshed && h22.timeAcquired < i3 || void 0 !== h22.timeRefreshed && h22.timeRefreshed < i3) && (o3.removeItemSync(u3), c3 = true);
          }
        }
      }
      c3 && e3.notifyWaiters();
    }, e3.waiters = void 0, e3;
  }();
  i2.default = l22;
}));
const r = { timeoutInSeconds: 60 }, s$1 = { name: "auth0-spa-js", version: "2.1.3" }, c$1 = () => Date.now();
let d$1 = class d extends Error {
  constructor(e2, t2) {
    super(t2), this.error = e2, this.error_description = t2, Object.setPrototypeOf(this, d.prototype);
  }
  static fromPayload({ error: e2, error_description: t2 }) {
    return new d(e2, t2);
  }
};
let u$2 = class u extends d$1 {
  constructor(e2, t2, i2, o22 = null) {
    super(e2, t2), this.state = i2, this.appState = o22, Object.setPrototypeOf(this, u.prototype);
  }
};
let l$1 = class l extends d$1 {
  constructor() {
    super("timeout", "Timeout"), Object.setPrototypeOf(this, l.prototype);
  }
};
let h$2 = class h extends l$1 {
  constructor(e2) {
    super(), this.popup = e2, Object.setPrototypeOf(this, h.prototype);
  }
};
let p$1 = class p extends d$1 {
  constructor(e2) {
    super("cancelled", "Popup closed"), this.popup = e2, Object.setPrototypeOf(this, p.prototype);
  }
};
let m$1 = class m extends d$1 {
  constructor(e2, t2, i2) {
    super(e2, t2), this.mfa_token = i2, Object.setPrototypeOf(this, m.prototype);
  }
};
let f$1 = class f extends d$1 {
  constructor(e2, t2) {
    super("missing_refresh_token", `Missing Refresh Token (audience: '${g$1(e2, ["default"])}', scope: '${g$1(t2)}')`), this.audience = e2, this.scope = t2, Object.setPrototypeOf(this, f.prototype);
  }
};
function g$1(e2, t2 = []) {
  return e2 && !t2.includes(e2) ? e2 : "";
}
const w$1 = () => window.crypto, y = () => {
  const e2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.";
  let t2 = "";
  return Array.from(w$1().getRandomValues(new Uint8Array(43))).forEach((i2) => t2 += e2[i2 % e2.length]), t2;
}, k = (e2) => btoa(e2), v$1 = (t2) => {
  var { clientId: i2 } = t2, o22 = e$1(t2, ["clientId"]);
  return new URLSearchParams(((e2) => Object.keys(e2).filter((t3) => void 0 !== e2[t3]).reduce((t3, i3) => Object.assign(Object.assign({}, t3), { [i3]: e2[i3] }), {}))(Object.assign({ client_id: i2 }, o22))).toString();
}, b$1 = (e2) => ((e3) => decodeURIComponent(atob(e3).split("").map((e4) => "%" + ("00" + e4.charCodeAt(0).toString(16)).slice(-2)).join("")))(e2.replace(/_/g, "/").replace(/-/g, "+")), _$1 = async (e2, t2) => {
  const i2 = await fetch(e2, t2);
  return { ok: i2.ok, json: await i2.json() };
}, I$1 = async (e2, t2, i2) => {
  const o22 = new AbortController();
  let n2;
  return t2.signal = o22.signal, Promise.race([_$1(e2, t2), new Promise((e3, t3) => {
    n2 = setTimeout(() => {
      o22.abort(), t3(new Error("Timeout when executing 'fetch'"));
    }, i2);
  })]).finally(() => {
    clearTimeout(n2);
  });
}, S$1 = async (e2, t2, i2, o22, n2, a22, r2) => {
  return s2 = { auth: { audience: t2, scope: i2 }, timeout: n2, fetchUrl: e2, fetchOptions: o22, useFormData: r2 }, c2 = a22, new Promise(function(e3, t3) {
    const i3 = new MessageChannel();
    i3.port1.onmessage = function(o3) {
      o3.data.error ? t3(new Error(o3.data.error)) : e3(o3.data), i3.port1.close();
    }, c2.postMessage(s2, [i3.port2]);
  });
  var s2, c2;
}, O$1 = async (e2, t2, i2, o22, n2, a22, r2 = 1e4) => n2 ? S$1(e2, t2, i2, o22, r2, n2, a22) : I$1(e2, o22, r2);
async function T$1(t2, i2) {
  var { baseUrl: o22, timeout: n2, audience: a22, scope: r2, auth0Client: c2, useFormData: u22 } = t2, l22 = e$1(t2, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
  const h22 = u22 ? v$1(l22) : JSON.stringify(l22);
  return await async function(t3, i3, o3, n3, a3, r3, s2) {
    let c3, u3 = null;
    for (let e2 = 0; e2 < 3; e2++) try {
      c3 = await O$1(t3, o3, n3, a3, r3, s2, i3), u3 = null;
      break;
    } catch (e3) {
      u3 = e3;
    }
    if (u3) throw u3;
    const l3 = c3.json, { error: h3, error_description: p22 } = l3, g2 = e$1(l3, ["error", "error_description"]), { ok: w2 } = c3;
    if (!w2) {
      const e2 = p22 || `HTTP error. Unable to fetch ${t3}`;
      if ("mfa_required" === h3) throw new m$1(h3, e2, g2.mfa_token);
      if ("missing_refresh_token" === h3) throw new f$1(o3, n3);
      throw new d$1(h3 || "request_error", e2);
    }
    return g2;
  }(`${o22}/oauth/token`, n2, a22 || "default", r2, { method: "POST", body: h22, headers: { "Content-Type": u22 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(c2 || s$1)) } }, i2, u22);
}
const j$1 = (...e2) => {
  return (t2 = e2.filter(Boolean).join(" ").trim().split(/\s+/), Array.from(new Set(t2))).join(" ");
  var t2;
};
class C {
  constructor(e2, t2 = "@@auth0spajs@@", i2) {
    this.prefix = t2, this.suffix = i2, this.clientId = e2.clientId, this.scope = e2.scope, this.audience = e2.audience;
  }
  toKey() {
    return [this.prefix, this.clientId, this.audience, this.scope, this.suffix].filter(Boolean).join("::");
  }
  static fromKey(e2) {
    const [t2, i2, o22, n2] = e2.split("::");
    return new C({ clientId: i2, scope: n2, audience: o22 }, t2);
  }
  static fromCacheEntry(e2) {
    const { scope: t2, audience: i2, client_id: o22 } = e2;
    return new C({ scope: t2, audience: i2, clientId: o22 });
  }
}
class z {
  set(e2, t2) {
    localStorage.setItem(e2, JSON.stringify(t2));
  }
  get(e2) {
    const t2 = window.localStorage.getItem(e2);
    if (t2) try {
      return JSON.parse(t2);
    } catch (e3) {
      return;
    }
  }
  remove(e2) {
    localStorage.removeItem(e2);
  }
  allKeys() {
    return Object.keys(window.localStorage).filter((e2) => e2.startsWith("@@auth0spajs@@"));
  }
}
let P$1 = class P {
  constructor() {
    this.enclosedCache = /* @__PURE__ */ function() {
      let e2 = {};
      return { set(t2, i2) {
        e2[t2] = i2;
      }, get(t2) {
        const i2 = e2[t2];
        if (i2) return i2;
      }, remove(t2) {
        delete e2[t2];
      }, allKeys: () => Object.keys(e2) };
    }();
  }
};
class x {
  constructor(e2, t2, i2) {
    this.cache = e2, this.keyManifest = t2, this.nowProvider = i2 || c$1;
  }
  async setIdToken(e2, t2, i2) {
    var o22;
    const n2 = this.getIdTokenCacheKey(e2);
    await this.cache.set(n2, { id_token: t2, decodedToken: i2 }), await (null === (o22 = this.keyManifest) || void 0 === o22 ? void 0 : o22.add(n2));
  }
  async getIdToken(e2) {
    const t2 = await this.cache.get(this.getIdTokenCacheKey(e2.clientId));
    if (!t2 && e2.scope && e2.audience) {
      const t3 = await this.get(e2);
      if (!t3) return;
      if (!t3.id_token || !t3.decodedToken) return;
      return { id_token: t3.id_token, decodedToken: t3.decodedToken };
    }
    if (t2) return { id_token: t2.id_token, decodedToken: t2.decodedToken };
  }
  async get(e2, t2 = 0) {
    var i2;
    let o22 = await this.cache.get(e2.toKey());
    if (!o22) {
      const t3 = await this.getCacheKeys();
      if (!t3) return;
      const i3 = this.matchExistingCacheKey(e2, t3);
      i3 && (o22 = await this.cache.get(i3));
    }
    if (!o22) return;
    const n2 = await this.nowProvider(), a22 = Math.floor(n2 / 1e3);
    return o22.expiresAt - t2 < a22 ? o22.body.refresh_token ? (o22.body = { refresh_token: o22.body.refresh_token }, await this.cache.set(e2.toKey(), o22), o22.body) : (await this.cache.remove(e2.toKey()), void await (null === (i2 = this.keyManifest) || void 0 === i2 ? void 0 : i2.remove(e2.toKey()))) : o22.body;
  }
  async set(e2) {
    var t2;
    const i2 = new C({ clientId: e2.client_id, scope: e2.scope, audience: e2.audience }), o22 = await this.wrapCacheEntry(e2);
    await this.cache.set(i2.toKey(), o22), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.add(i2.toKey()));
  }
  async clear(e2) {
    var t2;
    const i2 = await this.getCacheKeys();
    i2 && (await i2.filter((t3) => !e2 || t3.includes(e2)).reduce(async (e3, t3) => {
      await e3, await this.cache.remove(t3);
    }, Promise.resolve()), await (null === (t2 = this.keyManifest) || void 0 === t2 ? void 0 : t2.clear()));
  }
  async wrapCacheEntry(e2) {
    const t2 = await this.nowProvider();
    return { body: e2, expiresAt: Math.floor(t2 / 1e3) + e2.expires_in };
  }
  async getCacheKeys() {
    var e2;
    return this.keyManifest ? null === (e2 = await this.keyManifest.get()) || void 0 === e2 ? void 0 : e2.keys : this.cache.allKeys ? this.cache.allKeys() : void 0;
  }
  getIdTokenCacheKey(e2) {
    return new C({ clientId: e2 }, "@@auth0spajs@@", "@@user@@").toKey();
  }
  matchExistingCacheKey(e2, t2) {
    return t2.filter((t3) => {
      var i2;
      const o22 = C.fromKey(t3), n2 = new Set(o22.scope && o22.scope.split(" ")), a22 = (null === (i2 = e2.scope) || void 0 === i2 ? void 0 : i2.split(" ")) || [], r2 = o22.scope && a22.reduce((e3, t4) => e3 && n2.has(t4), true);
      return "@@auth0spajs@@" === o22.prefix && o22.clientId === e2.clientId && o22.audience === e2.audience && r2;
    })[0];
  }
}
let Z$1 = class Z {
  constructor(e2, t2, i2) {
    this.storage = e2, this.clientId = t2, this.cookieDomain = i2, this.storageKey = `a0.spajs.txs.${this.clientId}`;
  }
  create(e2) {
    this.storage.save(this.storageKey, e2, { daysUntilExpire: 1, cookieDomain: this.cookieDomain });
  }
  get() {
    return this.storage.get(this.storageKey);
  }
  remove() {
    this.storage.remove(this.storageKey, { cookieDomain: this.cookieDomain });
  }
};
const K = (e2) => "number" == typeof e2, W$1 = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"], E = (e2) => {
  if (!e2.id_token) throw new Error("ID token is required but missing");
  const t2 = ((e3) => {
    const t3 = e3.split("."), [i3, o3, n3] = t3;
    if (3 !== t3.length || !i3 || !o3 || !n3) throw new Error("ID token could not be decoded");
    const a22 = JSON.parse(b$1(o3)), r2 = { __raw: e3 }, s2 = {};
    return Object.keys(a22).forEach((e4) => {
      r2[e4] = a22[e4], W$1.includes(e4) || (s2[e4] = a22[e4]);
    }), { encoded: { header: i3, payload: o3, signature: n3 }, header: JSON.parse(b$1(i3)), claims: r2, user: s2 };
  })(e2.id_token);
  if (!t2.claims.iss) throw new Error("Issuer (iss) claim must be a string present in the ID token");
  if (t2.claims.iss !== e2.iss) throw new Error(`Issuer (iss) claim mismatch in the ID token; expected "${e2.iss}", found "${t2.claims.iss}"`);
  if (!t2.user.sub) throw new Error("Subject (sub) claim must be a string present in the ID token");
  if ("RS256" !== t2.header.alg) throw new Error(`Signature algorithm of "${t2.header.alg}" is not supported. Expected the ID token to be signed with "RS256".`);
  if (!t2.claims.aud || "string" != typeof t2.claims.aud && !Array.isArray(t2.claims.aud)) throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
  if (Array.isArray(t2.claims.aud)) {
    if (!t2.claims.aud.includes(e2.aud)) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but was not one of "${t2.claims.aud.join(", ")}"`);
    if (t2.claims.aud.length > 1) {
      if (!t2.claims.azp) throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
      if (t2.claims.azp !== e2.aud) throw new Error(`Authorized Party (azp) claim mismatch in the ID token; expected "${e2.aud}", found "${t2.claims.azp}"`);
    }
  } else if (t2.claims.aud !== e2.aud) throw new Error(`Audience (aud) claim mismatch in the ID token; expected "${e2.aud}" but found "${t2.claims.aud}"`);
  if (e2.nonce) {
    if (!t2.claims.nonce) throw new Error("Nonce (nonce) claim must be a string present in the ID token");
    if (t2.claims.nonce !== e2.nonce) throw new Error(`Nonce (nonce) claim mismatch in the ID token; expected "${e2.nonce}", found "${t2.claims.nonce}"`);
  }
  if (e2.max_age && !K(t2.claims.auth_time)) throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
  if (null == t2.claims.exp || !K(t2.claims.exp)) throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
  if (!K(t2.claims.iat)) throw new Error("Issued At (iat) claim must be a number present in the ID token");
  const i2 = e2.leeway || 60, o22 = new Date(e2.now || Date.now()), n2 = /* @__PURE__ */ new Date(0);
  if (n2.setUTCSeconds(t2.claims.exp + i2), o22 > n2) throw new Error(`Expiration Time (exp) claim error in the ID token; current time (${o22}) is after expiration time (${n2})`);
  if (null != t2.claims.nbf && K(t2.claims.nbf)) {
    const e3 = /* @__PURE__ */ new Date(0);
    if (e3.setUTCSeconds(t2.claims.nbf - i2), o22 < e3) throw new Error(`Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Current time (${o22}) is before ${e3}`);
  }
  if (null != t2.claims.auth_time && K(t2.claims.auth_time)) {
    const n3 = /* @__PURE__ */ new Date(0);
    if (n3.setUTCSeconds(parseInt(t2.claims.auth_time) + e2.max_age + i2), o22 > n3) throw new Error(`Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Current time (${o22}) is after last auth at ${n3}`);
  }
  if (e2.organization) {
    const i3 = e2.organization.trim();
    if (i3.startsWith("org_")) {
      const e3 = i3;
      if (!t2.claims.org_id) throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
      if (e3 !== t2.claims.org_id) throw new Error(`Organization ID (org_id) claim mismatch in the ID token; expected "${e3}", found "${t2.claims.org_id}"`);
    } else {
      const e3 = i3.toLowerCase();
      if (!t2.claims.org_name) throw new Error("Organization Name (org_name) claim must be a string present in the ID token");
      if (e3 !== t2.claims.org_name) throw new Error(`Organization Name (org_name) claim mismatch in the ID token; expected "${e3}", found "${t2.claims.org_name}"`);
    }
  }
  return t2;
};
var R = o$1(function(e2, i2) {
  var o22 = t$1 && t$1.__assign || function() {
    return o22 = Object.assign || function(e3) {
      for (var t2, i3 = 1, o3 = arguments.length; i3 < o3; i3++) for (var n3 in t2 = arguments[i3]) Object.prototype.hasOwnProperty.call(t2, n3) && (e3[n3] = t2[n3]);
      return e3;
    }, o22.apply(this, arguments);
  };
  function n2(e3, t2) {
    if (!t2) return "";
    var i3 = "; " + e3;
    return true === t2 ? i3 : i3 + "=" + t2;
  }
  function a22(e3, t2, i3) {
    return encodeURIComponent(e3).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t2).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e4) {
      if ("number" == typeof e4.expires) {
        var t3 = /* @__PURE__ */ new Date();
        t3.setMilliseconds(t3.getMilliseconds() + 864e5 * e4.expires), e4.expires = t3;
      }
      return n2("Expires", e4.expires ? e4.expires.toUTCString() : "") + n2("Domain", e4.domain) + n2("Path", e4.path) + n2("Secure", e4.secure) + n2("SameSite", e4.sameSite);
    }(i3);
  }
  function r2(e3) {
    for (var t2 = {}, i3 = e3 ? e3.split("; ") : [], o3 = /(%[\dA-F]{2})+/gi, n3 = 0; n3 < i3.length; n3++) {
      var a3 = i3[n3].split("="), r3 = a3.slice(1).join("=");
      '"' === r3.charAt(0) && (r3 = r3.slice(1, -1));
      try {
        t2[a3[0].replace(o3, decodeURIComponent)] = r3.replace(o3, decodeURIComponent);
      } catch (e4) {
      }
    }
    return t2;
  }
  function s2() {
    return r2(document.cookie);
  }
  function c2(e3, t2, i3) {
    document.cookie = a22(e3, t2, o22({ path: "/" }, i3));
  }
  i2.__esModule = true, i2.encode = a22, i2.parse = r2, i2.getAll = s2, i2.get = function(e3) {
    return s2()[e3];
  }, i2.set = c2, i2.remove = function(e3, t2) {
    c2(e3, "", o22(o22({}, t2), { expires: -1 }));
  };
});
i$1(R), R.encode, R.parse, R.getAll;
var U$1 = R.get, L = R.set, D$1 = R.remove;
const X$1 = { get(e2) {
  const t2 = U$1(e2);
  if (void 0 !== t2) return JSON.parse(t2);
}, save(e2, t2, i2) {
  let o22 = {};
  "https:" === window.location.protocol && (o22 = { secure: true, sameSite: "none" }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o22.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o22.domain = i2.cookieDomain), L(e2, JSON.stringify(t2), o22);
}, remove(e2, t2) {
  let i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D$1(e2, i2);
} }, N = { get(e2) {
  const t2 = X$1.get(e2);
  return t2 || X$1.get(`_legacy_${e2}`);
}, save(e2, t2, i2) {
  let o22 = {};
  "https:" === window.location.protocol && (o22 = { secure: true }), (null == i2 ? void 0 : i2.daysUntilExpire) && (o22.expires = i2.daysUntilExpire), (null == i2 ? void 0 : i2.cookieDomain) && (o22.domain = i2.cookieDomain), L(`_legacy_${e2}`, JSON.stringify(t2), o22), X$1.save(e2, t2, i2);
}, remove(e2, t2) {
  let i2 = {};
  (null == t2 ? void 0 : t2.cookieDomain) && (i2.domain = t2.cookieDomain), D$1(e2, i2), X$1.remove(e2, t2), X$1.remove(`_legacy_${e2}`, t2);
} }, J$1 = { get(e2) {
  if ("undefined" == typeof sessionStorage) return;
  const t2 = sessionStorage.getItem(e2);
  return null != t2 ? JSON.parse(t2) : void 0;
}, save(e2, t2) {
  sessionStorage.setItem(e2, JSON.stringify(t2));
}, remove(e2) {
  sessionStorage.removeItem(e2);
} };
function F$1(e2, t2, i2) {
  var o22 = void 0 === t2 ? null : t2, n2 = function(e3, t3) {
    var i3 = atob(e3);
    if (t3) {
      for (var o3 = new Uint8Array(i3.length), n3 = 0, a3 = i3.length; n3 < a3; ++n3) o3[n3] = i3.charCodeAt(n3);
      return String.fromCharCode.apply(null, new Uint16Array(o3.buffer));
    }
    return i3;
  }(e2, void 0 !== i2 && i2), a22 = n2.indexOf("\n", 10) + 1, r2 = n2.substring(a22) + (o22 ? "//# sourceMappingURL=" + o22 : ""), s2 = new Blob([r2], { type: "application/javascript" });
  return URL.createObjectURL(s2);
}
var H, Y$1, G$1, V$1, M$1 = (H = "Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Y2xhc3MgZSBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQscil7c3VwZXIociksdGhpcy5lcnJvcj10LHRoaXMuZXJyb3JfZGVzY3JpcHRpb249cixPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcyxlLnByb3RvdHlwZSl9c3RhdGljIGZyb21QYXlsb2FkKHtlcnJvcjp0LGVycm9yX2Rlc2NyaXB0aW9uOnJ9KXtyZXR1cm4gbmV3IGUodCxyKX19Y2xhc3MgdCBleHRlbmRzIGV7Y29uc3RydWN0b3IoZSxzKXtzdXBlcigibWlzc2luZ19yZWZyZXNoX3Rva2VuIixgTWlzc2luZyBSZWZyZXNoIFRva2VuIChhdWRpZW5jZTogJyR7cihlLFsiZGVmYXVsdCJdKX0nLCBzY29wZTogJyR7cihzKX0nKWApLHRoaXMuYXVkaWVuY2U9ZSx0aGlzLnNjb3BlPXMsT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsdC5wcm90b3R5cGUpfX1mdW5jdGlvbiByKGUsdD1bXSl7cmV0dXJuIGUmJiF0LmluY2x1ZGVzKGUpP2U6IiJ9ImZ1bmN0aW9uIj09dHlwZW9mIFN1cHByZXNzZWRFcnJvciYmU3VwcHJlc3NlZEVycm9yO2NvbnN0IHM9ZT0+e3ZhcntjbGllbnRJZDp0fT1lLHI9ZnVuY3Rpb24oZSx0KXt2YXIgcj17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmdC5pbmRleE9mKHMpPDAmJihyW3NdPWVbc10pO2lmKG51bGwhPWUmJiJmdW5jdGlvbiI9PXR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz0wO2ZvcihzPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7bzxzLmxlbmd0aDtvKyspdC5pbmRleE9mKHNbb10pPDAmJk9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChlLHNbb10pJiYocltzW29dXT1lW3Nbb11dKX1yZXR1cm4gcn0oZSxbImNsaWVudElkIl0pO3JldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKChlPT5PYmplY3Qua2V5cyhlKS5maWx0ZXIoKHQ9PnZvaWQgMCE9PWVbdF0pKS5yZWR1Y2UoKCh0LHIpPT5PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdCkse1tyXTplW3JdfSkpLHt9KSkoT2JqZWN0LmFzc2lnbih7Y2xpZW50X2lkOnR9LHIpKSkudG9TdHJpbmcoKX07bGV0IG89e307Y29uc3Qgbj0oZSx0KT0+YCR7ZX18JHt0fWA7YWRkRXZlbnRMaXN0ZW5lcigibWVzc2FnZSIsKGFzeW5jKHtkYXRhOnt0aW1lb3V0OmUsYXV0aDpyLGZldGNoVXJsOmksZmV0Y2hPcHRpb25zOmMsdXNlRm9ybURhdGE6YX0scG9ydHM6W3BdfSk9PntsZXQgZjtjb25zdHthdWRpZW5jZTp1LHNjb3BlOmx9PXJ8fHt9O3RyeXtjb25zdCByPWE/KGU9Pntjb25zdCB0PW5ldyBVUkxTZWFyY2hQYXJhbXMoZSkscj17fTtyZXR1cm4gdC5mb3JFYWNoKCgoZSx0KT0+e3JbdF09ZX0pKSxyfSkoYy5ib2R5KTpKU09OLnBhcnNlKGMuYm9keSk7aWYoIXIucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09ci5ncmFudF90eXBlKXtjb25zdCBlPSgoZSx0KT0+b1tuKGUsdCldKSh1LGwpO2lmKCFlKXRocm93IG5ldyB0KHUsbCk7Yy5ib2R5PWE/cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKTpKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30scikse3JlZnJlc2hfdG9rZW46ZX0pKX1sZXQgaCxnOyJmdW5jdGlvbiI9PXR5cGVvZiBBYm9ydENvbnRyb2xsZXImJihoPW5ldyBBYm9ydENvbnRyb2xsZXIsYy5zaWduYWw9aC5zaWduYWwpO3RyeXtnPWF3YWl0IFByb21pc2UucmFjZShbKGQ9ZSxuZXcgUHJvbWlzZSgoZT0+c2V0VGltZW91dChlLGQpKSkpLGZldGNoKGksT2JqZWN0LmFzc2lnbih7fSxjKSldKX1jYXRjaChlKXtyZXR1cm4gdm9pZCBwLnBvc3RNZXNzYWdlKHtlcnJvcjplLm1lc3NhZ2V9KX1pZighZylyZXR1cm4gaCYmaC5hYm9ydCgpLHZvaWQgcC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KTtmPWF3YWl0IGcuanNvbigpLGYucmVmcmVzaF90b2tlbj8oKChlLHQscik9PntvW24odCxyKV09ZX0pKGYucmVmcmVzaF90b2tlbix1LGwpLGRlbGV0ZSBmLnJlZnJlc2hfdG9rZW4pOigoZSx0KT0+e2RlbGV0ZSBvW24oZSx0KV19KSh1LGwpLHAucG9zdE1lc3NhZ2Uoe29rOmcub2ssanNvbjpmfSl9Y2F0Y2goZSl7cC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3I6ZS5lcnJvcixlcnJvcl9kZXNjcmlwdGlvbjplLm1lc3NhZ2V9fSl9dmFyIGR9KSl9KCk7Cgo=", Y$1 = null, G$1 = false, function(e2) {
  return V$1 = V$1 || F$1(H, Y$1, G$1), new Worker(V$1, e2);
});
const A$1 = {};
class B {
  constructor(e2, t2) {
    this.cache = e2, this.clientId = t2, this.manifestKey = this.createManifestKeyFrom(this.clientId);
  }
  async add(e2) {
    var t2;
    const i2 = new Set((null === (t2 = await this.cache.get(this.manifestKey)) || void 0 === t2 ? void 0 : t2.keys) || []);
    i2.add(e2), await this.cache.set(this.manifestKey, { keys: [...i2] });
  }
  async remove(e2) {
    const t2 = await this.cache.get(this.manifestKey);
    if (t2) {
      const i2 = new Set(t2.keys);
      return i2.delete(e2), i2.size > 0 ? await this.cache.set(this.manifestKey, { keys: [...i2] }) : await this.cache.remove(this.manifestKey);
    }
  }
  get() {
    return this.cache.get(this.manifestKey);
  }
  clear() {
    return this.cache.remove(this.manifestKey);
  }
  createManifestKeyFrom(e2) {
    return `@@auth0spajs@@::${e2}`;
  }
}
const $$1 = { memory: () => new P$1().enclosedCache, localstorage: () => new z() }, q = (e2) => $$1[e2], Q$1 = (t2) => {
  const { openUrl: i2, onRedirect: o22 } = t2, n2 = e$1(t2, ["openUrl", "onRedirect"]);
  return Object.assign(Object.assign({}, n2), { openUrl: false === i2 || i2 ? i2 : o22 });
}, ee$1 = new a$1();
class te {
  constructor(e2) {
    let t2, i2;
    if (this.userCache = new P$1().enclosedCache, this.defaultOptions = { authorizationParams: { scope: "openid profile email" }, useRefreshTokensFallback: false, useFormData: true }, this._releaseLockOnPageHide = async () => {
      await ee$1.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
    }, this.options = Object.assign(Object.assign(Object.assign({}, this.defaultOptions), e2), { authorizationParams: Object.assign(Object.assign({}, this.defaultOptions.authorizationParams), e2.authorizationParams) }), "undefined" != typeof window && (() => {
      if (!w$1()) throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
      if (void 0 === w$1().subtle) throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/main/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
    })(), e2.cache && e2.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e2.cache) i2 = e2.cache;
    else {
      if (t2 = e2.cacheLocation || "memory", !q(t2)) throw new Error(`Invalid cache location "${t2}"`);
      i2 = q(t2)();
    }
    this.httpTimeoutMs = e2.httpTimeoutInSeconds ? 1e3 * e2.httpTimeoutInSeconds : 1e4, this.cookieStorage = false === e2.legacySameSiteCookie ? X$1 : N, this.orgHintCookieName = `auth0.${this.options.clientId}.organization_hint`, this.isAuthenticatedCookieName = ((e3) => `auth0.${e3}.is.authenticated`)(this.options.clientId), this.sessionCheckExpiryDays = e2.sessionCheckExpiryDays || 1;
    const o22 = e2.useCookiesForTransactions ? this.cookieStorage : J$1;
    var n2;
    this.scope = j$1("openid", this.options.authorizationParams.scope, this.options.useRefreshTokens ? "offline_access" : ""), this.transactionManager = new Z$1(o22, this.options.clientId, this.options.cookieDomain), this.nowProvider = this.options.nowProvider || c$1, this.cacheManager = new x(i2, i2.allKeys ? void 0 : new B(i2, this.options.clientId), this.nowProvider), this.domainUrl = (n2 = this.options.domain, /^https?:\/\//.test(n2) ? n2 : `https://${n2}`), this.tokenIssuer = ((e3, t3) => e3 ? e3.startsWith("https://") ? e3 : `https://${e3}/` : `${t3}/`)(this.options.issuer, this.domainUrl), "undefined" != typeof window && window.Worker && this.options.useRefreshTokens && "memory" === t2 && (this.options.workerUrl ? this.worker = new Worker(this.options.workerUrl) : this.worker = new M$1());
  }
  _url(e2) {
    const t2 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || s$1)));
    return `${this.domainUrl}${e2}&auth0Client=${t2}`;
  }
  _authorizeUrl(e2) {
    return this._url(`/authorize?${v$1(e2)}`);
  }
  async _verifyIdToken(e2, t2, i2) {
    const o22 = await this.nowProvider();
    return E({ iss: this.tokenIssuer, aud: this.options.clientId, id_token: e2, nonce: t2, organization: i2, leeway: this.options.leeway, max_age: (n2 = this.options.authorizationParams.max_age, "string" != typeof n2 ? n2 : parseInt(n2, 10) || void 0), now: o22 });
    var n2;
  }
  _processOrgHint(e2) {
    e2 ? this.cookieStorage.save(this.orgHintCookieName, e2, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }) : this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain });
  }
  async _prepareAuthorizeUrl(e2, t2, i2) {
    const o22 = k(y()), n2 = k(y()), a22 = y(), r2 = ((e3) => {
      const t3 = new Uint8Array(e3);
      return ((e4) => {
        const t4 = { "+": "-", "/": "_", "=": "" };
        return e4.replace(/[+/=]/g, (e5) => t4[e5]);
      })(window.btoa(String.fromCharCode(...Array.from(t3))));
    })(await (async (e3) => {
      const t3 = w$1().subtle.digest({ name: "SHA-256" }, new TextEncoder().encode(e3));
      return await t3;
    })(a22)), s2 = ((e3, t3, i3, o3, n3, a3, r3, s3) => Object.assign(Object.assign(Object.assign({ client_id: e3.clientId }, e3.authorizationParams), i3), { scope: j$1(t3, i3.scope), response_type: "code", response_mode: s3 || "query", state: o3, nonce: n3, redirect_uri: r3 || e3.authorizationParams.redirect_uri, code_challenge: a3, code_challenge_method: "S256" }))(this.options, this.scope, e2, o22, n2, r2, e2.redirect_uri || this.options.authorizationParams.redirect_uri || i2, null == t2 ? void 0 : t2.response_mode), c2 = this._authorizeUrl(s2);
    return { nonce: n2, code_verifier: a22, scope: s2.scope, audience: s2.audience || "default", redirect_uri: s2.redirect_uri, state: o22, url: c2 };
  }
  async loginWithPopup(e2, t2) {
    var i2;
    if (e2 = e2 || {}, !(t2 = t2 || {}).popup && (t2.popup = ((e3) => {
      const t3 = window.screenX + (window.innerWidth - 400) / 2, i3 = window.screenY + (window.innerHeight - 600) / 2;
      return window.open(e3, "auth0:authorize:popup", `left=${t3},top=${i3},width=400,height=600,resizable,scrollbars=yes,status=1`);
    })(""), !t2.popup)) throw new Error("Unable to open a popup for loginWithPopup - window.open returned `null`");
    const o22 = await this._prepareAuthorizeUrl(e2.authorizationParams || {}, { response_mode: "web_message" }, window.location.origin);
    t2.popup.location.href = o22.url;
    const n2 = await ((e3) => new Promise((t3, i3) => {
      let o3;
      const n3 = setInterval(() => {
        e3.popup && e3.popup.closed && (clearInterval(n3), clearTimeout(a3), window.removeEventListener("message", o3, false), i3(new p$1(e3.popup)));
      }, 1e3), a3 = setTimeout(() => {
        clearInterval(n3), i3(new h$2(e3.popup)), window.removeEventListener("message", o3, false);
      }, 1e3 * (e3.timeoutInSeconds || 60));
      o3 = function(r2) {
        if (r2.data && "authorization_response" === r2.data.type) {
          if (clearTimeout(a3), clearInterval(n3), window.removeEventListener("message", o3, false), e3.popup.close(), r2.data.response.error) return i3(d$1.fromPayload(r2.data.response));
          t3(r2.data.response);
        }
      }, window.addEventListener("message", o3);
    }))(Object.assign(Object.assign({}, t2), { timeoutInSeconds: t2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60 }));
    if (o22.state !== n2.state) throw new d$1("state_mismatch", "Invalid state");
    const a22 = (null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization;
    await this._requestToken({ audience: o22.audience, scope: o22.scope, code_verifier: o22.code_verifier, grant_type: "authorization_code", code: n2.code, redirect_uri: o22.redirect_uri }, { nonceIn: o22.nonce, organization: a22 });
  }
  async getUser() {
    var e2;
    const t2 = await this._getIdTokenFromCache();
    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.user;
  }
  async getIdTokenClaims() {
    var e2;
    const t2 = await this._getIdTokenFromCache();
    return null === (e2 = null == t2 ? void 0 : t2.decodedToken) || void 0 === e2 ? void 0 : e2.claims;
  }
  async loginWithRedirect(t2 = {}) {
    var i2;
    const o22 = Q$1(t2), { openUrl: n2, fragment: a22, appState: r2 } = o22, s2 = e$1(o22, ["openUrl", "fragment", "appState"]), c2 = (null === (i2 = s2.authorizationParams) || void 0 === i2 ? void 0 : i2.organization) || this.options.authorizationParams.organization, d22 = await this._prepareAuthorizeUrl(s2.authorizationParams || {}), { url: u22 } = d22, l22 = e$1(d22, ["url"]);
    this.transactionManager.create(Object.assign(Object.assign(Object.assign({}, l22), { appState: r2 }), c2 && { organization: c2 }));
    const h22 = a22 ? `${u22}#${a22}` : u22;
    n2 ? await n2(h22) : window.location.assign(h22);
  }
  async handleRedirectCallback(e2 = window.location.href) {
    const t2 = e2.split("?").slice(1);
    if (0 === t2.length) throw new Error("There are no query params available for parsing.");
    const { state: i2, code: o22, error: n2, error_description: a22 } = ((e3) => {
      e3.indexOf("#") > -1 && (e3 = e3.substring(0, e3.indexOf("#")));
      const t3 = new URLSearchParams(e3);
      return { state: t3.get("state"), code: t3.get("code") || void 0, error: t3.get("error") || void 0, error_description: t3.get("error_description") || void 0 };
    })(t2.join("")), r2 = this.transactionManager.get();
    if (!r2) throw new d$1("missing_transaction", "Invalid state");
    if (this.transactionManager.remove(), n2) throw new u$2(n2, a22 || n2, i2, r2.appState);
    if (!r2.code_verifier || r2.state && r2.state !== i2) throw new d$1("state_mismatch", "Invalid state");
    const s2 = r2.organization, c2 = r2.nonce, l22 = r2.redirect_uri;
    return await this._requestToken(Object.assign({ audience: r2.audience, scope: r2.scope, code_verifier: r2.code_verifier, grant_type: "authorization_code", code: o22 }, l22 ? { redirect_uri: l22 } : {}), { nonceIn: c2, organization: s2 }), { appState: r2.appState };
  }
  async checkSession(e2) {
    if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
      if (!this.cookieStorage.get("auth0.is.authenticated")) return;
      this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove("auth0.is.authenticated");
    }
    try {
      await this.getTokenSilently(e2);
    } catch (e3) {
    }
  }
  async getTokenSilently(e2 = {}) {
    var t2;
    const i2 = Object.assign(Object.assign({ cacheMode: "on" }, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j$1(this.scope, null === (t2 = e2.authorizationParams) || void 0 === t2 ? void 0 : t2.scope) }) }), o22 = await ((e3, t3) => {
      let i3 = A$1[t3];
      return i3 || (i3 = e3().finally(() => {
        delete A$1[t3], i3 = null;
      }), A$1[t3] = i3), i3;
    })(() => this._getTokenSilently(i2), `${this.options.clientId}::${i2.authorizationParams.audience}::${i2.authorizationParams.scope}`);
    return e2.detailedResponse ? o22 : null == o22 ? void 0 : o22.access_token;
  }
  async _getTokenSilently(t2) {
    const { cacheMode: i2 } = t2, o22 = e$1(t2, ["cacheMode"]);
    if ("off" !== i2) {
      const e2 = await this._getEntryFromCache({ scope: o22.authorizationParams.scope, audience: o22.authorizationParams.audience || "default", clientId: this.options.clientId });
      if (e2) return e2;
    }
    if ("cache-only" !== i2) {
      if (!await (async (e2, t3 = 3) => {
        for (let i3 = 0; i3 < t3; i3++) if (await e2()) return true;
        return false;
      })(() => ee$1.acquireLock("auth0.lock.getTokenSilently", 5e3), 10)) throw new l$1();
      try {
        if (window.addEventListener("pagehide", this._releaseLockOnPageHide), "off" !== i2) {
          const e3 = await this._getEntryFromCache({ scope: o22.authorizationParams.scope, audience: o22.authorizationParams.audience || "default", clientId: this.options.clientId });
          if (e3) return e3;
        }
        const e2 = this.options.useRefreshTokens ? await this._getTokenUsingRefreshToken(o22) : await this._getTokenFromIFrame(o22), { id_token: t3, access_token: n2, oauthTokenScope: a22, expires_in: r2 } = e2;
        return Object.assign(Object.assign({ id_token: t3, access_token: n2 }, a22 ? { scope: a22 } : null), { expires_in: r2 });
      } finally {
        await ee$1.releaseLock("auth0.lock.getTokenSilently"), window.removeEventListener("pagehide", this._releaseLockOnPageHide);
      }
    }
  }
  async getTokenWithPopup(e2 = {}, t2 = {}) {
    var i2;
    const o22 = Object.assign(Object.assign({}, e2), { authorizationParams: Object.assign(Object.assign(Object.assign({}, this.options.authorizationParams), e2.authorizationParams), { scope: j$1(this.scope, null === (i2 = e2.authorizationParams) || void 0 === i2 ? void 0 : i2.scope) }) });
    t2 = Object.assign(Object.assign({}, r), t2), await this.loginWithPopup(o22, t2);
    return (await this.cacheManager.get(new C({ scope: o22.authorizationParams.scope, audience: o22.authorizationParams.audience || "default", clientId: this.options.clientId }))).access_token;
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  _buildLogoutUrl(t2) {
    null !== t2.clientId ? t2.clientId = t2.clientId || this.options.clientId : delete t2.clientId;
    const i2 = t2.logoutParams || {}, { federated: o22 } = i2, n2 = e$1(i2, ["federated"]), a22 = o22 ? "&federated" : "";
    return this._url(`/v2/logout?${v$1(Object.assign({ clientId: t2.clientId }, n2))}`) + a22;
  }
  async logout(t2 = {}) {
    const i2 = Q$1(t2), { openUrl: o22 } = i2, n2 = e$1(i2, ["openUrl"]);
    null === t2.clientId ? await this.cacheManager.clear() : await this.cacheManager.clear(t2.clientId || this.options.clientId), this.cookieStorage.remove(this.orgHintCookieName, { cookieDomain: this.options.cookieDomain }), this.cookieStorage.remove(this.isAuthenticatedCookieName, { cookieDomain: this.options.cookieDomain }), this.userCache.remove("@@user@@");
    const a22 = this._buildLogoutUrl(n2);
    o22 ? await o22(a22) : false !== o22 && window.location.assign(a22);
  }
  async _getTokenFromIFrame(e2) {
    const t2 = Object.assign(Object.assign({}, e2.authorizationParams), { prompt: "none" }), i2 = this.cookieStorage.get(this.orgHintCookieName);
    i2 && !t2.organization && (t2.organization = i2);
    const { url: o22, state: n2, nonce: a22, code_verifier: r2, redirect_uri: s2, scope: c2, audience: u22 } = await this._prepareAuthorizeUrl(t2, { response_mode: "web_message" }, window.location.origin);
    try {
      if (window.crossOriginIsolated) throw new d$1("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
      const i3 = e2.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, h22 = await ((e3, t3, i4 = 60) => new Promise((o3, n3) => {
        const a3 = window.document.createElement("iframe");
        a3.setAttribute("width", "0"), a3.setAttribute("height", "0"), a3.style.display = "none";
        const r3 = () => {
          window.document.body.contains(a3) && (window.document.body.removeChild(a3), window.removeEventListener("message", s3, false));
        };
        let s3;
        const c3 = setTimeout(() => {
          n3(new l$1()), r3();
        }, 1e3 * i4);
        s3 = function(e4) {
          if (e4.origin != t3) return;
          if (!e4.data || "authorization_response" !== e4.data.type) return;
          const i5 = e4.source;
          i5 && i5.close(), e4.data.response.error ? n3(d$1.fromPayload(e4.data.response)) : o3(e4.data.response), clearTimeout(c3), window.removeEventListener("message", s3, false), setTimeout(r3, 2e3);
        }, window.addEventListener("message", s3, false), window.document.body.appendChild(a3), a3.setAttribute("src", e3);
      }))(o22, this.domainUrl, i3);
      if (n2 !== h22.state) throw new d$1("state_mismatch", "Invalid state");
      const p22 = await this._requestToken(Object.assign(Object.assign({}, e2.authorizationParams), { code_verifier: r2, code: h22.code, grant_type: "authorization_code", redirect_uri: s2, timeout: e2.authorizationParams.timeout || this.httpTimeoutMs }), { nonceIn: a22, organization: t2.organization });
      return Object.assign(Object.assign({}, p22), { scope: c2, oauthTokenScope: p22.scope, audience: u22 });
    } catch (e3) {
      throw "login_required" === e3.error && this.logout({ openUrl: false }), e3;
    }
  }
  async _getTokenUsingRefreshToken(e2) {
    const t2 = await this.cacheManager.get(new C({ scope: e2.authorizationParams.scope, audience: e2.authorizationParams.audience || "default", clientId: this.options.clientId }));
    if (!(t2 && t2.refresh_token || this.worker)) {
      if (this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e2);
      throw new f$1(e2.authorizationParams.audience || "default", e2.authorizationParams.scope);
    }
    const i2 = e2.authorizationParams.redirect_uri || this.options.authorizationParams.redirect_uri || window.location.origin, o22 = "number" == typeof e2.timeoutInSeconds ? 1e3 * e2.timeoutInSeconds : null;
    try {
      const n2 = await this._requestToken(Object.assign(Object.assign(Object.assign({}, e2.authorizationParams), { grant_type: "refresh_token", refresh_token: t2 && t2.refresh_token, redirect_uri: i2 }), o22 && { timeout: o22 }));
      return Object.assign(Object.assign({}, n2), { scope: e2.authorizationParams.scope, oauthTokenScope: n2.scope, audience: e2.authorizationParams.audience || "default" });
    } catch (t3) {
      if ((t3.message.indexOf("Missing Refresh Token") > -1 || t3.message && t3.message.indexOf("invalid refresh token") > -1) && this.options.useRefreshTokensFallback) return await this._getTokenFromIFrame(e2);
      throw t3;
    }
  }
  async _saveEntryInCache(t2) {
    const { id_token: i2, decodedToken: o22 } = t2, n2 = e$1(t2, ["id_token", "decodedToken"]);
    this.userCache.set("@@user@@", { id_token: i2, decodedToken: o22 }), await this.cacheManager.setIdToken(this.options.clientId, t2.id_token, t2.decodedToken), await this.cacheManager.set(n2);
  }
  async _getIdTokenFromCache() {
    const e2 = this.options.authorizationParams.audience || "default", t2 = await this.cacheManager.getIdToken(new C({ clientId: this.options.clientId, audience: e2, scope: this.scope })), i2 = this.userCache.get("@@user@@");
    return t2 && t2.id_token === (null == i2 ? void 0 : i2.id_token) ? i2 : (this.userCache.set("@@user@@", t2), t2);
  }
  async _getEntryFromCache({ scope: e2, audience: t2, clientId: i2 }) {
    const o22 = await this.cacheManager.get(new C({ scope: e2, audience: t2, clientId: i2 }), 60);
    if (o22 && o22.access_token) {
      const { access_token: e3, oauthTokenScope: t3, expires_in: i3 } = o22, n2 = await this._getIdTokenFromCache();
      return n2 && Object.assign(Object.assign({ id_token: n2.id_token, access_token: e3 }, t3 ? { scope: t3 } : null), { expires_in: i3 });
    }
  }
  async _requestToken(e2, t2) {
    const { nonceIn: i2, organization: o22 } = t2 || {}, n2 = await T$1(Object.assign({ baseUrl: this.domainUrl, client_id: this.options.clientId, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData, timeout: this.httpTimeoutMs }, e2), this.worker), a22 = await this._verifyIdToken(n2.id_token, i2, o22);
    return await this._saveEntryInCache(Object.assign(Object.assign(Object.assign(Object.assign({}, n2), { decodedToken: a22, scope: e2.scope, audience: e2.audience || "default" }), n2.scope ? { oauthTokenScope: n2.scope } : null), { client_id: this.options.clientId })), this.cookieStorage.save(this.isAuthenticatedCookieName, true, { daysUntilExpire: this.sessionCheckExpiryDays, cookieDomain: this.options.cookieDomain }), this._processOrgHint(o22 || a22.claims.org_id), Object.assign(Object.assign({}, n2), { decodedToken: a22 });
  }
}
function createAuth(auth0Client, customProviderHooks) {
  const authImplementation = createAuthImplementation(auth0Client);
  return createAuthentication(authImplementation);
}
function createAuthImplementation(auth0Client) {
  return {
    type: "auth0",
    client: auth0Client,
    restoreAuthState: async () => {
      var _a3, _b2, _c2, _d, _e2;
      if (((_b2 = (_a3 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _a3.search) == null ? void 0 : _b2.includes("code=")) && ((_d = (_c2 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _c2.search) == null ? void 0 : _d.includes("state="))) {
        const { appState } = await auth0Client.handleRedirectCallback();
        const url = (appState == null ? void 0 : appState.targetUrl) ? appState.targetUrl : window.location.pathname;
        (_e2 = globalThis == null ? void 0 : globalThis.location) == null ? void 0 : _e2.assign(url);
      }
    },
    login: async (options2) => auth0Client.loginWithRedirect(options2),
    logout: async (options2) => auth0Client.logout(options2),
    signup: async (options2) => auth0Client.loginWithRedirect({
      ...options2,
      authorizationParams: {
        screen_hint: "signup",
        prompt: "login"
      }
    }),
    getToken: () => auth0Client.getTokenSilently(),
    getUserMetadata: async () => {
      const user = await auth0Client.getUser();
      return user || null;
    }
  };
}
const auth0 = new te({
  domain: "auth.landingsite.ai",
  clientId: "fhFKuJDrScHQlR6yv6XpGZ7z4zpnfyAM",
  authorizationParams: {
    redirect_uri: "https://app.landingsite.ai/login-success",
    audience: "https://landingsite.us.auth0.com/api/v2/"
  },
  // Storing tokens in the browser's local storage provides persistence across page refreshes and browser tabs.
  // But if an attacker can run JavaScript in your SPA using a cross-site scripting (XSS) attack,
  // they can retrieve the tokens stored in local storage.
  // See https://auth0.com/docs/libraries/auth0-spa-js#change-storage-options.
  cacheLocation: "localstorage",
  // `useRefreshTokens` is required for automatically extending sessions beyond what's set in the initial JWT expiration.
  // See https://auth0.com/docs/tokens/refresh-tokens.
  useRefreshTokens: true
});
const {
  AuthProvider,
  useAuth
} = createAuth(auth0);
const GET_STRIPE_CUSTOMER_PORTAL_SESSION_URL$1 = gql`
  mutation GetStripeCustomerPortalSessionUrlMutation {
    getStripeCustomerPortalSessionUrl
  }
`;
const AppNavBarLayout = ({
  children
}) => {
  const {
    loading,
    isAuthenticated,
    logIn,
    signUp,
    logOut
  } = useAuth();
  const [loadingBillingPortal, setLoadingBillingPortal] = reactExports.useState(false);
  const [getStripeCustomerPortalSessionUrl] = useMutation$1(GET_STRIPE_CUSTOMER_PORTAL_SESSION_URL$1);
  const onClickLogin = (event) => {
    event.preventDefault();
    logIn({
      appState: {
        targetUrl: `/login-success?redirectTo=${encodeURIComponent(window.location.pathname + window.location.search)}`
      }
    });
  };
  const onClickSignup = (event) => {
    event.preventDefault();
    signUp({
      appState: {
        targetUrl: `/login-success?redirectTo=${encodeURIComponent(window.location.pathname + window.location.search)}`
      }
    });
  };
  const navigateToBillingPortal = async () => {
    setLoadingBillingPortal(true);
    const res = await getStripeCustomerPortalSessionUrl();
    console.log(res);
    window.location.href = res.data.getStripeCustomerPortalSessionUrl;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full min-w-full bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("header", { id: "main-header", className: "py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "flex items-center text-xl font-bold tracking-tight text-gray-800 sm:text-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo_full_black.png", className: "mr-2 inline h-5", alt: "Landingsite" }),
        "Landingsite.ai"
      ] }),
      !loading && !isAuthenticated && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "flex items-center gap-x-8 text-sm text-black", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "hover:underline", href: "/login", onClick: onClickLogin, children: "Log In" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "rounded bg-lime-400 px-4 py-2 text-sm hover:bg-lime-500", href: "/signup", onClick: onClickSignup, children: "Sign Up" }) })
      ] }),
      !loading && isAuthenticated && /* @__PURE__ */ jsxRuntimeExports.jsx(lo, { className: "relative flex", children: ({
        open
      }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(lo.Button, { className: `
                          ${open ? "" : "text-opacity-90"}
                          group inline-flex h-[32px] w-[50px] flex-grow items-center justify-center rounded-lg bg-lime-400 p-2 text-base font-medium text-gray-800 hover:bg-gray-700 hover:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user mr-1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-chevron-down" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ze, { as: reactExports.Fragment, enter: "transition ease-out duration-200", enterFrom: "opacity-0 translate-y-1", enterTo: "opacity-100 translate-y-0", leave: "transition ease-in duration-150", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 translate-y-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(lo.Panel, { className: "absolute -left-3/4 z-[80] mt-10 w-[180px] -translate-x-1/2 transform px-4 sm:w-[140px] sm:px-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-hidden rounded-lg shadow-lg ring-1 ring-black ring-opacity-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Dashboard" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", onClick: navigateToBillingPortal, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Billing" }),
            !loadingBillingPortal && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-credit-card" }),
            loadingBillingPortal && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-spinner-third animate-spin" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", onClick: () => {
            logOut({
              logoutParams: {
                returnTo: "https://www.landingsite.ai/"
              }
            });
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Log Out" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-sign-out" })
          ] })
        ] }) }) })
      ] }) })
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "h-full", children })
  ] }) });
};
let e = { data: "" }, t = (t2) => "object" == typeof window ? ((t2 ? t2.querySelector("#_goober") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t2 || e, l2 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a2 = /\/\*[^]*?\*\/|  +/g, n$1 = /\n+/g, o2 = (e2, t2) => {
  let r2 = "", l22 = "", a22 = "";
  for (let n2 in e2) {
    let c2 = e2[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c2 + ";" : l22 += "f" == n2[1] ? o2(c2, n2) : n2 + "{" + o2(c2, "k" == n2[1] ? "" : t2) + "}" : "object" == typeof c2 ? l22 += o2(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + " " + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a22 += o2.p ? o2.p(n2, c2) : n2 + ":" + c2 + ";");
  }
  return r2 + (t2 && a22 ? t2 + "{" + a22 + "}" : a22) + l22;
}, c = {}, s = (e2) => {
  if ("object" == typeof e2) {
    let t2 = "";
    for (let r2 in e2) t2 += r2 + s(e2[r2]);
    return t2;
  }
  return e2;
}, i = (e2, t2, r2, i2, p22) => {
  let u22 = s(e2), d22 = c[u22] || (c[u22] = ((e3) => {
    let t3 = 0, r3 = 11;
    for (; t3 < e3.length; ) r3 = 101 * r3 + e3.charCodeAt(t3++) >>> 0;
    return "go" + r3;
  })(u22));
  if (!c[d22]) {
    let t3 = u22 !== e2 ? e2 : ((e3) => {
      let t4, r3, o22 = [{}];
      for (; t4 = l2.exec(e3.replace(a2, "")); ) t4[4] ? o22.shift() : t4[3] ? (r3 = t4[3].replace(n$1, " ").trim(), o22.unshift(o22[0][r3] = o22[0][r3] || {})) : o22[0][t4[1]] = t4[2].replace(n$1, " ").trim();
      return o22[0];
    })(e2);
    c[d22] = o2(p22 ? { ["@keyframes " + d22]: t3 } : t3, r2 ? "" : "." + d22);
  }
  let f22 = r2 && c.g ? c.g : null;
  return r2 && (c.g = c[d22]), ((e3, t3, r3, l22) => {
    l22 ? t3.data = t3.data.replace(l22, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r3 ? e3 + t3.data : t3.data + e3);
  })(c[d22], t2, i2, f22), d22;
}, p2 = (e2, t2, r2) => e2.reduce((e3, l22, a22) => {
  let n2 = t2[a22];
  if (n2 && n2.call) {
    let e4 = n2(r2), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;
    n2 = t3 ? "." + t3 : e4 && "object" == typeof e4 ? e4.props ? "" : o2(e4, "") : false === e4 ? "" : e4;
  }
  return e3 + l22 + (null == n2 ? "" : n2);
}, "");
function u$1(e2) {
  let r2 = this || {}, l22 = e2.call ? e2(r2.p) : e2;
  return i(l22.unshift ? l22.raw ? p2(l22, [].slice.call(arguments, 1), r2.p) : l22.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r2.p) : t2), {}) : l22, t(r2.target), r2.g, r2.o, r2.k);
}
let d2, f2, g;
u$1.bind({ g: 1 });
let h$1 = u$1.bind({ k: 1 });
function m2(e2, t2, r2, l22) {
  o2.p = t2, d2 = e2, f2 = r2, g = l22;
}
function j(e2, t2) {
  let r2 = this || {};
  return function() {
    let l22 = arguments;
    function a22(n2, o22) {
      let c2 = Object.assign({}, n2), s2 = c2.className || a22.className;
      r2.p = Object.assign({ theme: f2 && f2() }, c2), r2.o = / *go\d+/.test(s2), c2.className = u$1.apply(r2, l22) + (s2 ? " " + s2 : "");
      let i2 = e2;
      return e2[0] && (i2 = c2.as || e2, delete c2.as), g && i2[0] && g(c2), d2(i2, c2);
    }
    return a22;
  };
}
var W = (e2) => typeof e2 == "function", T = (e2, t2) => W(e2) ? e2(t2) : e2;
var U = /* @__PURE__ */ (() => {
  let e2 = 0;
  return () => (++e2).toString();
})(), b = /* @__PURE__ */ (() => {
  let e2;
  return () => {
    if (e2 === void 0 && typeof window < "u") {
      let t2 = matchMedia("(prefers-reduced-motion: reduce)");
      e2 = !t2 || t2.matches;
    }
    return e2;
  };
})();
var Q = 20;
var S = /* @__PURE__ */ new Map(), X = 1e3, $ = (e2) => {
  if (S.has(e2)) return;
  let t2 = setTimeout(() => {
    S.delete(e2), u2({ type: 4, toastId: e2 });
  }, X);
  S.set(e2, t2);
}, J = (e2) => {
  let t2 = S.get(e2);
  t2 && clearTimeout(t2);
}, v = (e2, t2) => {
  switch (t2.type) {
    case 0:
      return { ...e2, toasts: [t2.toast, ...e2.toasts].slice(0, Q) };
    case 1:
      return t2.toast.id && J(t2.toast.id), { ...e2, toasts: e2.toasts.map((r2) => r2.id === t2.toast.id ? { ...r2, ...t2.toast } : r2) };
    case 2:
      let { toast: o3 } = t2;
      return e2.toasts.find((r2) => r2.id === o3.id) ? v(e2, { type: 1, toast: o3 }) : v(e2, { type: 0, toast: o3 });
    case 3:
      let { toastId: s2 } = t2;
      return s2 ? $(s2) : e2.toasts.forEach((r2) => {
        $(r2.id);
      }), { ...e2, toasts: e2.toasts.map((r2) => r2.id === s2 || s2 === void 0 ? { ...r2, visible: false } : r2) };
    case 4:
      return t2.toastId === void 0 ? { ...e2, toasts: [] } : { ...e2, toasts: e2.toasts.filter((r2) => r2.id !== t2.toastId) };
    case 5:
      return { ...e2, pausedAt: t2.time };
    case 6:
      let a3 = t2.time - (e2.pausedAt || 0);
      return { ...e2, pausedAt: void 0, toasts: e2.toasts.map((r2) => ({ ...r2, pauseDuration: r2.pauseDuration + a3 })) };
  }
}, A = [], P2 = { toasts: [], pausedAt: void 0 }, u2 = (e2) => {
  P2 = v(P2, e2), A.forEach((t2) => {
    t2(P2);
  });
}, Y = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, I = (e2 = {}) => {
  let [t2, o3] = reactExports.useState(P2);
  reactExports.useEffect(() => (A.push(o3), () => {
    let a3 = A.indexOf(o3);
    a3 > -1 && A.splice(a3, 1);
  }), [t2]);
  let s2 = t2.toasts.map((a3) => {
    var r2, c2;
    return { ...e2, ...e2[a3.type], ...a3, duration: a3.duration || ((r2 = e2[a3.type]) == null ? void 0 : r2.duration) || (e2 == null ? void 0 : e2.duration) || Y[a3.type], style: { ...e2.style, ...(c2 = e2[a3.type]) == null ? void 0 : c2.style, ...a3.style } };
  });
  return { ...t2, toasts: s2 };
};
var G = (e2, t2 = "blank", o3) => ({ createdAt: Date.now(), visible: true, type: t2, ariaProps: { role: "status", "aria-live": "polite" }, message: e2, pauseDuration: 0, ...o3, id: (o3 == null ? void 0 : o3.id) || U() }), h2 = (e2) => (t2, o3) => {
  let s2 = G(t2, e2, o3);
  return u2({ type: 2, toast: s2 }), s2.id;
}, n = (e2, t2) => h2("blank")(e2, t2);
n.error = h2("error");
n.success = h2("success");
n.loading = h2("loading");
n.custom = h2("custom");
n.dismiss = (e2) => {
  u2({ type: 3, toastId: e2 });
};
n.remove = (e2) => u2({ type: 4, toastId: e2 });
n.promise = (e2, t2, o3) => {
  let s2 = n.loading(t2.loading, { ...o3, ...o3 == null ? void 0 : o3.loading });
  return e2.then((a3) => (n.success(T(t2.success, a3), { id: s2, ...o3, ...o3 == null ? void 0 : o3.success }), a3)).catch((a3) => {
    n.error(T(t2.error, a3), { id: s2, ...o3, ...o3 == null ? void 0 : o3.error });
  }), e2;
};
var Z2 = (e2, t2) => {
  u2({ type: 1, toast: { id: e2, height: t2 } });
}, ee = () => {
  u2({ type: 5, time: Date.now() });
}, D = (e2) => {
  let { toasts: t2, pausedAt: o3 } = I(e2);
  reactExports.useEffect(() => {
    if (o3) return;
    let r2 = Date.now(), c2 = t2.map((i2) => {
      if (i2.duration === 1 / 0) return;
      let d3 = (i2.duration || 0) + i2.pauseDuration - (r2 - i2.createdAt);
      if (d3 < 0) {
        i2.visible && n.dismiss(i2.id);
        return;
      }
      return setTimeout(() => n.dismiss(i2.id), d3);
    });
    return () => {
      c2.forEach((i2) => i2 && clearTimeout(i2));
    };
  }, [t2, o3]);
  let s2 = reactExports.useCallback(() => {
    o3 && u2({ type: 6, time: Date.now() });
  }, [o3]), a3 = reactExports.useCallback((r2, c2) => {
    let { reverseOrder: i2 = false, gutter: d3 = 8, defaultPosition: p3 } = c2 || {}, g2 = t2.filter((m3) => (m3.position || p3) === (r2.position || p3) && m3.height), E2 = g2.findIndex((m3) => m3.id === r2.id), x2 = g2.filter((m3, R2) => R2 < E2 && m3.visible).length;
    return g2.filter((m3) => m3.visible).slice(...i2 ? [x2 + 1] : [0, x2]).reduce((m3, R2) => m3 + (R2.height || 0) + d3, 0);
  }, [t2]);
  return { toasts: t2, handlers: { updateHeight: Z2, startPause: ee, endPause: s2, calculateOffset: a3 } };
};
var oe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re = h$1`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se = h$1`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, _ = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e2) => e2.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
var ne = h$1`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V = j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e2) => e2.secondary || "#e0e0e0"};
  border-right-color: ${(e2) => e2.primary || "#616161"};
  animation: ${ne} 1s linear infinite;
`;
var pe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de = h$1`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, w = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e2) => e2.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e2) => e2.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
var ue = j("div")`
  position: absolute;
`, le = j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Te = h$1`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, fe = j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Te} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M = ({ toast: e2 }) => {
  let { icon: t2, type: o3, iconTheme: s2 } = e2;
  return t2 !== void 0 ? typeof t2 == "string" ? reactExports.createElement(fe, null, t2) : t2 : o3 === "blank" ? null : reactExports.createElement(le, null, reactExports.createElement(V, { ...s2 }), o3 !== "loading" && reactExports.createElement(ue, null, o3 === "error" ? reactExports.createElement(_, { ...s2 }) : reactExports.createElement(w, { ...s2 })));
};
var ye = (e2) => `
0% {transform: translate3d(0,${e2 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge = (e2) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e2 * -150}%,-1px) scale(.6); opacity:0;}
`, he = "0%{opacity:0;} 100%{opacity:1;}", xe = "0%{opacity:1;} 100%{opacity:0;}", be = j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se = j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (e2, t2) => {
  let s2 = e2.includes("top") ? 1 : -1, [a3, r2] = b() ? [he, xe] : [ye(s2), ge(s2)];
  return { animation: t2 ? `${h$1(a3)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$1(r2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, F = reactExports.memo(({ toast: e2, position: t2, style: o3, children: s2 }) => {
  let a3 = e2.height ? Ae(e2.position || t2 || "top-center", e2.visible) : { opacity: 0 }, r2 = reactExports.createElement(M, { toast: e2 }), c2 = reactExports.createElement(Se, { ...e2.ariaProps }, T(e2.message, e2));
  return reactExports.createElement(be, { className: e2.className, style: { ...a3, ...o3, ...e2.style } }, typeof s2 == "function" ? s2({ icon: r2, message: c2 }) : reactExports.createElement(reactExports.Fragment, null, r2, c2));
});
m2(reactExports.createElement);
var Ee = ({ id: e2, className: t2, style: o3, onHeightUpdate: s2, children: a3 }) => {
  let r2 = reactExports.useCallback((c2) => {
    if (c2) {
      let i2 = () => {
        let d3 = c2.getBoundingClientRect().height;
        s2(e2, d3);
      };
      i2(), new MutationObserver(i2).observe(c2, { subtree: true, childList: true, characterData: true });
    }
  }, [e2, s2]);
  return reactExports.createElement("div", { ref: r2, className: t2, style: o3 }, a3);
}, Re = (e2, t2) => {
  let o3 = e2.includes("top"), s2 = o3 ? { top: 0 } : { bottom: 0 }, a3 = e2.includes("center") ? { justifyContent: "center" } : e2.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: b() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t2 * (o3 ? 1 : -1)}px)`, ...s2, ...a3 };
}, ve = u$1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, O = 16, Ie = ({ reverseOrder: e2, position: t2 = "top-center", toastOptions: o3, gutter: s2, children: a3, containerStyle: r2, containerClassName: c2 }) => {
  let { toasts: i2, handlers: d3 } = D(o3);
  return reactExports.createElement("div", { style: { position: "fixed", zIndex: 9999, top: O, left: O, right: O, bottom: O, pointerEvents: "none", ...r2 }, className: c2, onMouseEnter: d3.startPause, onMouseLeave: d3.endPause }, i2.map((p3) => {
    let g2 = p3.position || t2, E2 = d3.calculateOffset(p3, { reverseOrder: e2, gutter: s2, defaultPosition: t2 }), x2 = Re(g2, E2);
    return reactExports.createElement(Ee, { id: p3.id, key: p3.id, onHeightUpdate: d3.updateHeight, className: p3.visible ? ve : "", style: x2 }, p3.type === "custom" ? T(p3.message, p3) : a3 ? a3(p3) : reactExports.createElement(F, { toast: p3, position: g2 }));
  }));
};
var _t = n;
const ChatLayout = ({
  children
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie, { toastOptions: {
      className: "rw-toast",
      duration: 6e3
    } }),
    children
  ] });
};
const GET_STRIPE_CUSTOMER_PORTAL_SESSION_URL = gql`
  mutation GetStripeCustomerPortalSessionUrlMutation {
    getStripeCustomerPortalSessionUrl
  }
`;
const FineTuningNavBarLayout = ({
  children
}) => {
  const {
    loading,
    isAuthenticated,
    logIn,
    signUp,
    logOut
  } = useAuth();
  const [loadingBillingPortal, setLoadingBillingPortal] = reactExports.useState(false);
  const [getStripeCustomerPortalSessionUrl] = useMutation$1(GET_STRIPE_CUSTOMER_PORTAL_SESSION_URL);
  const onClickLogin = (event) => {
    event.preventDefault();
    logIn({
      appState: {
        targetUrl: `/login-success?redirectTo=${encodeURIComponent(window.location.pathname + window.location.search)}`
      }
    });
  };
  const onClickSignup = (event) => {
    event.preventDefault();
    signUp({
      appState: {
        targetUrl: `/login-success?redirectTo=${encodeURIComponent(window.location.pathname + window.location.search)}`
      }
    });
  };
  const navigateToBillingPortal = async () => {
    setLoadingBillingPortal(true);
    const res = await getStripeCustomerPortalSessionUrl();
    console.log(res);
    window.location.href = res.data.getStripeCustomerPortalSessionUrl;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-full", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "h-full min-w-full border border-b-gray-200 bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("header", { id: "main-header", className: "py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-8", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "inline-block text-xl font-bold tracking-tight text-gray-800 sm:text-2xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo_full_black.png", className: "mr-2 inline h-5", alt: "Landingsite" }),
          "Landingsite.ai"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/fine-tuning/playground", className: "inline-block", children: "Playground" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/fine-tuning/examples", className: "inline-block", children: "Examples" })
      ] }),
      !loading && !isAuthenticated && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: "flex items-center gap-x-8 text-sm text-black", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "hover:underline", href: "/login", onClick: onClickLogin, children: "Log In" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { className: "rounded bg-lime-400 px-4 py-2 text-sm hover:bg-lime-500", href: "/signup", onClick: onClickSignup, children: "Sign Up" }) })
      ] }),
      !loading && isAuthenticated && /* @__PURE__ */ jsxRuntimeExports.jsx(lo, { className: "relative flex", children: ({
        open
      }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(lo.Button, { className: `
                          ${open ? "" : "text-opacity-90"}
                          group inline-flex h-[32px] w-[50px] flex-grow items-center justify-center rounded-lg bg-lime-400 p-2 text-base font-medium text-gray-800 hover:bg-gray-700 hover:text-white focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user mr-1" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-chevron-down" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ze, { as: reactExports.Fragment, enter: "transition ease-out duration-200", enterFrom: "opacity-0 translate-y-1", enterTo: "opacity-100 translate-y-0", leave: "transition ease-in duration-150", leaveFrom: "opacity-100 translate-y-0", leaveTo: "opacity-0 translate-y-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(lo.Panel, { className: "absolute -left-3/4 z-[80] mt-10 w-[180px] -translate-x-1/2 transform px-4 sm:w-[140px] sm:px-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "overflow-hidden rounded-lg shadow-lg ring-1 ring-black ring-opacity-5", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Dashboard" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-user" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", onClick: navigateToBillingPortal, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Billing" }),
            !loadingBillingPortal && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-credit-card" }),
            loadingBillingPortal && /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-regular fa-spinner-third animate-spin" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: "flex w-full items-center justify-between bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-200", onClick: () => {
            logOut({
              returnTo: "https://www.landingsite.ai/"
            });
          }, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Log Out" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("i", { className: "fa-solid fa-sign-out" })
          ] })
        ] }) }) })
      ] }) })
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "h-full", children })
  ] }) });
};
const ScaffoldLayout = ({
  title,
  titleTo,
  buttonLabel,
  buttonTo,
  children
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "rw-scaffold", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Ie, { toastOptions: {
      className: "rw-toast",
      duration: 6e3
    } }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "rw-header", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "rw-heading rw-heading-primary", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: namedRoutes[titleTo](), className: "rw-link", children: title }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: namedRoutes[buttonTo](), className: "rw-button rw-button-green", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rw-button-icon", children: "+" }),
        " ",
        buttonLabel
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "rw-main", children })
  ] });
};
const TrainingWebsitesNavBarLayout = ({
  children
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "h-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-w-full border border-b-gray-200 bg-white", children: /* @__PURE__ */ jsxRuntimeExports.jsx("header", { id: "main-header", className: "py-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-between", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-8", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "/", className: "inline-block text-xl font-bold tracking-tight text-gray-800 sm:text-2xl", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: "/logo_full_black.png", className: "mr-2 inline h-5", alt: "Landingsite" }),
        "Landingsite.ai"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/fine-tuning/playground", className: "inline-block", children: "Playground" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/training-websites", className: "inline-block", children: "Training Websites" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "/template-editor", className: "inline-block", children: "Template Editor" })
    ] }) }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "h-full", children })
  ] }) });
};
const ClaimPage = {
  name: "ClaimPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./ClaimPage-1R3Z_eHG.js"), true ? [] : void 0))
};
({
  LazyComponent: reactExports.lazy(() => __vitePreload(() => Promise.resolve().then(() => FatalErrorPage$1), true ? void 0 : void 0))
});
const FineTuningExamplesPage = {
  name: "FineTuningExamplesPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./FineTuningExamplesPage-DnSwrDqS.js"), true ? __vite__mapDeps([0,1,2,3,4,5]) : void 0))
};
const FineTuningPlaygroundPage = {
  name: "FineTuningPlaygroundPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./FineTuningPlaygroundPage-SVAphOTM.js"), true ? __vite__mapDeps([6,3]) : void 0))
};
const HomePage = {
  name: "HomePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./HomePage-uN4gHFOV.js"), true ? __vite__mapDeps([7,8,9,10,11,12,1,13,14,15,16,4,5]) : void 0))
};
const LoginPage = {
  name: "LoginPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./LoginPage-C9r9Ylin.js"), true ? __vite__mapDeps([17,18]) : void 0))
};
const LoginSuccessPage = {
  name: "LoginSuccessPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./LoginSuccessPage-BGwWXT-M.js"), true ? [] : void 0))
};
const LogoutPage = {
  name: "LogoutPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./LogoutPage-ARGV1b5F.js"), true ? __vite__mapDeps([19,18]) : void 0))
};
const NotFoundPage = {
  name: "NotFoundPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./NotFoundPage-AxmG2XWO.js"), true ? [] : void 0))
};
({
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./PlansPage-ZgsF5TVh.js"), true ? [] : void 0))
});
({
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./PluginInstructionsPage-CFo60cxG.js"), true ? __vite__mapDeps([20,21,12,10,14,11,15]) : void 0))
});
const PurchaseSuccessPage = {
  name: "PurchaseSuccessPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./PurchaseSuccessPage-B41kUWwa.js"), true ? __vite__mapDeps([22,12,10]) : void 0))
};
const RecentSignupsPage = {
  name: "RecentSignupsPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./RecentSignupsPage-2iSg3HK3.js"), true ? __vite__mapDeps([23,24,25,26,27]) : void 0))
};
const SignupPage = {
  name: "SignupPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./SignupPage-CZwdwKYb.js"), true ? __vite__mapDeps([28,18]) : void 0))
};
const TemplateEditorEditPage = {
  name: "TemplateEditorEditPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateEditorEditPage-CjkcHG0v.js"), true ? __vite__mapDeps([29,21,3,30,31,32,33,13,34,35,11,36,10,37,38,15]) : void 0))
};
const TemplateEditorNewPage = {
  name: "TemplateEditorNewPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateEditorNewPage-C-ZgZO7L.js"), true ? __vite__mapDeps([39,21,40]) : void 0))
};
const TemplateEditorPage = {
  name: "TemplateEditorPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateEditorPage-CSTkdqIw.js"), true ? __vite__mapDeps([41,21]) : void 0))
};
const TemplateEditorValidatorPage = {
  name: "TemplateEditorValidatorPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateEditorValidatorPage-CMTTA8PS.js"), true ? __vite__mapDeps([42,21,3,30,31,32,34,35,11,36,10,37,38]) : void 0))
};
const TemplateEightBuilderPage = {
  name: "TemplateEightBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateEightBuilderPage-LtXM-sY-.js"), true ? [] : void 0))
};
const TemplateFiveBuilderPage = {
  name: "TemplateFiveBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateFiveBuilderPage-ByPQhGlj.js"), true ? [] : void 0))
};
const TemplateFourBuilderPage = {
  name: "TemplateFourBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateFourBuilderPage--PQY9pjb.js"), true ? [] : void 0))
};
const TemplateNineBuilderPage = {
  name: "TemplateNineBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateNineBuilderPage-DGX6uxO4.js"), true ? [] : void 0))
};
const TemplateOneBuilderPage = {
  name: "TemplateOneBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateOneBuilderPage-3CfwGd-q.js"), true ? [] : void 0))
};
const TemplateSectionEditPage = {
  name: "TemplateSectionEditPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateSectionEditPage-DCZ-NTEI.js"), true ? __vite__mapDeps([43,1,2,3]) : void 0))
};
const TemplateSectionsPage = {
  name: "TemplateSectionsPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateSectionsPage-DfhFrPAU.js"), true ? __vite__mapDeps([44,1,3]) : void 0))
};
const TemplateSevenBuilderPage = {
  name: "TemplateSevenBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateSevenBuilderPage-HUiN64Qx.js"), true ? [] : void 0))
};
const TemplateSixBuilderPage = {
  name: "TemplateSixBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateSixBuilderPage-CDxj_nXC.js"), true ? [] : void 0))
};
const TemplateTenBuilderPage = {
  name: "TemplateTenBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateTenBuilderPage-BliukeE1.js"), true ? [] : void 0))
};
const TemplateThreeBuilderPage = {
  name: "TemplateThreeBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateThreeBuilderPage-zjQo1fCv.js"), true ? [] : void 0))
};
const TemplateTwoBuilderPage = {
  name: "TemplateTwoBuilderPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplateTwoBuilderPage-Cb-cDWJW.js"), true ? [] : void 0))
};
const TrainingWebsitesEditPage = {
  name: "TrainingWebsitesEditPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TrainingWebsitesEditPage-C8yYujh5.js"), true ? __vite__mapDeps([45,1,2,3,33,13]) : void 0))
};
const TrainingWebsitesNewTrainingWebsitePage = {
  name: "TrainingWebsitesNewTrainingWebsitePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TrainingWebsitesNewTrainingWebsitePage-CxEfuSjj.js"), true ? [] : void 0))
};
const TrainingWebsitesPage = {
  name: "TrainingWebsitesPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TrainingWebsitesPage-BzEXt-5o.js"), true ? __vite__mapDeps([46,1]) : void 0))
};
const UpgradePurchaseSuccessPage = {
  name: "UpgradePurchaseSuccessPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./UpgradePurchaseSuccessPage-D-kwnTQM.js"), true ? __vite__mapDeps([47,12,10]) : void 0))
};
const WebsiteChatPage = {
  name: "WebsiteChatPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./WebsiteChatPage-VebCn-tN.js"), true ? __vite__mapDeps([48,13,11,21,24,25,26,15,14,9,10,49,36,37,5,50,35,51,33,12,3,32,52,31,30]) : void 0))
};
const WebsiteChatSettingsPage = {
  name: "WebsiteChatSettingsPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./WebsiteChatSettingsPage-CeKMBZP6.js"), true ? __vite__mapDeps([53,21,12,10,16,11,15,14,37,36,49,54,51,55,34,35,38,56,25,26,57,27]) : void 0))
};
const WebsitePreviewPage = {
  name: "WebsitePreviewPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./WebsitePreviewPage-CNudNwJO.js"), true ? __vite__mapDeps([58,3,52,31,30,24,25,26]) : void 0))
};
const DomainDomainAddPage = {
  name: "DomainDomainAddPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainAddPage-Dui3Di5u.js"), true ? __vite__mapDeps([59,12,10,54,11,15,14,38,37,36,49]) : void 0))
};
const DomainDomainConfirmDnsPage = {
  name: "DomainDomainConfirmDnsPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainConfirmDnsPage-WTGzAe-r.js"), true ? __vite__mapDeps([60,21,12,10,61,40,49,36,54,11,15,14]) : void 0))
};
const DomainDomainPage = {
  name: "DomainDomainPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainPage-DbOVy7Wx.js"), true ? __vite__mapDeps([62,12,10,1,61,40,49,36]) : void 0))
};
const DomainDomainSearchPage = {
  name: "DomainDomainSearchPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainSearchPage-Pp6UoDnH.js"), true ? __vite__mapDeps([63,13,12,10,15,11,14,38,16,56,36,49,57,24,25,26]) : void 0))
};
const DomainDomainVerifyNameserversPage = {
  name: "DomainDomainVerifyNameserversPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainVerifyNameserversPage-QH6lKLci.js"), true ? __vite__mapDeps([64,21,12,10,50,35,11,36,54,15,55,57,49,14,27,26]) : void 0))
};
const DomainDomainsPage = {
  name: "DomainDomainsPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./DomainsPage-BCsxmRU3.js"), true ? __vite__mapDeps([65,8,9,10,11,12,1,16,15,14]) : void 0))
};
const AdminChatTemplateChatTemplatePage = {
  name: "AdminChatTemplateChatTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./ChatTemplatePage-CsRyD_fm.js"), true ? __vite__mapDeps([66,1]) : void 0))
};
const AdminChatTemplateChatTemplatesPage = {
  name: "AdminChatTemplateChatTemplatesPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./ChatTemplatesPage-BHazjiT7.js"), true ? __vite__mapDeps([67,1,68]) : void 0))
};
const AdminChatTemplateEditChatTemplatePage = {
  name: "AdminChatTemplateEditChatTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./EditChatTemplatePage-DA0YWz9_.js"), true ? __vite__mapDeps([69,1,70,40]) : void 0))
};
const AdminChatTemplateNewChatTemplatePage = {
  name: "AdminChatTemplateNewChatTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./NewChatTemplatePage-CuWW9GMm.js"), true ? __vite__mapDeps([71,70,40]) : void 0))
};
const AdminChatTemplatePreviewChatTemplatePage = {
  name: "AdminChatTemplatePreviewChatTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./PreviewChatTemplatePage-idXFkrvX.js"), true ? __vite__mapDeps([72,1,3,30]) : void 0))
};
const AdminKVStorageEditKVStoragePage = {
  name: "AdminKVStorageEditKVStoragePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./EditKVStoragePage-BDqX34St.js"), true ? __vite__mapDeps([73,1,74,40]) : void 0))
};
const AdminKVStorageKVStoragePage = {
  name: "AdminKVStorageKVStoragePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./KVStoragePage-1T1JCZsm.js"), true ? __vite__mapDeps([75,1,68]) : void 0))
};
const AdminKVStorageKVStoragesPage = {
  name: "AdminKVStorageKVStoragesPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./KVStoragesPage-DEtm2gE7.js"), true ? __vite__mapDeps([76,1,68]) : void 0))
};
const AdminKVStorageNewKVStoragePage = {
  name: "AdminKVStorageNewKVStoragePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./NewKVStoragePage-DVcAqQYl.js"), true ? __vite__mapDeps([77,74,40]) : void 0))
};
const AdminTemplateEditTemplatePage = {
  name: "AdminTemplateEditTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./EditTemplatePage-CM93fTWh.js"), true ? __vite__mapDeps([78,1,79,40]) : void 0))
};
const AdminTemplateNewTemplatePage = {
  name: "AdminTemplateNewTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./NewTemplatePage-9rEctMb7.js"), true ? __vite__mapDeps([80,79,40]) : void 0))
};
const AdminTemplateTemplatePage = {
  name: "AdminTemplateTemplatePage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplatePage-Cyv1AT_d.js"), true ? __vite__mapDeps([81,1,68]) : void 0))
};
const AdminTemplateTemplatesPage = {
  name: "AdminTemplateTemplatesPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./TemplatesPage-PgF6rR7v.js"), true ? __vite__mapDeps([82,1,68]) : void 0))
};
const AdminUserUserPage = {
  name: "AdminUserUserPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./UserPage-Bg05icDF.js"), true ? __vite__mapDeps([83,14,11,15,84]) : void 0))
};
const AdminUserUsersPage = {
  name: "AdminUserUsersPage",
  prerenderLoader: (name) => ({
    default: globalThis.__REDWOOD__PRERENDER_PAGES[name]
  }),
  LazyComponent: reactExports.lazy(() => __vitePreload(() => import("./UsersPage-BwQ2e3rf.js"), true ? __vite__mapDeps([85,14,11,38,15,84]) : void 0))
};
const Routes = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Router, { useAuth, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", roles: "admin", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: ScaffoldLayout, title: "KvStorages", titleTo: "adminKvStorages", buttonLabel: "New KvStorage", buttonTo: "adminNewKvStorage", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/kv-storages/new", page: AdminKVStorageNewKVStoragePage, name: "adminNewKvStorage" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/kv-storages/{id}/edit", page: AdminKVStorageEditKVStoragePage, name: "adminEditKvStorage" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/kv-storages/{id}", page: AdminKVStorageKVStoragePage, name: "adminKvStorage" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/kv-storages", page: AdminKVStorageKVStoragesPage, name: "adminKvStorages" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", roles: "admin", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: ScaffoldLayout, title: "Templates", titleTo: "adminTemplates", buttonLabel: "New Template", buttonTo: "adminNewTemplate", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/templates/new", page: AdminTemplateNewTemplatePage, name: "adminNewTemplate" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/templates/{id}/edit", page: AdminTemplateEditTemplatePage, name: "adminEditTemplate" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/templates/{id}", page: AdminTemplateTemplatePage, name: "adminTemplate" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/templates", page: AdminTemplateTemplatesPage, name: "adminTemplates" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PrivateSet, { unauthenticated: "login", roles: "support", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/users/{id}", page: AdminUserUserPage, name: "adminUser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/users", page: AdminUserUsersPage, name: "adminUsers" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(PrivateSet, { unauthenticated: "login", roles: "admin", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: ScaffoldLayout, title: "ChatTemplates", titleTo: "adminChatTemplates", buttonLabel: "New Chat Template", buttonTo: "adminNewChatTemplate", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/chat/templates/new", page: AdminChatTemplateNewChatTemplatePage, name: "adminNewChatTemplate" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/chat/templates/{id}/edit", page: AdminChatTemplateEditChatTemplatePage, name: "adminEditChatTemplate" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/chat/templates/{id}", page: AdminChatTemplateChatTemplatePage, name: "adminChatTemplate" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/chat/templates", page: AdminChatTemplateChatTemplatesPage, name: "adminChatTemplates" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/chat/templates/{id}/preview", page: AdminChatTemplatePreviewChatTemplatePage, name: "adminPreviewChatTemplate" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", roles: "admin", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: FineTuningNavBarLayout, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/fine-tuning/playground", page: FineTuningPlaygroundPage, name: "fineTuningPlayground" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/fine-tuning/examples", page: FineTuningExamplesPage, name: "fineTuningExamples" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", roles: ["admin", "training"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: TrainingWebsitesNavBarLayout, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/training-websites/new", page: TrainingWebsitesNewTrainingWebsitePage, name: "newTrainingWebsite" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/training-websites/{id}", page: TrainingWebsitesEditPage, name: "editTrainingWebsite" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/training-websites", page: TrainingWebsitesPage, name: "trainingWebsites" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-editor", page: TemplateEditorPage, name: "templateEditor" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-editor/new", page: TemplateEditorNewPage, name: "templateEditorNew" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-editor/validate", page: TemplateEditorValidatorPage, name: "templateEditorValidator" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-editor/{id}/edit", page: TemplateEditorEditPage, name: "templateEditorEdit" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-sections", page: TemplateSectionsPage, name: "templateSections" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-sections/{id}/edit", page: TemplateSectionEditPage, name: "editTemplateSection" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", roles: "admin", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Set$1, { wrap: TrainingWebsitesNavBarLayout, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/admin/recent-signups", page: RecentSignupsPage, name: "recentSignups" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Set$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: ChatLayout, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website-chat/{id}", page: WebsiteChatPage, name: "websiteChat" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website-chat/{id}/settings/{tab}", page: WebsiteChatSettingsPage, name: "websiteChatSettingsTab" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website-chat/{id}/settings/plugins/{pluginId}", page: WebsiteChatSettingsPage, name: "websiteChatPluginSettings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website-chat/{id}/{page...}", page: WebsiteChatPage, name: "websiteChatPage" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: ChatLayout, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains", page: DomainDomainsPage, name: "domains" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains/add", page: DomainDomainAddPage, name: "domainAdd" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains/{id}/confirm-dns", page: DomainDomainConfirmDnsPage, name: "domainConfirmDns" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains/{id}/verify-nameservers", page: DomainDomainVerifyNameserversPage, name: "domainVerifyNameservers" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains/search", page: DomainDomainSearchPage, name: "domainSearch" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/domains/{id}", page: DomainDomainPage, name: "domain" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/purchase-success", page: PurchaseSuccessPage, name: "purchaseSuccess" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/upgrade-purchase-success", page: UpgradePurchaseSuccessPage, name: "upgradePurchaseSuccess" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PrivateSet, { unauthenticated: "login", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Set$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", page: HomePage, name: "home" }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Set$1, { wrap: AppNavBarLayout, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website/{id}", redirect: "/website-chat/{id}", name: "website" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website/{id}/settings", redirect: "/website-chat/{id}/settings/general", name: "websiteSettings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website/{id}/plans", redirect: "/website-chat/{id}/settings/plans", name: "websitePlansSettings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website/{id}/custom-domain", redirect: "/website-chat/{id}/settings/domain", name: "websiteCustomDomainSettings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website/{id}/delete-website", redirect: "/website-chat/{id}/settings/delete", name: "websiteDeleteWebsiteSettings" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/1", page: TemplateOneBuilderPage, name: "templateOneBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/2", page: TemplateTwoBuilderPage, name: "templateTwoBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/3", page: TemplateThreeBuilderPage, name: "templateThreeBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/4", page: TemplateFourBuilderPage, name: "templateFourBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/5", page: TemplateFiveBuilderPage, name: "templateFiveBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/6", page: TemplateSixBuilderPage, name: "templateSixBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/7", page: TemplateSevenBuilderPage, name: "templateSevenBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/8", page: TemplateEightBuilderPage, name: "templateEightBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/9", page: TemplateNineBuilderPage, name: "templateNineBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/template-builder/10", page: TemplateTenBuilderPage, name: "templateTenBuilder" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/website-preview", page: WebsitePreviewPage, name: "websitePreview" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login-success", page: LoginSuccessPage, name: "loginSuccess" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/logout", page: LogoutPage, name: "logout" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/signup", page: SignupPage, name: "signup" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login", page: LoginPage, name: "login" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/claim", page: ClaimPage, name: "claim" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { notfound: true, page: NotFoundPage })
  ] });
};
{
  init({
    dsn: "https://4d4ccc012635e517019ecffe578a424e@o4505134687977472.ingest.sentry.io/4506230476177408",
    integrations: [
      // Sentry.browserTracingIntegration(),
      // Sentry.replayIntegration(),
      captureConsoleIntegration({
        levels: ["error"]
      })
    ],
    beforeSend(event) {
      var _a3, _b2;
      const suppressedErrors = ["Missing Refresh Token", "Unknown or invalid refresh token"];
      if (suppressedErrors.some((error) => {
        var _a4;
        return (_a4 = event.message) == null ? void 0 : _a4.includes(error);
      }) || ((_b2 = (_a3 = event.exception) == null ? void 0 : _a3.values) == null ? void 0 : _b2.some((exception) => suppressedErrors.some((error) => exception.value.includes(error))))) {
        return null;
      }
      return event;
    }
    // Performance Monitoring
    // tracesSampleRate: 1.0,
    // Session Replay
    // replaysSessionSampleRate: 0.0,
    // replaysOnErrorSampleRate: 1.0,
  });
}
const options = {
  session_recording: {
    maskAllInputs: false,
    maskInputOptions: {
      password: true
    }
  }
};
const App = () => /* @__PURE__ */ jsxRuntimeExports.jsx(PostHogProvider, { apiKey: "phc_IS9NHfACBg6Ul9wpMrfnfiBB7DvwFUYn6VPfgoiLi2c", options, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FatalErrorBoundary, { page: FatalErrorPage, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RedwoodProvider, { titleTemplate: "%PageTitle | %AppTitle", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AuthProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RedwoodApolloProvider, { useAuth, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, {}) }) }) }) }) });
const redwoodAppElement = document.getElementById("redwood-app");
if (((_c = redwoodAppElement.children) == null ? void 0 : _c.length) > 0) {
  hydrateRoot(redwoodAppElement, /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}));
} else {
  const root2 = createRoot(redwoodAppElement);
  root2.render(/* @__PURE__ */ jsxRuntimeExports.jsx(App, {}));
}
export {
  Ie as $,
  Fe as A,
  i$2 as B,
  te$1 as C,
  b$2 as D,
  E$1 as E,
  F$2 as F,
  R$1 as G,
  R$3 as H,
  I$3 as I,
  f$3 as J,
  K$1 as K,
  Link as L,
  m$3 as M,
  s$3 as N,
  O$2 as O,
  P$2 as P,
  l$2 as Q,
  React$2 as R,
  re$1 as S,
  T$3 as T,
  C$2 as U,
  O$4 as V,
  helmetPkg as W,
  X$3 as X,
  useParams as Y,
  useLocation as Z,
  useQuery$1 as _,
  useMutation$1 as a,
  _t as a0,
  getDefaultExportFromCjs as a1,
  Kind$1 as a2,
  useCellCacheContext as a3,
  fragmentRegistry as a4,
  reactDomExports as a5,
  o$5 as a6,
  u$7 as a7,
  f$4 as a8,
  useFloating$1 as a9,
  compact$1 as aA,
  NetworkStatus as aB,
  isNonEmptyArray$1 as aC,
  canUseDOM$1 as aD,
  m$4 as aE,
  Me$1 as aF,
  c$3 as aG,
  s$6 as aH,
  n$5 as aI,
  xe$1 as aJ,
  Re$1 as aK,
  be$2 as aL,
  x$1 as aM,
  _$3 as aN,
  R$2 as aO,
  d$4 as aP,
  r$2 as aQ,
  $f7dceffc5ad7768b$export$4e328f61c538687f as aR,
  $6179b936705e76d3$export$ae780daf29e6d456 as aS,
  w$4 as aT,
  e$3 as aU,
  ye$1 as aV,
  _$2 as aW,
  j$4 as aX,
  Fe$1 as aY,
  A$2 as aZ,
  h$3 as a_,
  offset as aa,
  shift as ab,
  flip as ac,
  size as ad,
  arrow as ae,
  hide as af,
  limitShift as ag,
  autoUpdate as ah,
  usePostHog as ai,
  useMatch as aj,
  React$3 as ak,
  ReactDOM as al,
  __assign as am,
  __rest as an,
  __spreadArray as ao,
  rehacktExports as ap,
  mergeOptions$1 as aq,
  verifyDocumentType as ar,
  DocumentType as as,
  ApolloError as at,
  equal$2 as au,
  React$1 as av,
  invariant$3 as aw,
  canUseLayoutEffect$1 as ax,
  getApolloContext as ay,
  maybeDeepFreeze$1 as az,
  namedRoutes as b,
  n$6 as c,
  n$4 as d,
  u$3 as e,
  o$4 as f,
  gql as g,
  u$6 as h,
  a$2 as i,
  jsxRuntimeExports as j,
  L$2 as k,
  l$3 as l,
  f$6 as m,
  navigate as n,
  o$3 as o,
  p$4 as p,
  c$2 as q,
  reactExports as r,
  s$5 as s,
  f$2 as t,
  useAuth as u,
  t$4 as v,
  u$4 as w,
  x$2 as x,
  y$4 as y,
  ze as z
};
//# sourceMappingURL=index-Cl9LNxzF.js.map
